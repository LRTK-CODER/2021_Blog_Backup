{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/29/hello-world/"},{"title":"백준 브론즈5 - 1001번 문제","text":"백준 1001번 문제A-BLink : https://www.acmicpc.net/problem/1001 1print(int(input())-int(input())) 1000번 문제처럼 데이터를 입력받아 정수형으로 변환하여 -를 해주었다.하지만 결과는? 런타임 에러이유는 모르겠다… 혹시 아시는 분은 댓글 부탁드립니다… 일단 입력값은 ‘3 2’이다. 이를 입력받아야히는데 어떻게 입력을 받아야할까? 123a, b = input().split()print(a)print(b) split함수를 사용하면 하나의 input함수로 여러 변수에 값을 넣어줄 수 있다. splitLink : https://wikidocs.net/13#split split함수는 문자열을 나누는 함수이다. 12s = 'a b c d'print(s.split()) # ['a', 'b', 'c', 'd'] 출력 list로 return되어지만, input에는 각 하나씩 입력되어 변수에 저장될 것이다.이를 이용해서 문제를 해결해보자. 12a, b = input().split()print(int(a)-int(b)) input은 문자열로 데이터를 넣어주기 때문에 값을 계산하기 위해서는 정수 변환이 필수이다.하지만 입력받은 정수가 100개라면? 하나하나 int함수를 넣어서 계산해야하나?답은 map함수에 있다. mapLink : https://wikidocs.net/32#map map(f, iterable)로 함수(f)와 반복 가능한(iterable) 자료형을 입력받아 f에 iterable를 넣어서 f의 결과를 묶어서 돌려주는 함수이다.","link":"/2020/11/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EB%93%9C5-1001%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1000번 문제","text":"백준 1000번 문제A+BLink : https://www.acmicpc.net/problem/1000 1print(int(input())+int(input())) 간단하게 생각할 수 있는 코드이다.input로 값을 입력받아 int 함수를 이용하여 문자에서 정수로 데이터타입을 변경하여 더하여 print 함수를 이용하여 출력하였다. 이 코드를 좀 더 python스럽게 만들어 보자. 1print(eval('+'.join(input()))) eval, join 함수를 사용하여 python스럽게 아주 간단하게 변경되었다.join과 eval에 대하여 알아보자. 문자열 삽입(join)Link : https://wikidocs.net/13#join 문자열의 문자 사이에 문자를 삽입하는 함수이다. 1print('+'.join('1234')) # 1+2+3+4 출력 위와 같이 문자열인 1234의 문자 사이에 +를 삽입되었다.python스럽게 고친 코드도 이를 이용하여 입력 받은 문자열에 +를 삽입하였다.허나 이상한 부분이 있다. join은 문자열의 문자 사이에 문자를 넣은 함수이지 계산을 하는 함수는 아니다.그럼 어떻게 계산을 할 수 있을지는 eval함수에 답이 있다. evalLink : https://wikidocs.net/32#eval eval함수는 실행 가능한 문자열을 실행한 결과값을 돌려주는 마법의 함수이다. 1234print(&quot;'Hi' + '!!!'&quot;) # 'Hi' + '!!!' 출력print(eval(&quot;'Hi' + '!!!'&quot;)) # Hi!!! 출력print(eval('+'.join('1234'))) # 10 출력 위와 같이 실행 가능한 문자를 실행해주는 함수이다.자세한 예제를 보고 싶다면 programiz 사이트에서 참고하면 좋다. Link : https://www.programiz.com/python-programming/methods/built-in/eval","link":"/2020/11/07/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1001%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1271번 문제","text":"백준 1271번 문제엄청난 부자2link : https://www.acmicpc.net/problem/1271 12a, b = map(int, input().split())print(f'{a//b}\\n{a%b}') 1001번 문제와 같은 방식으로 풀이를 했다.다만 틀린 점은 print함수의 문자열 앞에 f가 있다는 점이다.f의 뜻은 fomat이라는 뜻이다. 원래 이 기능은 생긴지 얼마 안되었다.이 기능이 없기 전까지는 print(‘{0}\\n{1}’.fomat(a//b, a%b))와 같이 fomat함수를 사용하였다.하지만 가독성이 떨어져서 문자열 앞에 f를 표시하는 것으로 변경되었고, 문자열 안에 바로 변수를 선언하여서 가독성을 높였다. 이제 좀 더 python스럽게 변경해보자. 1print(*divmod(*map(int,input().split()))) 특이한 것이 있다. 저 *은 무엇인가?? 곱하기인가?아니다. *은 파이썬이 지원하는 많은 연산자 중 하나인 Asterisk이다. Asterisk파이썬에서는 *는 곱셈 이상의 여러 의미를 갖는 연산이 가능케한다. 그 중 위의 코드는 컨테이너 타입의 데이터를 Unpacking할 때 쓰이는 Asterisk이다. 12345print('None Asterlisk : ', map(int, input().split()), '\\n')# None Asterlisk : &lt;map object at 0x10e4f20a0&gt; 출력print('Asterlisk : ', *map(int, input().split()), '\\n')# Asterlisk : 100 10 출력 123456a = [1, 2, 3, 4]print('None Asterlisk : ', a, '\\n')# None Asterlisk : [1, 2, 3, 4] print('Asterlisk : ', *a, '\\n')# Asterlisk : 1 2 3 4 예시 코드를 보니 아주 명확하게 구별이 가능했다.혹시 더 알아보고 싶으면 아래의 링크로 알아보면 된다.link : https://mingrammer.com/understanding-the-asterisk-of-python/ *은 해결했으니, divmod함수를 알아보자. divmodlink : https://wikidocs.net/32#divmod divmod함수는 이름 뜻대로 두 개의 인자값을 나눈 몫과 나머지를 튜플 형태로 return 해주는 함수이다. 12345print(divmod(7,3))# (2, 1) 출력print(divmod(100, 10))# (10, 0) 출력","link":"/2020/11/09/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1550번 문제","text":"백준 1550번 문제16진수link : https://www.acmicpc.net/problem/1550 1print(int(input(), 16)) int함수에 옵션을 주어서 간단하게 문제를 해결하였다. int함수의 옵션은 밑의 주소에서 확인하면 된다.link : https://wikidocs.net/32#int","link":"/2020/11/10/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1550%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2338번 문제","text":"백준 2338번 문제긴자리 계산link : https://www.acmicpc.net/problem/2338 12a, b = map(int, input().split())print(f'{a+b}\\n{a-b}\\n{a*b}') 1271번 문제풀이 방식으로 문제 풀이를 하였다. 이렇게 제출해도 정답으로 인정 받지만, 예제 입력을 보면 한 줄이 아닌 두 줄로 입력을 하고 있다. 이점을 걸리신 분들은 다음과 같은 방식으로 코드를 수정하면 된다. 12a, b = map(int, open(0))print(f'{a+b}\\n{a-b}\\n{a*b}') 이 방식은 정해진 변수에 계속 입력을 받을 수 있고, stdout방식이 아닌 EOF방식으로 출력이 된다.stdout방식과 EOF방식이 무엇일까?두 개의 방식을 설명하기 앞서 선행되어야 하는 것이 입출력이 무엇인지를 알아야한다. 입출력쉽게 말해 프로그램에게 데이터를 주는 것이 입력이고, 데이터를 모니터로 보여주게 하는 것이 출력이다. 스트림우리가 데이터를 입력할 때 주로 무엇을 사용할까요? 바로 키보드와 마우스입니다.키보드와 마우스를 사용하여 프로그램에게 데이터를 전달해야하는데 전달해주는 것이 바로 **표준 입력 스트림(stdin)**입니다. 프로그램에서 모니터, 프린터로 전달하는 것은 **표준 출력 스트림(stdout)**이라고 합니다. 이 외에도 오류 출력용인 **표준 에러 스트림(stderr)**가 있습니다. 이것들은 input함수, print함수를 사용하면 생성이되고 입력과 출력이 끝나면 자동으로 종료가 됩니다. EOFEOF(End Of File)은 더 이상 데이터가 없음을 의미합니다.왜 open(0)은 EOF방식 출력이라고 제가 표현 했을까요? open(0)은 입력 받는 것이 무한 반복 하기 때문입니다.그 때문에 프로그램에게 EOF을 알려 줘야 무한 입력이 끝나고, 값이 출력될 수 있기 때문에 EOF방식 출력이라고 표현했습니다. – 출론 –그럼 왜 open(0)이 무한 입력이 될까요?open함수는 파일을 읽기 위해 주로 사용되는 함수입니다. 즉, 파일 입력 함수이죠.open함수의 대표적인 인자값은 open(file, mode)입니다.그런데 파일이 0이다? open함수 입장에서는 읽을 데이터가 없으니 직접 데이터를 입력하라고 입력창을 띄어주는 것 같습니다. 이에 대해서는 python의 open함수 코드를 열어봐서 분석할 예정입니다.","link":"/2020/11/10/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2338%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2475번 문제","text":"백준 2475번 문제검증수link : https://www.acmicpc.net/problem/2475 12a, b, c, e, f = map(int, input().split())print((a**2 + b**2 + c**2 + e**2 + f**2)%10) **은 제곱근을 의미한다. a**2 =&gt; a^2를 의미 위 코드를 python스럽게 변경해보자. 1print( sum( a**2 for a in map(int, input().split()) )%10 ) 보기 좋게 한 줄로 표현이 되었다.근데 이상하게 print함수 안에 for문이 들어가 있다.이 형식은 제너레이터 표현라고 한다. itertorlink : https://bluese05.tistory.com/55 itertor - 제너레이터 - 제너레이터 표현 순으로 봐야 좀 더 이해가 쉽다. itertor은 next 메소드로 데이터를 순차적으로 호출 가능한 object이다. 12345678x = [1, 2, 3]print(type(x), '\\n') # &lt;class 'list'&gt; 출력y = iter(x)print(type(y), '\\n') #&lt;class 'list_iterator'&gt; for i in range(4): print(next(y)) # 1 2 3 출력 이와 같이 iter함수를 사용하여 iterator 형식으로 변환할 수 있다.하지만 우리는 반복문을 쓸 때 next 메소드를 쓴 적이 없다.이유는 파이썬 내부에서 임시로 list를 iterator로 자동 변환해주기 때문이다. generatorlink : https://bluese05.tistory.com/56 제너레이터는 iterator를 반환하는 함수이다.제너레이터는 일반적인 함수와 비슷하게 보이지만, 차이점이 있다.yield라는 존재가 그 차이점이다. 12345678910111213141516171819202122232425def ex(n): i = 0 while i &lt; n: yield i i += 1 while i &gt; n: yield print(i, 'no!!') break return idef test(): a = 10000 return aprint(*ex(-2), '\\n') # 0 no!!# None 출력print(*ex(3), '\\n') # 0 1 2 출력 print(i, '\\n') # 3 출력print(test()) # 10000 출력print(a) # 0 출력 yield함수가 끝나면 함수 안의 변수들은 메모리 상에서 clear된다.하지만 yield를 사용한 경우는 다른 형식으로 흘려간다.함수에서 yield를 만나면, 해당 함수는 그 상태로 정지가 되어 next 메소드를 호출한 쪽으로 yield를 전달하게 된다.이 후 해당 함수는 종료되는 것이 아니라, 함수 내부 데이터가 메모리에 그대로 유지하고 실행된다. 위의 예제 코드에서 ex함수가 종료되어도 ex함수의 i 변수의 데이터가 메모리에 남아 있는 것을 알 수 있다. generator expreession제너레이터 표현은 제너레이터를 쉽게 사용할 수 있도록 해준다.list comprehension과 비슷하지만, [] 대신 ()를 사용하면 된다. 1234567891011121314151617s = [1,2,3,4,5]print('--list comprehension--')[print(i) for i in s]print('\\n')# --list comprehension--# 1# 2# 3# 4# 5 출력print('--generator expreession--')(print(i) for i in s)# --generator expreession--# &lt;generator object &lt;genexpr&gt; at 0x113b3a890&gt; 출력 복잡한데 왜 사용할까?사용하는 이유는 성능 때문이다. 일반적인 for문을 돌리는 것보다 generator expreession과 list comprehension형식으로 돌리는게 속도와 메모리가 성능이 좋다. 다른 방식들도 있는데 이는 밑의 링크를 참고하면 된다.link : https://mingrammer.com/introduce-comprehension-of-python/","link":"/2020/11/12/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2475%EB%B2%88-%EB%AC%B8%EC%A0%9C/"}],"tags":[{"name":"backjoon","slug":"backjoon","link":"/tags/backjoon/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"백준 브론즈5","slug":"백준-브론즈5","link":"/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885/"},{"name":"backjoon bronze5","slug":"backjoon-bronze5","link":"/tags/backjoon-bronze5/"}],"categories":[{"name":"백준 브론즈5","slug":"백준-브론즈5","link":"/categories/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885/"}]}