<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LRTK Blog</title>
    <link>https://lrtk-coder.github.io/</link>
    
    <atom:link href="https://lrtk-coder.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Coding, Security, IT News 등 정리한 블로그</description>
    <pubDate>Mon, 01 Mar 2021 23:17:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>백준 실버 1920번 문제</title>
      <link>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-1920%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-1920%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Mon, 01 Mar 2021 14:15:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;수-찾기&quot;&gt;&lt;a href=&quot;#수-찾기&quot; class=&quot;headerlink&quot; title=&quot;수 찾기&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1920&quot;&gt;수 찾기&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;N개의 정수 A[1]</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="수-찾기"><a href="#수-찾기" class="headerlink" title="수 찾기"></a><a href="https://www.acmicpc.net/problem/1920">수 찾기</a></h1><p>N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; input()</span><br><span class="line">data &#x3D; &#123;*map(int, input().split())&#125;</span><br><span class="line">n2 &#x3D; input()</span><br><span class="line">data2 &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">for _ in data2:</span><br><span class="line">    if _ in data:</span><br><span class="line">        print(1)</span><br><span class="line">    else:</span><br><span class="line">        print(0)</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>Set 함수를 이용하여 혹시나 있을 첫번째 데이터인 data 속의 값의 중복 제거 후 data2의 값과 하나씩 비교하여 있으면 1를 출력</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%844/">백준 실버4</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84-1920%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 실버 5397번 문제</title>
      <link>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-5397%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-5397%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Mon, 01 Mar 2021 03:42:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;키로거&quot;&gt;&lt;a href=&quot;#키로거&quot; class=&quot;headerlink&quot; title=&quot;키로거&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/5397&quot;&gt;키로거&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;창영이는 강산이의 비밀번호를</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="키로거"><a href="#키로거" class="headerlink" title="키로거"></a><a href="https://www.acmicpc.net/problem/5397">키로거</a></h1><p>창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다.</p><p>키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다.</p><p>강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오.</p><h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test_case &#x3D; int(input())</span><br><span class="line">for _ in range(test_case):</span><br><span class="line">    left_stack, right_stack &#x3D; [], []</span><br><span class="line">    cuser &#x3D; input()</span><br><span class="line"></span><br><span class="line">    for data in cuser:</span><br><span class="line">        if data &#x3D;&#x3D; &#39;&lt;&#39;:</span><br><span class="line">            if left_stack:</span><br><span class="line">                right_stack.append(left_stack.pop())</span><br><span class="line">        elif data &#x3D;&#x3D; &#39;&gt;&#39;:</span><br><span class="line">            if right_stack:</span><br><span class="line">                left_stack.append(right_stack.pop())</span><br><span class="line">        elif data &#x3D;&#x3D; &#39;-&#39;:</span><br><span class="line">            if left_stack:</span><br><span class="line">                left_stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            left_stack.append(data)</span><br><span class="line">    left_stack.extend(reversed(right_stack))</span><br><span class="line">    print(&#39;&#39;.join(left_stack))</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>두 개의 스택을 선언하여, 진짜 커서가 움직이는 것처럼 구현하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843/">백준 실버3</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-5397%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 실버 1966번 문제</title>
      <link>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1966%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1966%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Mon, 01 Mar 2021 02:09:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;프린터-큐&quot;&gt;&lt;a href=&quot;#프린터-큐&quot; class=&quot;headerlink&quot; title=&quot;프린터 큐&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1966&quot;&gt;프린터 큐&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;여러분도 알다</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="프린터-큐"><a href="#프린터-큐" class="headerlink" title="프린터 큐"></a><a href="https://www.acmicpc.net/problem/1966">프린터 큐</a></h1><p>여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.</p><p>현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.<br>나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.<br>예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.</p><p>여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test_case &#x3D; int(input())</span><br><span class="line">for _ in range(test_case):</span><br><span class="line">    n, m &#x3D; map(int, input().split())</span><br><span class="line">    queue &#x3D; [(data, idx) for idx, data in enumerate([*map(int, input().split())])]</span><br><span class="line"></span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    while True:</span><br><span class="line">        if queue[0][0] &#x3D;&#x3D; max(queue, key&#x3D;lambda x: x[0])[0]:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            if queue[0][1] &#x3D;&#x3D; m:</span><br><span class="line">                print(count)</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                queue.pop(0)</span><br><span class="line">        else:</span><br><span class="line">            queue.append(queue.pop(0))</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><ul><li>몇번을 입력 받을 건가? : test_case</li><li>Queue 안의 문서 갯수 : n</li><li>Queue에서 몇번째로 POP되는지 알고자하는 번수 : m</li><li>Queue</li></ul><p>위 4개를 입력받고, 해당 Queue에는 중요도가 저장이 된다.</p><p><img src="/images/pasted-248.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_case &#x3D; int(input())</span><br><span class="line">for _ in range(test_case):</span><br><span class="line">    n, m &#x3D; map(int, input().split())</span><br><span class="line">    queue &#x3D; [*map(int, input().split())]</span><br><span class="line">    queue &#x3D; [(data, idx) for idx, data in enumerate(queue)]</span><br></pre></td></tr></table></figure><p>문제풀이에선 queue를 한 줄로 표현했으나, 위와 같이 정의할 수도 있다.<br>queue의 값에 index(문서)도 같이 포함을 하여, 몇번째 문서인지를 검사할 수 있도록 하였다.</p><p><img src="/images/pasted-249.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">while True:</span><br><span class="line">if queue[0][0] &#x3D;&#x3D; max(queue, key&#x3D;lambda x: x[0])[0]:</span><br><span class="line">count +&#x3D; 1</span><br><span class="line">    else:</span><br><span class="line">    queue.append(queue.pop(0))</span><br></pre></td></tr></table></figure><p>무한 루프를 이용하여, 중요도가 가장 큰 값이 pop을 할 수 있도록 순회를 하였다.</p><p>이렇게 Queue의 특성을 이용하여 풀이를 진행하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843/">백준 실버3</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1966%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈 2920번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/28/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2920%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/28/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2920%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Sun, 28 Feb 2021 06:27:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;음계&quot;&gt;&lt;a href=&quot;#음계&quot; class=&quot;headerlink&quot; title=&quot;음계&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2920&quot;&gt;음계&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;다장조는 c d e f g a b </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="음계"><a href="#음계" class="headerlink" title="음계"></a><a href="https://www.acmicpc.net/problem/2920">음계</a></h1><p>다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, …, C를 8로 바꾼다.</p><p>1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다.</p><p>연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오.</p><h2 id="문제풀이1"><a href="#문제풀이1" class="headerlink" title="문제풀이1"></a>문제풀이1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">count_check &#x3D; True</span><br><span class="line">if n[0] &#x3D;&#x3D; 1:</span><br><span class="line">    for i in range(len(n)-1):</span><br><span class="line">        if n[i] &lt; n[i+1]:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            count_check &#x3D; False</span><br><span class="line">        if count_check &#x3D;&#x3D; False:</span><br><span class="line">            print(&#39;mixed&#39;)</span><br><span class="line">            break</span><br><span class="line">    if count_check &#x3D;&#x3D; True:</span><br><span class="line">        print(&#39;ascending&#39;)</span><br><span class="line"></span><br><span class="line">elif n[0] &#x3D;&#x3D; 8:</span><br><span class="line">    for i in range(len(n)-1):</span><br><span class="line">        if n[i] &gt; n[i+1]:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            count_check &#x3D; False</span><br><span class="line">        if count_check &#x3D;&#x3D; False:</span><br><span class="line">            print(&#39;mixed&#39;)</span><br><span class="line">            break</span><br><span class="line">    if count_check &#x3D;&#x3D; True:</span><br><span class="line">        print(&#39;descending&#39;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    print(&#39;mixed&#39;)</span><br></pre></td></tr></table></figure><h3 id="풀이1-설명"><a href="#풀이1-설명" class="headerlink" title="풀이1 설명"></a>풀이1 설명</h3><p>문제에서 나타는 경우의 수는,</p><ul><li>1 2 3 4 5 6 7 8 : ‘ascending’</li><li>8 7 6 5 4 3 2 1 : ‘descending’</li><li>둘 다 아니면 mixed</li></ul><p>위 3개로 볼 수 있다.</p><p>그래서 나는 입력받은 값들을 리스트로 저장하여, 맨 첫번째 자리를 검사였다.</p><ul><li>만약 1이면, ascending인 오름차순</li><li>만약 8이면, descending인 내림차순</li><li>둘 다 아니면 mixed</li></ul><p>그 후, 진짜 오름차순과 내림차순으로 되어 있는지 검사를 하였다.</p><h2 id="문제풀이2"><a href="#문제풀이2" class="headerlink" title="문제풀이2"></a>문제풀이2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">ascending &#x3D; True</span><br><span class="line">descending &#x3D; True</span><br><span class="line"></span><br><span class="line">for i in range(len(n)-1):</span><br><span class="line">    if n[i] &lt; n[i+1]:</span><br><span class="line">        descending &#x3D; False</span><br><span class="line">    elif n[i] &gt; n[i+1]:</span><br><span class="line">        ascending &#x3D; False</span><br><span class="line">    else:</span><br><span class="line">        ascending &#x3D; False</span><br><span class="line">        descending &#x3D; False</span><br><span class="line"></span><br><span class="line">if ascending:</span><br><span class="line">    print(&#39;ascending&#39;)</span><br><span class="line">elif descending:</span><br><span class="line">    print(&#39;descending&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;mixed&#39;)</span><br></pre></td></tr></table></figure><h3 id="풀이2-설명"><a href="#풀이2-설명" class="headerlink" title="풀이2 설명"></a>풀이2 설명</h3><p>여기선 내가 깊이 생각을 못 했던 것이 있었다.</p><p>굳이 첫번째 자리를 비교를 했어야 했는지와 왜 검사 값을 1개만 썼는지이다.</p><p>이 문제풀이에선 오름차순과 내림차순을 검사하는 변수인 ascending과 descending이 있다.</p><p>반복문으로 리스트화 된 입력값을 두 개씩 비교 후 오름차순인지 내림차순인지를 검사를 한다.</p><p>둘 다 False이면, mixed가 나온다.</p><p>문제풀이1에서 더욱 간단하게 짜여졌고, 가독성도 더 좋아 보인다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882/">백준 브론즈2</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/28/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2920%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Insecure DOR (Change Secret)</title>
      <link>https://lrtk-coder.github.io/2021/02/27/Insecure-DOR-Change-Secret/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/Insecure-DOR-Change-Secret/</guid>
      <pubDate>Sat, 27 Feb 2021 23:38:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;IDOR이란&quot;&gt;&lt;a href=&quot;#IDOR이란&quot; class=&quot;headerlink&quot; title=&quot;IDOR이란?&quot;&gt;&lt;/a&gt;IDOR이란?&lt;/h1&gt;&lt;p&gt;Insecure Direct Object Reference의 약자로, 공격자가 요청 메시지의 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="IDOR이란"><a href="#IDOR이란" class="headerlink" title="IDOR이란?"></a>IDOR이란?</h1><p>Insecure Direct Object Reference의 약자로, 공격자가 요청 메시지의 URL이나 파라미터를 변경하여 정상적으로 허용되지 않은 기능을 실행하거나 다른 사용자의 리소스에 접근할 수 있는 공격</p><h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p><img src="/images/pasted-242.png"></p><p>해당 계정의 시크릿 정보를 변경하는 사이트이다.</p><p><img src="/images/pasted-243.png"></p><p>확인을 위해 Test로 변경하여 SQL Injection (Login Form/User) 문제 페이지에서 조회하겠다.</p><p>URL을 보니, Get 메소드가 아닌 Post 메소드로 작동한다. 자세하게 살펴보기 위해 프록시를 이용해서 확인하였다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/insecure_direct_object_ref_1.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: XXX.XXX.XXX.XXX</span><br><span class="line"><span class="attribute">Content-Length</span>: 36</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Origin</span>: http://XXX.XXX.XXX.XXX</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Referer</span>: http://XXX.XXX.XXX.XXX/insecure_direct_object_ref_1.php</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line"><span class="attribute">Cookie</span>: PHPSESSID=apcd6m4eamdnh3ounef36vsus5; security_level=0</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">secret=test2&amp;login=bee&amp;action=change</span><br></pre></td></tr></table></figure><p>Body 부분을 보니, 입력한 Secret 값과 계정 정보, submit 값을 보내는 것을 볼 수 있다.</p><p>만약 bee가 아닌 다른 계정을 입력하면 그 계정의 시크릿이 변경이 되는지 확인을 하였다.</p><p><img src="/images/pasted-244.png"></p><p>LRTK의 계정 시크릿 정보는 bababababa이다.</p><p>이를 login 파라미터 수정을 통해 변경하겠다.</p><p><img src="/images/pasted-245.png" alt="`secret=test&amp;login=lrtk&amp;action=change`"></p><p>수정이 되는 모습을 확인할 수 있었다.</p><h2 id="Medium-amp-High"><a href="#Medium-amp-High" class="headerlink" title="Medium &amp; High"></a>Medium &amp; High</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secret=test3&amp;token=942bdebf5252ff371011fd88bdbc300622cba84b&amp;action=change</span><br></pre></td></tr></table></figure><p>Bee 계정에서 LRTK 계정의 scret 값을 변경하려고 했는데 Low와 다르게 Token으로 계정을 분류한다. </p><p>LRTK 계정의 토큰을 모르니 실패하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/Insecure-DOR-Change-Secret/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 실버 1874번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1874%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1874%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Sat, 27 Feb 2021 23:26:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;스택-수열&quot;&gt;&lt;a href=&quot;#스택-수열&quot; class=&quot;headerlink&quot; title=&quot;스택 수열&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1874&quot;&gt;스택 수열&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;스택 (sta</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="스택-수열"><a href="#스택-수열" class="headerlink" title="스택 수열"></a><a href="https://www.acmicpc.net/problem/1874">스택 수열</a></h1><p>스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.</p><p>1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.</p><h2 id="문제풀이1"><a href="#문제풀이1" class="headerlink" title="문제풀이1"></a>문제풀이1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; int(input())</span><br><span class="line"></span><br><span class="line">count &#x3D; 1</span><br><span class="line">stack &#x3D; []</span><br><span class="line">result &#x3D; []</span><br><span class="line"></span><br><span class="line">for i in range(1, n+1):</span><br><span class="line">    data &#x3D; int(input())</span><br><span class="line">    while count &lt;&#x3D; data:</span><br><span class="line">        stack.append(count)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        result.append(&#39;+&#39;)</span><br><span class="line">    if stack[-1] &#x3D;&#x3D; data:</span><br><span class="line">        stack.pop()</span><br><span class="line">        result.append(&#39;-&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;NO&#39;)</span><br><span class="line">        exit(0)</span><br><span class="line"></span><br><span class="line">print(&#39;\n&#39;.join(result))</span><br></pre></td></tr></table></figure><h3 id="풀이1-설명"><a href="#풀이1-설명" class="headerlink" title="풀이1 설명"></a>풀이1 설명</h3><ul><li>n : 스택에 저장할 총 갯수</li><li>count : 스택에 Push할 값</li><li>data : 스택에 Pop할 값</li></ul><p>1~n까지 반복을 하는데, 그 속엔 data을 입력 받는다. 하지만 아직 스택엔 아무 값이 없어서 count가 data만큼 같아질 때까지 반복을 하는데 1씩 증가 할 때마다 스택에 넣는다.</p><p>그 후 스택의 맨 위가 data와 같은 값이면, pop을 하고 result에 <code>-</code>를 입력한다.</p><p>같은 값이 아니면 pop과 push만으로 구현이 안되니 NO를 출력하였다.</p><h2 id="문제-풀이2"><a href="#문제-풀이2" class="headerlink" title="문제 풀이2"></a>문제 풀이2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">n &#x3D; int(input())</span><br><span class="line">data &#x3D; map(lambda x: int(x.rstrip()), sys.stdin.readlines())</span><br><span class="line"></span><br><span class="line">count &#x3D; 1</span><br><span class="line">stack &#x3D; []</span><br><span class="line">result &#x3D; []</span><br><span class="line"></span><br><span class="line">for i in data:</span><br><span class="line">    while count &lt;&#x3D; i:</span><br><span class="line">        stack.append(count)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        result.append(&#39;+&#39;)</span><br><span class="line">    if stack[-1] &#x3D;&#x3D; i:</span><br><span class="line">        stack.pop()</span><br><span class="line">        result.append(&#39;-&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;NO&#39;)</span><br><span class="line">        exit(0)</span><br><span class="line">        </span><br><span class="line">print(&#39;\n&#39;.join(result))</span><br></pre></td></tr></table></figure><h3 id="풀이2-설명"><a href="#풀이2-설명" class="headerlink" title="풀이2 설명"></a>풀이2 설명</h3><p>풀이1은 반복문에서 input()로 입력값을 받고 있어서 시간이 많이 소모가 된다.</p><p>그래서 readlines()를 이용하여 값을 입력 받아서 저장된 값들을 반복문에서 하나하나 꺼내서 쓰는 방식으로 변경하였다.</p><p><img src="/images/pasted-246.png"></p><p>그 결과 시간이 대폭 줄었다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843/">백준 실버3</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1874%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈4 16204번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16204%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16204%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Sat, 27 Feb 2021 23:21:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;카드-뽑기&quot;&gt;&lt;a href=&quot;#카드-뽑기&quot; class=&quot;headerlink&quot; title=&quot;카드 뽑기&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16204&quot;&gt;카드 뽑기&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;앞 면에 O</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="카드-뽑기"><a href="#카드-뽑기" class="headerlink" title="카드 뽑기"></a><a href="https://www.acmicpc.net/problem/16204">카드 뽑기</a></h1><p>앞 면에 O와 X가 적혀있는 카드 N개가 있다. N개의 카드 중 M개의 카드의 앞면에는 O가 한 개 적혀있고, 나머지 N-M개의 카드의 앞면에는 X가 한 개 적혀있다. 카드의 뒷 면은 두 종류의 카드 모두 같은 모양이라 구분할 수 없다.</p><p>카드의 뒷 면에 O나 X를 하나씩 적으려고 한다. 이 때, O는 K개, X는 N-K개 적으려고 한다.</p><p>앞 면과 뒷 면에 같은 모양이 적혀있는 카드의 최대 개수를 구하는 프로그램을 작성하시오.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n, m, k &#x3D; map(int, input().split())</span><br><span class="line">print(min(m, k) + min(n-m, n-k))</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제를 정리하자면, </p><ul><li>카드 총 갯수 : n</li><li>앞면 O의 갯수 : m</li><li>앞면 X의 갯수 : n-m</li><li>뒷면 O의 갯수 : k</li><li>뒷면 X의 갯수 : n-k</li></ul><p>이렇게 정리가 된다.</p><p>즉, m과 k을 비교하여 가장 작은 수를 같은 모양이 적혀있는 O 카드의 최대 개수로 보면 된다.</p><p>X 카드의 경우 n-m과 n-k를 비교하면 된다.</p><p>그 후 더해주면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/">백준 브론즈4</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16204%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈 2798번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2798%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2798%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Sat, 27 Feb 2021 22:27:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;블랙잭&quot;&gt;&lt;a href=&quot;#블랙잭&quot; class=&quot;headerlink&quot; title=&quot;블랙잭&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2798&quot;&gt;블랙잭&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;카지노에서 제일 인기 있는 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="블랙잭"><a href="#블랙잭" class="headerlink" title="블랙잭"></a><a href="https://www.acmicpc.net/problem/2798">블랙잭</a></h1><p>카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.</p><p>한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.</p><p>김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.</p><p>이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.</p><p>N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">data &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">result &#x3D; 0</span><br><span class="line">length &#x3D; len(data)</span><br><span class="line"></span><br><span class="line">for i in range(length):</span><br><span class="line">    for j in range(i+1, length):</span><br><span class="line">        for k in range(j+1, length):</span><br><span class="line">            sum_value &#x3D; data[i] + data[j] + data[k]</span><br><span class="line">            if sum_value &lt;&#x3D; m:</span><br><span class="line">                result &#x3D; max(result, sum_value)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>두번째로 입력 받은 입력값에서 m보다 작지만 가장 가까운 3개의 합을 구해야한다.</p><p>구하려면 모든 경우의 수를 구해야한다.</p><ul><li>data[0] + data[1] + data[2]</li><li>data[0] + data[1] + data[3]</li><li>data[0] + data[1] + data[4]</li></ul><p>위와 같은 순으로 반복문을 돌려서 모든 경우의 수를 구하고, 합한 값이 m보다 작거나 같으면 result와 크기 비교 후 result에 저장을 하였다.</p><p>이러면, 조건에 만족하는 값들 중에 가장 큰 수를 저장 할 수 있어고 그 값이 저장이 된다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882/">백준 브론즈2</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2798%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XSS - Stored (Blog)</title>
      <link>https://lrtk-coder.github.io/2021/02/27/XSS-Stored-Blog/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/XSS-Stored-Blog/</guid>
      <pubDate>Sat, 27 Feb 2021 03:57:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제풀이&quot;&gt;&lt;a href=&quot;#문제풀이&quot; class=&quot;headerlink&quot; title=&quot;문제풀이&quot;&gt;&lt;/a&gt;문제풀이&lt;/h1&gt;&lt;h2 id=&quot;Low&quot;&gt;&lt;a href=&quot;#Low&quot; class=&quot;headerlink&quot; title=&quot;Low&quot;&gt;&lt;/a&gt;Lo</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p><img src="/images/pasted-238.png"></p><p>form에 글에 입력하고 Submit 버튼을 클릭하면, 해당 글이 DB에 저장이 된다.</p><p>그리고 페이지는 DB에서 저장된 글을 가져와서 페이지로 반영을 한다.</p><p>이를 이용하여 XSS 코드를 DB에 저장하여 페이지에 반영하겠다.</p><p><img src="/images/pasted-239.png" alt="`&amp;ltimg src=# onerror=alert(1)&amp;gt`"></p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p><img src="/images/pasted-240.png"></p><p>addslashes 함수로 DB에서 불려온 값의 <code>&#39;</code>, <code>&quot;</code>, <code>\</code>가 이스케이프 되는 것을 볼 수 있다.</p><p>addslashes 함수를 우회하는 방법은 Low에서 사용한 XSS 코드처럼 <code>&#39;</code>, <code>&quot;</code>, <code>\</code>을 사용하지 않고 XSS을 시도하면 된다.</p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><p><img src="/images/pasted-241.png"></p><p>htmlspecialchars 함수로 특수문자가 HTML 엔티티로 이스케이프되면서 그대로 출력되는 모습을 볼 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/XSS-Stored-Blog/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XSS - Reflected (User-Agent)</title>
      <link>https://lrtk-coder.github.io/2021/02/27/XSS-Reflected-User-Agent/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/XSS-Reflected-User-Agent/</guid>
      <pubDate>Sat, 27 Feb 2021 03:34:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;User-Agent&quot;&gt;&lt;a href=&quot;#User-Agent&quot; class=&quot;headerlink&quot; title=&quot;User-Agent&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HT</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent">User-Agent</a></h1><p>사용자 에이전트 요청 헤더는 서버와 네트워크 피어가 요청하는 응용 프로그램, 운영 체제, 공급 업체 및 / 또는 버전을 식별 할 수있는 특성 문자열 사용자 에이전트</p><h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p>XSS - Reflected (Referer) 문제와 똑같은 문제이다. 차이점이라면, Referer 헤더가 아닌 User-Agent 헤더를 이용하는 것이다.</p><p>바로 User-Agent을 프록시를 이용하여 XSS 코드를 삽입하여 페이지에 반영하겠다.</p><p><img src="/images/pasted-235.png" alt="`&amp;ltimg src=# onerror=alert(1)&amp;gt`"></p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p><img src="/images/pasted-236.png"><br><code>&#39;</code>, <code>&quot;</code>, <code>\</code>의 앞에 <code>\</code>이 추가되어 이스케이프가 된 것을 볼 수 있었다.</p><p>addslashed 함수로 입력값을 이스케이프를 한 것으로 보인다.</p><p>해당 우회방법은 Low 방법대로 <code>&#39;</code>, <code>&quot;</code>, <code>\</code>를 사용 안하는 방법이 있다.</p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><p><img src="/images/pasted-237.png"></p><p>htmlspecialchars 함수에 의해 특수 문자가 HTML 엔티티로 이스케이프되어 그대로 출력되는 것을 볼 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/XSS-Reflected-User-Agent/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈4 19944번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-19944%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-19944%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Sat, 27 Feb 2021 01:58:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;뉴비의-기준은-뭘까&quot;&gt;&lt;a href=&quot;#뉴비의-기준은-뭘까&quot; class=&quot;headerlink&quot; title=&quot;뉴비의 기준은 뭘까?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19944&quot;&gt;뉴비의 기준은</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="뉴비의-기준은-뭘까"><a href="#뉴비의-기준은-뭘까" class="headerlink" title="뉴비의 기준은 뭘까?"></a><a href="https://www.acmicpc.net/problem/19944">뉴비의 기준은 뭘까?</a></h1><p>2020 INPC는 IGRUS 뉴비들을 위해 열리는 대회입니다. 하지만 영수 할아버지나 인용 할아버지와 같이 14학번이지만 마음만은 뉴비인 어르신들 때문에 대회장이 TLE들의 파티가 되자 뉴비의 기준을 정의하기로 하였습니다.</p><p>INPC 운영진들은 고심 끝에 뉴비를 1학년 혹은 2학년인 학생으로 정의 내렸고 뉴비를 정의하는 김에 올드비와 TLE도 정의 내리기로 하였습니다. 올드비는 N학년 이하이면서 뉴비가 아닌 학생으로 정의하기로 하였고 TLE은 뉴비도 아니고 올드비도 아닌 학생으로 정의하였습니다.</p><p>N과 M이 주어졌을 때, M학년이 뉴비인지 올드비인지 TLE인지 구별해 주세요.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">print([[&#39;OLDBIE!&#39;, &#39;NEWBIE!&#39;][m &lt; 3], &#39;TLE!&#39;][n &lt; m])</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제 요약을 해보면,</p><ul><li>m이 1과 2일 때, NEWBIE! 출력</li><li>m이 n 이하면, OLDBIE! 출력</li><li>둘 다 아니면, TLE! 출력</li></ul><p>이것들을 파이썬으로 변환하면,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">if m &lt; 3:</span><br><span class="line">print(&#39;NEWBIE!&#39;)</span><br><span class="line">elif m &lt;&#x3D; n:</span><br><span class="line">print(&#39;OLDBIE!&#39;)</span><br><span class="line">else:</span><br><span class="line">print(&#39;TLE!&#39;)</span><br></pre></td></tr></table></figure><p>가 된다.</p><p>이를 BOOL을 이용한 인덱싱으로 표현하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/">백준 브론즈4</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-19944%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XSS - Reflected (Referer)</title>
      <link>https://lrtk-coder.github.io/2021/02/25/XSS-Reflected-Referer/</link>
      <guid>https://lrtk-coder.github.io/2021/02/25/XSS-Reflected-Referer/</guid>
      <pubDate>Thu, 25 Feb 2021 17:44:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제풀이&quot;&gt;&lt;a href=&quot;#문제풀이&quot; class=&quot;headerlink&quot; title=&quot;문제풀이&quot;&gt;&lt;/a&gt;문제풀이&lt;/h1&gt;&lt;p&gt;XSS - Reflected (Back Button)과 같은 문제라고 봐도 되는 문제이다.&lt;/p&gt;
&lt;p&gt;&lt;img</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><p>XSS - Reflected (Back Button)과 같은 문제라고 봐도 되는 문제이다.</p><p><img src="/images/pasted-231.png"></p><p>Referer 헤더를 참고하여 페이지에 반영하는 사이트이다. 프록시를 이용하여 Referer 헤더에 XSS 코드를 삽입하면, 페이지에선 그대로 반영을 해 줄 것이다.</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/xss_referer.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: XXX.XXX.XXX.XXX</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span>: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line"><span class="attribute">Referer</span>: &lt;img src=# onerror=alert(1)&gt;</span><br><span class="line"><span class="attribute">Cookie</span>: PHPSESSID=qnpb44sfr6u9ofp3pni8vobuf5; security_level=0</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-232.png"></p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p><img src="/images/pasted-233.png" alt="`Referer: &#39;&quot;\&lt;&gt;`"></p><p><code>&#39;</code>, <code>&quot;</code>, <code>\</code>의 앞에 <code>\</code>가 추가되어 이스케이프가 된 것을 보아 addslashes 함수에 의해 입력값이 이스케이프가 된다는 것을 알 수 있다.</p><p>이를 우회하기 위해 Low Level에서 사용한 XSS코드처럼 <code>&#39;</code>, <code>&quot;</code>를 사용하지 않고 XSS를 실행하면 된다.</p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><p><img src="/images/pasted-234.png"></p><p>입력값의 특수 문자가 HTML 엔티티로 이스케이프가 되어 XSS 코드가 그대로 출력되는 모습이다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/25/XSS-Reflected-Referer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈4 11549번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/25/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-23178117%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/25/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-23178117%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Thu, 25 Feb 2021 16:51:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Identifying-tea&quot;&gt;&lt;a href=&quot;#Identifying-tea&quot; class=&quot;headerlink&quot; title=&quot;Identifying tea&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Identifying-tea"><a href="#Identifying-tea" class="headerlink" title="Identifying tea"></a><a href="https://www.acmicpc.net/problem/11549">Identifying tea</a></h1><p>Blind tea tasting is the skill of identifying a tea by using only your senses of smell and taste.</p><p>As part of the Ideal Challenge of Pure-Tea Consumers (ICPC), a local TV show is organized. During the show, a full teapot is prepared and five contestants are handed a cup of tea each. The participants must smell, taste and assess the sample so as to identify the tea type, which can be: (1) white tea; (2) green tea; (3) black tea; or (4) herbal tea. At the end, the answers are checked to determine the number of correct guesses.</p><p>Given the actual tea type and the answers provided, determine the number of contestants who got the correct answer.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = [*<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())]</span><br><span class="line">print(b.count(a))</span><br></pre></td></tr></table></figure><p>Count 함수를 이용하여 특정값의 중복 수를 출력하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/">백준 브론즈4</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/25/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-23178117%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XSS - Reflected (PHP_SELF)</title>
      <link>https://lrtk-coder.github.io/2021/02/24/phpMyAdmin-BBCode-Tag-XSS/</link>
      <guid>https://lrtk-coder.github.io/2021/02/24/phpMyAdmin-BBCode-Tag-XSS/</guid>
      <pubDate>Wed, 24 Feb 2021 23:15:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;PHP-SELF&quot;&gt;&lt;a href=&quot;#PHP-SELF&quot; class=&quot;headerlink&quot; title=&quot;PHP_SELF&quot;&gt;&lt;/a&gt;PHP_SELF&lt;/h1&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="PHP-SELF"><a href="#PHP-SELF" class="headerlink" title="PHP_SELF"></a>PHP_SELF</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[<span class="string">&#x27;PHP_SELF&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>현재 실행중인 파일(자신)의 경로 + 파일명을 담은 전역변수</li><li>웹에선 URL상의 경로가 출력됨.</li><li>CLI에서는 접근한 경로가 그대로 출력.</li></ul><h1 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p><img src="/images/pasted-227.png"></p><p>first name과 last name에 값을 넣으면 그대로 출력하는 페이지이다.</p><p>이를 이용하여 XSS 코드를 반영하겠다.</p><p><img src="/images/pasted-228.png" alt="`&amp;ltimg src=# onerror=alert(1)&amp;gt`/`aa`"></p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p><img src="/images/pasted-229.png" alt="`&#39;&quot;&amp;\`/`aa`"></p><p><code>&#39;</code>, <code>&quot;</code>, <code>\</code>의 앞에 <code>\</code>가 추가된 값으로 이스케이프된 것을 볼 수 있다.</p><p>아마 addslashes() 함수로 입력값에 대한 이스케이프를 진행 한 것으로 추측이 된다.</p><p><img src="/images/pasted-228.png" alt="`&amp;ltimg src=# onerror=alert(1)&amp;gt`/`aa`"></p><p>이를 우회하기 위해선 Low Level의 방식처럼 <code>&#39;</code>, <code>&quot;</code>, <code>\</code>를 사용 안하는 방법으로 XSS 코드를 입력할 수 있다.</p><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><p><img src="/images/pasted-230.png"></p><p>htmlspecialchars 함수로 특수문자가 HTML 엔티티로 이스케이프로 되어 XSS 코드가 제대로 반영이 안된 것을 볼 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/24/phpMyAdmin-BBCode-Tag-XSS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈4 15726번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14935%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14935%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Wed, 24 Feb 2021 22:51:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;이칙연산&quot;&gt;&lt;a href=&quot;#이칙연산&quot; class=&quot;headerlink&quot; title=&quot;이칙연산&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15726&quot;&gt;이칙연산&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;다음과 같이 세 수</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="이칙연산"><a href="#이칙연산" class="headerlink" title="이칙연산"></a><a href="https://www.acmicpc.net/problem/15726">이칙연산</a></h1><p>다음과 같이 세 수가 연속해서 주어졌을 때 한 번의 곱셈 기호와 한 번의 나눗셈 기호를 이용하여 만든 식 중 가장 큰 값을 출력하는 프로그램을 작성하시오. (세 수의 순서는 변하지 않는다.)</p><p>32 ☐ 16 ☐ 8</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">print(<span class="built_in">int</span>(<span class="built_in">max</span>(a*b/c, a/b*c)))</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제의 요점은 3개의 숫자를 곱셈과 나누기를 이용해서 계산했을 때 어떻게 계산해야 가장 큰 수가 나오는지를 구하는 문제이다.</p><ol><li>숫자1 * 숫자2 / 숫자3</li><li>숫자1 / 숫자2 * 숫자3</li><li>1과 2의 결과값 크키 비교 후 큰 수 출력.</li></ol><p>여기서, 많이 헤매는 부분은 <code>//</code>, <code>/</code> 둘 중 어느 것을 써야하는지이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># 10 3 3 입력</span></span><br><span class="line">print(a*b/c, a/b*c)<span class="comment"># 10.0 10.0 출력</span></span><br><span class="line">print(a*b//c, a//b*c)<span class="comment"># 10 9 출력</span></span><br></pre></td></tr></table></figure><p><code>//</code>은 소수점을 버리기 때문에 값이 차이가 나는 것을 알 수 있다.</p><p>하지만 이 문제에서 왜 <code>/</code>을 쓰는지는 모르겠다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80/">백준</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/">백준 브론즈4</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14935%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>알고리즘 정리 - 동적 계획법, 분할 정복</title>
      <link>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/</link>
      <guid>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/</guid>
      <pubDate>Wed, 24 Feb 2021 08:38:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;정의&quot;&gt;&lt;a href=&quot;#정의&quot; class=&quot;headerlink&quot; title=&quot;정의&quot;&gt;&lt;/a&gt;정의&lt;/h1&gt;&lt;h2 id=&quot;동적-계획법-Dynamic-Programming&quot;&gt;&lt;a href=&quot;#동적-계획법-Dynamic-Programming&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h1><h2 id="동적-계획법-Dynamic-Programming"><a href="#동적-계획법-Dynamic-Programming" class="headerlink" title="동적 계획법(Dynamic Programming)"></a>동적 계획법(Dynamic Programming)</h2><p>입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘</p><p>상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식</p><p>Memoization 기법을 사용함.<br><br>Memoization이란? 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술</p><p>문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용됨.</p><h2 id="분할-정복"><a href="#분할-정복" class="headerlink" title="분할 정복"></a>분할 정복</h2><p>문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘</p><p>하양식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식</p><p>문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음.</p><h2 id="공통점"><a href="#공통점" class="headerlink" title="공통점"></a>공통점</h2><p>문제를 잘게 쪼개서, 가장 작은 단위로 분할</p><h2 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h2><ul><li><p>동적 계획법<br><br>부분 문제는 중복되어, 상위 문제 해결 시 재활용됨.<br><br>Memoization 기법 사용(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)</p></li><li><p>분할 정복<br><br>부분 문제는 서로 중보되지 않음.<br><br>Memoization 기법 사용 안함.</p></li></ul><h2 id="이해"><a href="#이해" class="headerlink" title="이해"></a>이해</h2><h3 id="동적-계획법-알고리즘-이해"><a href="#동적-계획법-알고리즘-이해" class="headerlink" title="동적 계획법 알고리즘 이해"></a>동적 계획법 알고리즘 이해</h3><ol><li>피보나치 수열<br><img src="/images/pasted-225.png"></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(0) &#x3D; 0</span><br><span class="line">fibonacci(1) &#x3D; 1</span><br><span class="line">fibonacci(2) &#x3D; 1</span><br><span class="line">fibonacci(3) &#x3D; 2</span><br><span class="line">fibonacci(4) &#x3D; 3</span><br><span class="line">fibonacci(5) &#x3D; 5</span><br><span class="line">fibonacci(6) &#x3D; 8</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Recursive call 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> fibo(num - <span class="number">1</span>) + fibo(num - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(fibo(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>fibo(4)를 구하기 위해선 fibo(3)과 fibo(2)가 필요하다.</p><p>fibo(3)은 fibo(2) + fibo(1)<br><br>fibo(2)은 fibo(1) + fibo(0)</p><p>fibo(4)를 구하기 위해선 fibo(0) 1개, fibo(1) 2개, fibo(2) 1개가 필요한데 이를 계속 계산하여 구하는 것은 비효율적이다.</p><p>이 부분을 해결하는 방법이 동적 계획법이다.</p><figure class="highlight python"><figcaption><span>DP 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp</span>(<span class="params">num</span>):</span></span><br><span class="line">    cache = [<span class="number">0</span> <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(num+<span class="number">1</span>)]</span><br><span class="line">    cache[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    cache[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num+<span class="number">1</span>):</span><br><span class="line">        cache[index] = cache[index<span class="number">-1</span>] + cache[index<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> cache[num]</span><br><span class="line"></span><br><span class="line">print(fibo_dp(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>리스트에 피보나치 수열을 계산 값을 저장을 하여 저장된 값을 사용하여 계산하여 효율을 높였다.</p><h3 id="분할-정복-알고리즘-이해"><a href="#분할-정복-알고리즘-이해" class="headerlink" title="분할 정복 알고리즘 이해"></a>분할 정복 알고리즘 이해</h3><p>퀵 정렬 알고리즘 참고</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/">Basic</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/">동적 계획법</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/">분할 정복</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>알고리즘 정리 - 퀵 정렬</title>
      <link>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%ED%80%B5-%EC%A0%95%EB%A0%AC/</link>
      <guid>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%ED%80%B5-%EC%A0%95%EB%A0%AC/</guid>
      <pubDate>Wed, 24 Feb 2021 00:13:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;퀵-정렬-Quick-Sort&quot;&gt;&lt;a href=&quot;#퀵-정렬-Quick-Sort&quot; class=&quot;headerlink&quot; title=&quot;퀵 정렬(Quick Sort)&quot;&gt;&lt;/a&gt;퀵 정렬(Quick Sort)&lt;/h1&gt;&lt;img src=&quot;https://m</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h1><img src="https://media.vlpt.us/images/rachell_lee/post/9d07118d-e83a-46c6-a1f9-7d667dbc09b5/quick_sort.gif"><p>기준점(pivot)을 정해서, 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right)으로 모으는 함수를 작성함.<br><br>각 왼쪽(left), 오른쪽(right)은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복함.<br><br>함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right)을 리턴함.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    left, right = <span class="built_in">list</span>(), <span class="built_in">list</span>()</span><br><span class="line">    pivot = data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> pivot &gt; data[index]:</span><br><span class="line">            left.append(data[index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qsort(left) + [pivot] + qsort(right)</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line">print(qsort(data_list))</span><br></pre></td></tr></table></figure><h2 id="알고리즘-분석"><a href="#알고리즘-분석" class="headerlink" title="알고리즘 분석"></a>알고리즘 분석</h2><p>병합 정렬과 유사, 시간 복잡도는 O(n log n)</p><p>단, 최악의 경우 pivot이 가장 크거나 작으면 모든 데이터를와 비교하게 된다. O(n<sup>2</sup>)</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/">Basic</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/">분할 정복</category>
      
      <category domain="https://lrtk-coder.github.io/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/">퀵 정렬</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%ED%80%B5-%EC%A0%95%EB%A0%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>알고리즘 정리 - 재귀용법</title>
      <link>https://lrtk-coder.github.io/2021/02/23/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95/</link>
      <guid>https://lrtk-coder.github.io/2021/02/23/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95/</guid>
      <pubDate>Tue, 23 Feb 2021 19:10:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;재귀-용법-Recursive-Call-재귀-호출&quot;&gt;&lt;a href=&quot;#재귀-용법-Recursive-Call-재귀-호출&quot; class=&quot;headerlink&quot; title=&quot;재귀 용법(Recursive Call, 재귀 호출)&quot;&gt;&lt;/a&gt;재귀 용법(</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="재귀-용법-Recursive-Call-재귀-호출"><a href="#재귀-용법-Recursive-Call-재귀-호출" class="headerlink" title="재귀 용법(Recursive Call, 재귀 호출)"></a>재귀 용법(Recursive Call, 재귀 호출)</h1><p>함수 안에서 동일한 함수를 호출하는 형태</p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>팩토리얼을 구하는 알고리즘</p><ul><li>2! = 1*2</li><li>3! = 1*2*3</li><li>4! = 1*2*3*4</li><li>n! = n * (n-1)!</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>시간 복잡도/공간 복잡도는 O(n-1)이므로, O(n)이라는 시간 복잡도/공간 복잡도를 가진다.</p><h2 id="일반적인-형태"><a href="#일반적인-형태" class="headerlink" title="일반적인 형태"></a>일반적인 형태</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursive</span>(<span class="params">입력</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 입력 &gt; 일정값:</span><br><span class="line">        <span class="keyword">return</span> recursive(입력 또는 특정값)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> 결과값</span><br></pre></td></tr></table></figure><blockquote><p>파이썬의 경우 재귀함수의 길이는 1000번이 최대이다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://lrtk-coder.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/">Basic</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/">재귀함수</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/23/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>백준 브론즈4 14470번 문제</title>
      <link>https://lrtk-coder.github.io/2021/02/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14470%EB%B2%88-%EB%AC%B8%EC%A0%9C/</link>
      <guid>https://lrtk-coder.github.io/2021/02/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14470%EB%B2%88-%EB%AC%B8%EC%A0%9C/</guid>
      <pubDate>Tue, 23 Feb 2021 16:43:15 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;전자레인지&quot;&gt;&lt;a href=&quot;#전자레인지&quot; class=&quot;headerlink&quot; title=&quot;전자레인지&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14470&quot;&gt;전자레인지&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;JOI 군은</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="전자레인지"><a href="#전자레인지" class="headerlink" title="전자레인지"></a><a href="https://www.acmicpc.net/problem/14470">전자레인지</a></h1><p>JOI 군은 식사 준비를 위해 A℃의 고기를 전자레인지로 B℃까지 데우려고 한다. 고기는 온도가 0℃보다 낮을 때 얼어 있고, 0℃보다 높을 때는 얼어 있지 않다. 온도가 정확히 0℃일 때 고기는 얼어 있을 수도, 얼어 있지 않을 수도 있다.</p><p>JOI 군은 가열할 때 고기가 아래의 규칙을 따라 데워진다고 가정하고, 고기를 데우는 데 걸리는 시간을 어림하기로 했다.</p><ul><li>고기가 얼어 있고 온도가 0℃ 미만일 때 : 온도가 C초에 1℃씩 오른다.</li><li>고기가 얼어 있고 온도가 정확히 0℃일 때 : 얼어 있지 않은 상태로 만드는(해동하는) 데 D초가 걸린다.</li><li>고기가 얼어 있지 않을 때 : 온도가 E초에 1℃씩 오른다.</li></ul><p>이 규칙을 토대로, 고기가 B℃까지 데워지는 데 몇 초가 걸리는지 구하라.</p><h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d, e = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">open</span>(<span class="number">0</span>))</span><br><span class="line">print([-(a)*c + b*e + d, b*e - a*e][a&gt;<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>a : 고기온도<br><br>b : 목표온도<br><br>c : 얼어있는 고기를 1도씩 올리는 시간<br><br>d : 얼어있는 고기를 해동하는 시간<br><br>e : 얼지 않은 고기를 1도씩 올리는 시간</p><p>다음과 같은 시간을 구하고 값을 더해주면 목표 온도까지의 시간을 구할 수 있다.</p><p>0&gt;고기온도:</p><ul><li>언 고기을 0도까지 해동하는 시간 (a*c)</li><li>0도의 고기를 해동하는 시간 (d)</li><li>0도에서 목표온도까지 도달하는 시간 (b*e)</li></ul><p>0&lt;고기온도:</p><ul><li>고기온도에서 목표온도까지 도달하는 시간 (b*e - a*e)</li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://lrtk-coder.github.io/2021/02/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14470%EB%B2%88-%EB%AC%B8%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XSS - Reflected (Login Form)</title>
      <link>https://lrtk-coder.github.io/2021/02/23/XSS-Reflected-Login-Form/</link>
      <guid>https://lrtk-coder.github.io/2021/02/23/XSS-Reflected-Login-Form/</guid>
      <pubDate>Tue, 23 Feb 2021 09:05:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제풀이&quot;&gt;&lt;a href=&quot;#문제풀이&quot; class=&quot;headerlink&quot; title=&quot;문제풀이&quot;&gt;&lt;/a&gt;문제풀이&lt;/h1&gt;&lt;h2 id=&quot;Low&quot;&gt;&lt;a href=&quot;#Low&quot; class=&quot;headerlink&quot; title=&quot;Low&quot;&gt;&lt;/a&gt;Lo</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p><img src="/images/pasted-219.png"></p><p>로그인을 해야하지만, bee 계정과 LRTK 계정으로 로그인이 안된다.</p><p>현 로그인의 계정 정보도 없어서, SQL Injection이 되는 지 확인을 해보았다.</p><p><img src="/images/pasted-221.png" alt="Login: `&#39;`"></p><p>SQL의 에러메시지가 그대로 출력되는 것을 확인할 수 있었다. 이것을 이용하여 입력한 XSS 코드가 페이지에 반영할 수 있을 것 같다.</p><p><img src="/images/pasted-222.png" alt="Login: `&amp;lta$gthi&amp;lt/a&amp;gt&#39;`"></p><p>먼저 a태그를 넣어서 반영이 되는지 확인을 했는데 반영이 되는 것을 볼 수 있었다.</p><p><img src="/images/pasted-223.png" alt="Login: `&amp;ltscript&amp;gtalert(1)&amp;lt/script&amp;gt&#39;`"></p><p>SQL 에러 메시지 출력을 막으면 될 거 같은데 Medium과 High에서 방어 방법을 알아 보겠다.</p><h2 id="Medium-amp-High"><a href="#Medium-amp-High" class="headerlink" title="Medium &amp; High"></a>Medium &amp; High</h2><p><img src="/images/pasted-224.png"></p><p>SQL 에러가 더이상 출력이 안된다. 더이상 XSS은 시도할 수 없을 것 같다.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>($_COOKIE[<span class="string">&quot;security_level&quot;</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;0&quot;</span> :</span><br><span class="line">    $data = no_check($data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;1&quot;</span> :</span><br><span class="line">        $data = sqli_check_1($data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;2&quot;</span> :</span><br><span class="line">        $data = sqli_check_2($data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        $data = no_check($data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><figcaption><span>sqli_check_1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqli_check_1</span>(<span class="params">$data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addslashes($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addslashes 함수로 특정 특수 문자 앞에 <code>\</code>을 넣어서 이스케이프하였다.</p><figure class="highlight php"><figcaption><span>sqli_check_2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqli_check_2</span>(<span class="params">$data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mysql_real_escape_string($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mysql_real_escape_string 함수를 이용하여 SQL에 사용되는 특수 문자 앞에 <code>\</code>을 넣어서 이스케이프 처리하였다.</p>]]></content:encoded>
      
      
      <category domain="https://lrtk-coder.github.io/categories/Security/">Security</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/">Web</category>
      
      <category domain="https://lrtk-coder.github.io/categories/Security/Web/BeeBox/">BeeBox</category>
      
      
      <category domain="https://lrtk-coder.github.io/tags/BeeBox/">BeeBox</category>
      
      
      <comments>https://lrtk-coder.github.io/2021/02/23/XSS-Reflected-Login-Form/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
