<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>카테고리: 알고리즘 - LRTK Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LRTK Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LRTK Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Coding, Security, IT News 등 정리한 블로그"><meta property="og:type" content="blog"><meta property="og:title" content="LRTK Blog"><meta property="og:url" content="https://lrtk-coder.github.io/"><meta property="og:site_name" content="LRTK Blog"><meta property="og:description" content="Coding, Security, IT News 등 정리한 블로그"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://lrtk-coder.github.io/img/og_image.png"><meta property="article:author" content="LRTK"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://lrtk-coder.github.io"},"headline":"LRTK Blog","image":["https://lrtk-coder.github.io/img/og_image.png"],"author":{"@type":"Person","name":"LRTK"},"description":"Coding, Security, IT News 등 정리한 블로그"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-176131510-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-176131510-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/rss2.xml" title="LRTK Blog" type="application/rss+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Logo4.svg" alt="LRTK Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/lrtk-coder"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">알고리즘</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-03-01T02:09:00.000Z" title="2021-03-01T02:09:00.000Z">2021-03-01</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-01T23:18:02.000Z" title="2021-03-01T23:18:02.000Z">2021-03-02</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</a></span><span class="level-item">4분안에 읽기 (약 653 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/01/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1966%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 실버 1966번 문제</a></h1><div class="content"><h1 id="프린터-큐"><a href="#프린터-큐" class="headerlink" title="프린터 큐"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/1966">프린터 큐</a></h1><p>여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.</p>
<p>현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.<br>나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.<br>예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.</p>
<p>여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test_case &#x3D; int(input())</span><br><span class="line">for _ in range(test_case):</span><br><span class="line">    n, m &#x3D; map(int, input().split())</span><br><span class="line">    queue &#x3D; [(data, idx) for idx, data in enumerate([*map(int, input().split())])]</span><br><span class="line"></span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    while True:</span><br><span class="line">        if queue[0][0] &#x3D;&#x3D; max(queue, key&#x3D;lambda x: x[0])[0]:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            if queue[0][1] &#x3D;&#x3D; m:</span><br><span class="line">                print(count)</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                queue.pop(0)</span><br><span class="line">        else:</span><br><span class="line">            queue.append(queue.pop(0))</span><br></pre></td></tr></table></figure>
<h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><ul>
<li>몇번을 입력 받을 건가? : test_case</li>
<li>Queue 안의 문서 갯수 : n</li>
<li>Queue에서 몇번째로 POP되는지 알고자하는 번수 : m</li>
<li>Queue</li>
</ul>
<p>위 4개를 입력받고, 해당 Queue에는 중요도가 저장이 된다.</p>
<p><img src="/images/pasted-248.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_case &#x3D; int(input())</span><br><span class="line">for _ in range(test_case):</span><br><span class="line">    n, m &#x3D; map(int, input().split())</span><br><span class="line">    queue &#x3D; [*map(int, input().split())]</span><br><span class="line">    queue &#x3D; [(data, idx) for idx, data in enumerate(queue)]</span><br></pre></td></tr></table></figure>
<p>문제풀이에선 queue를 한 줄로 표현했으나, 위와 같이 정의할 수도 있다.<br>queue의 값에 index(문서)도 같이 포함을 하여, 몇번째 문서인지를 검사할 수 있도록 하였다.</p>
<p><img src="/images/pasted-249.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">while True:</span><br><span class="line">	if queue[0][0] &#x3D;&#x3D; max(queue, key&#x3D;lambda x: x[0])[0]:</span><br><span class="line">		count +&#x3D; 1</span><br><span class="line">    else:</span><br><span class="line">    	queue.append(queue.pop(0))</span><br></pre></td></tr></table></figure>
<p>무한 루프를 이용하여, 중요도가 가장 큰 값이 pop을 할 수 있도록 순회를 하였다.</p>
<p>이렇게 Queue의 특성을 이용하여 풀이를 진행하였다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-28T06:27:00.000Z" title="2021-02-28T06:27:00.000Z">2021-02-28</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-01T23:19:01.000Z" title="2021-03-01T23:19:01.000Z">2021-03-02</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></span><span class="level-item">4분안에 읽기 (약 540 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/28/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2920%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 2920번 문제</a></h1><div class="content"><h1 id="음계"><a href="#음계" class="headerlink" title="음계"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/2920">음계</a></h1><p>다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, …, C를 8로 바꾼다.</p>
<p>1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다.</p>
<p>연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오.</p>
<h2 id="문제풀이1"><a href="#문제풀이1" class="headerlink" title="문제풀이1"></a>문제풀이1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">count_check &#x3D; True</span><br><span class="line">if n[0] &#x3D;&#x3D; 1:</span><br><span class="line">    for i in range(len(n)-1):</span><br><span class="line">        if n[i] &lt; n[i+1]:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            count_check &#x3D; False</span><br><span class="line">        if count_check &#x3D;&#x3D; False:</span><br><span class="line">            print(&#39;mixed&#39;)</span><br><span class="line">            break</span><br><span class="line">    if count_check &#x3D;&#x3D; True:</span><br><span class="line">        print(&#39;ascending&#39;)</span><br><span class="line"></span><br><span class="line">elif n[0] &#x3D;&#x3D; 8:</span><br><span class="line">    for i in range(len(n)-1):</span><br><span class="line">        if n[i] &gt; n[i+1]:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            count_check &#x3D; False</span><br><span class="line">        if count_check &#x3D;&#x3D; False:</span><br><span class="line">            print(&#39;mixed&#39;)</span><br><span class="line">            break</span><br><span class="line">    if count_check &#x3D;&#x3D; True:</span><br><span class="line">        print(&#39;descending&#39;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    print(&#39;mixed&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="풀이1-설명"><a href="#풀이1-설명" class="headerlink" title="풀이1 설명"></a>풀이1 설명</h3><p>문제에서 나타는 경우의 수는,</p>
<ul>
<li>1 2 3 4 5 6 7 8 : ‘ascending’</li>
<li>8 7 6 5 4 3 2 1 : ‘descending’</li>
<li>둘 다 아니면 mixed</li>
</ul>
<p>위 3개로 볼 수 있다.</p>
<p>그래서 나는 입력받은 값들을 리스트로 저장하여, 맨 첫번째 자리를 검사였다.</p>
<ul>
<li>만약 1이면, ascending인 오름차순</li>
<li>만약 8이면, descending인 내림차순</li>
<li>둘 다 아니면 mixed</li>
</ul>
<p>그 후, 진짜 오름차순과 내림차순으로 되어 있는지 검사를 하였다.</p>
<h2 id="문제풀이2"><a href="#문제풀이2" class="headerlink" title="문제풀이2"></a>문제풀이2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">ascending &#x3D; True</span><br><span class="line">descending &#x3D; True</span><br><span class="line"></span><br><span class="line">for i in range(len(n)-1):</span><br><span class="line">    if n[i] &lt; n[i+1]:</span><br><span class="line">        descending &#x3D; False</span><br><span class="line">    elif n[i] &gt; n[i+1]:</span><br><span class="line">        ascending &#x3D; False</span><br><span class="line">    else:</span><br><span class="line">        ascending &#x3D; False</span><br><span class="line">        descending &#x3D; False</span><br><span class="line"></span><br><span class="line">if ascending:</span><br><span class="line">    print(&#39;ascending&#39;)</span><br><span class="line">elif descending:</span><br><span class="line">    print(&#39;descending&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;mixed&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="풀이2-설명"><a href="#풀이2-설명" class="headerlink" title="풀이2 설명"></a>풀이2 설명</h3><p>여기선 내가 깊이 생각을 못 했던 것이 있었다.</p>
<p>굳이 첫번째 자리를 비교를 했어야 했는지와 왜 검사 값을 1개만 썼는지이다.</p>
<p>이 문제풀이에선 오름차순과 내림차순을 검사하는 변수인 ascending과 descending이 있다.</p>
<p>반복문으로 리스트화 된 입력값을 두 개씩 비교 후 오름차순인지 내림차순인지를 검사를 한다.</p>
<p>둘 다 False이면, mixed가 나온다.</p>
<p>문제풀이1에서 더욱 간단하게 짜여졌고, 가독성도 더 좋아 보인다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-27T23:26:00.000Z" title="2021-02-27T23:26:00.000Z">2021-02-28</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-01T23:18:14.000Z" title="2021-03-01T23:18:14.000Z">2021-03-02</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/">실버</a></span><span class="level-item">4분안에 읽기 (약 567 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/27/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843-1874%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 실버 1874번 문제</a></h1><div class="content"><h1 id="스택-수열"><a href="#스택-수열" class="headerlink" title="스택 수열"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/1874">스택 수열</a></h1><p>스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.</p>
<p>1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.</p>
<h2 id="문제풀이1"><a href="#문제풀이1" class="headerlink" title="문제풀이1"></a>문제풀이1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; int(input())</span><br><span class="line"></span><br><span class="line">count &#x3D; 1</span><br><span class="line">stack &#x3D; []</span><br><span class="line">result &#x3D; []</span><br><span class="line"></span><br><span class="line">for i in range(1, n+1):</span><br><span class="line">    data &#x3D; int(input())</span><br><span class="line">    while count &lt;&#x3D; data:</span><br><span class="line">        stack.append(count)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        result.append(&#39;+&#39;)</span><br><span class="line">    if stack[-1] &#x3D;&#x3D; data:</span><br><span class="line">        stack.pop()</span><br><span class="line">        result.append(&#39;-&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;NO&#39;)</span><br><span class="line">        exit(0)</span><br><span class="line"></span><br><span class="line">print(&#39;\n&#39;.join(result))</span><br></pre></td></tr></table></figure>
<h3 id="풀이1-설명"><a href="#풀이1-설명" class="headerlink" title="풀이1 설명"></a>풀이1 설명</h3><ul>
<li>n : 스택에 저장할 총 갯수</li>
<li>count : 스택에 Push할 값</li>
<li>data : 스택에 Pop할 값</li>
</ul>
<p>1~n까지 반복을 하는데, 그 속엔 data을 입력 받는다. 하지만 아직 스택엔 아무 값이 없어서 count가 data만큼 같아질 때까지 반복을 하는데 1씩 증가 할 때마다 스택에 넣는다.</p>
<p>그 후 스택의 맨 위가 data와 같은 값이면, pop을 하고 result에 <code>-</code>를 입력한다.</p>
<p>같은 값이 아니면 pop과 push만으로 구현이 안되니 NO를 출력하였다.</p>
<h2 id="문제-풀이2"><a href="#문제-풀이2" class="headerlink" title="문제 풀이2"></a>문제 풀이2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">n &#x3D; int(input())</span><br><span class="line">data &#x3D; map(lambda x: int(x.rstrip()), sys.stdin.readlines())</span><br><span class="line"></span><br><span class="line">count &#x3D; 1</span><br><span class="line">stack &#x3D; []</span><br><span class="line">result &#x3D; []</span><br><span class="line"></span><br><span class="line">for i in data:</span><br><span class="line">    while count &lt;&#x3D; i:</span><br><span class="line">        stack.append(count)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        result.append(&#39;+&#39;)</span><br><span class="line">    if stack[-1] &#x3D;&#x3D; i:</span><br><span class="line">        stack.pop()</span><br><span class="line">        result.append(&#39;-&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;NO&#39;)</span><br><span class="line">        exit(0)</span><br><span class="line">        </span><br><span class="line">print(&#39;\n&#39;.join(result))</span><br></pre></td></tr></table></figure>
<h3 id="풀이2-설명"><a href="#풀이2-설명" class="headerlink" title="풀이2 설명"></a>풀이2 설명</h3><p>풀이1은 반복문에서 input()로 입력값을 받고 있어서 시간이 많이 소모가 된다.</p>
<p>그래서 readlines()를 이용하여 값을 입력 받아서 저장된 값들을 반복문에서 하나하나 꺼내서 쓰는 방식으로 변경하였다.</p>
<p><img src="/images/pasted-246.png"></p>
<p>그 결과 시간이 대폭 줄었다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-27T23:21:00.000Z" title="2021-02-27T23:21:00.000Z">2021-02-28</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-28T08:36:43.000Z" title="2021-02-28T08:36:43.000Z">2021-02-28</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</a></span><span class="level-item">2분안에 읽기 (약 311 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-16204%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈4 16204번 문제</a></h1><div class="content"><h1 id="카드-뽑기"><a href="#카드-뽑기" class="headerlink" title="카드 뽑기"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/16204">카드 뽑기</a></h1><p>앞 면에 O와 X가 적혀있는 카드 N개가 있다. N개의 카드 중 M개의 카드의 앞면에는 O가 한 개 적혀있고, 나머지 N-M개의 카드의 앞면에는 X가 한 개 적혀있다. 카드의 뒷 면은 두 종류의 카드 모두 같은 모양이라 구분할 수 없다.</p>
<p>카드의 뒷 면에 O나 X를 하나씩 적으려고 한다. 이 때, O는 K개, X는 N-K개 적으려고 한다.</p>
<p>앞 면과 뒷 면에 같은 모양이 적혀있는 카드의 최대 개수를 구하는 프로그램을 작성하시오.</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n, m, k &#x3D; map(int, input().split())</span><br><span class="line">print(min(m, k) + min(n-m, n-k))</span><br></pre></td></tr></table></figure>
<h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제를 정리하자면, </p>
<ul>
<li>카드 총 갯수 : n</li>
<li>앞면 O의 갯수 : m</li>
<li>앞면 X의 갯수 : n-m</li>
<li>뒷면 O의 갯수 : k</li>
<li>뒷면 X의 갯수 : n-k</li>
</ul>
<p>이렇게 정리가 된다.</p>
<p>즉, m과 k을 비교하여 가장 작은 수를 같은 모양이 적혀있는 O 카드의 최대 개수로 보면 된다.</p>
<p>X 카드의 경우 n-m과 n-k를 비교하면 된다.</p>
<p>그 후 더해주면 된다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-27T22:27:00.000Z" title="2021-02-27T22:27:00.000Z">2021-02-28</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-01T23:19:12.000Z" title="2021-03-01T23:19:12.000Z">2021-03-02</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></span><span class="level-item">3분안에 읽기 (약 518 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882-2798%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 2798번 문제</a></h1><div class="content"><h1 id="블랙잭"><a href="#블랙잭" class="headerlink" title="블랙잭"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/2798">블랙잭</a></h1><p>카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.</p>
<p>한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.</p>
<p>김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.</p>
<p>이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.</p>
<p>N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">data &#x3D; [*map(int, input().split())]</span><br><span class="line"></span><br><span class="line">result &#x3D; 0</span><br><span class="line">length &#x3D; len(data)</span><br><span class="line"></span><br><span class="line">for i in range(length):</span><br><span class="line">    for j in range(i+1, length):</span><br><span class="line">        for k in range(j+1, length):</span><br><span class="line">            sum_value &#x3D; data[i] + data[j] + data[k]</span><br><span class="line">            if sum_value &lt;&#x3D; m:</span><br><span class="line">                result &#x3D; max(result, sum_value)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>두번째로 입력 받은 입력값에서 m보다 작지만 가장 가까운 3개의 합을 구해야한다.</p>
<p>구하려면 모든 경우의 수를 구해야한다.</p>
<ul>
<li>data[0] + data[1] + data[2]</li>
<li>data[0] + data[1] + data[3]</li>
<li>data[0] + data[1] + data[4]</li>
</ul>
<p>위와 같은 순으로 반복문을 돌려서 모든 경우의 수를 구하고, 합한 값이 m보다 작거나 같으면 result와 크기 비교 후 result에 저장을 하였다.</p>
<p>이러면, 조건에 만족하는 값들 중에 가장 큰 수를 저장 할 수 있어고 그 값이 저장이 된다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-27T01:58:00.000Z" title="2021-02-27T01:58:00.000Z">2021-02-27</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-27T12:25:20.000Z" title="2021-02-27T12:25:20.000Z">2021-02-27</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</a></span><span class="level-item">2분안에 읽기 (약 343 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/27/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-19944%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈4 19944번 문제</a></h1><div class="content"><h1 id="뉴비의-기준은-뭘까"><a href="#뉴비의-기준은-뭘까" class="headerlink" title="뉴비의 기준은 뭘까?"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/19944">뉴비의 기준은 뭘까?</a></h1><p>2020 INPC는 IGRUS 뉴비들을 위해 열리는 대회입니다. 하지만 영수 할아버지나 인용 할아버지와 같이 14학번이지만 마음만은 뉴비인 어르신들 때문에 대회장이 TLE들의 파티가 되자 뉴비의 기준을 정의하기로 하였습니다.</p>
<p>INPC 운영진들은 고심 끝에 뉴비를 1학년 혹은 2학년인 학생으로 정의 내렸고 뉴비를 정의하는 김에 올드비와 TLE도 정의 내리기로 하였습니다. 올드비는 N학년 이하이면서 뉴비가 아닌 학생으로 정의하기로 하였고 TLE은 뉴비도 아니고 올드비도 아닌 학생으로 정의하였습니다.</p>
<p>N과 M이 주어졌을 때, M학년이 뉴비인지 올드비인지 TLE인지 구별해 주세요.</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">print([[&#39;OLDBIE!&#39;, &#39;NEWBIE!&#39;][m &lt; 3], &#39;TLE!&#39;][n &lt; m])</span><br></pre></td></tr></table></figure>
<h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제 요약을 해보면,</p>
<ul>
<li>m이 1과 2일 때, NEWBIE! 출력</li>
<li>m이 n 이하면, OLDBIE! 출력</li>
<li>둘 다 아니면, TLE! 출력</li>
</ul>
<p>이것들을 파이썬으로 변환하면,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n, m &#x3D; map(int, input().split())</span><br><span class="line">if m &lt; 3:</span><br><span class="line">	print(&#39;NEWBIE!&#39;)</span><br><span class="line">elif m &lt;&#x3D; n:</span><br><span class="line">	print(&#39;OLDBIE!&#39;)</span><br><span class="line">else:</span><br><span class="line">	print(&#39;TLE!&#39;)</span><br></pre></td></tr></table></figure>
<p>가 된다.</p>
<p>이를 BOOL을 이용한 인덱싱으로 표현하였다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-25T16:51:00.000Z" title="2021-02-25T16:51:00.000Z">2021-02-26</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-26T01:53:20.000Z" title="2021-02-26T01:53:20.000Z">2021-02-26</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</a></span><span class="level-item">1분안에 읽기 (약 160 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/25/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-23178117%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈4 11549번 문제</a></h1><div class="content"><h1 id="Identifying-tea"><a href="#Identifying-tea" class="headerlink" title="Identifying tea"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/11549">Identifying tea</a></h1><p>Blind tea tasting is the skill of identifying a tea by using only your senses of smell and taste.</p>
<p>As part of the Ideal Challenge of Pure-Tea Consumers (ICPC), a local TV show is organized. During the show, a full teapot is prepared and five contestants are handed a cup of tea each. The participants must smell, taste and assess the sample so as to identify the tea type, which can be: (1) white tea; (2) green tea; (3) black tea; or (4) herbal tea. At the end, the answers are checked to determine the number of correct guesses.</p>
<p>Given the actual tea type and the answers provided, determine the number of contestants who got the correct answer.</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = [*<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())]</span><br><span class="line">print(b.count(a))</span><br></pre></td></tr></table></figure>
<p>Count 함수를 이용하여 특정값의 중복 수를 출력하였다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-24T22:51:00.000Z" title="2021-02-24T22:51:00.000Z">2021-02-25</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-25T08:13:54.000Z" title="2021-02-25T08:13:54.000Z">2021-02-25</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/">브론즈4</a></span><span class="level-item">2분안에 읽기 (약 280 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884-14935%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈4 15726번 문제</a></h1><div class="content"><h1 id="이칙연산"><a href="#이칙연산" class="headerlink" title="이칙연산"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/15726">이칙연산</a></h1><p>다음과 같이 세 수가 연속해서 주어졌을 때 한 번의 곱셈 기호와 한 번의 나눗셈 기호를 이용하여 만든 식 중 가장 큰 값을 출력하는 프로그램을 작성하시오. (세 수의 순서는 변하지 않는다.)</p>
<p>32 ☐ 16 ☐ 8</p>
<h2 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">print(<span class="built_in">int</span>(<span class="built_in">max</span>(a*b/c, a/b*c)))</span><br></pre></td></tr></table></figure>
<h3 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h3><p>문제의 요점은 3개의 숫자를 곱셈과 나누기를 이용해서 계산했을 때 어떻게 계산해야 가장 큰 수가 나오는지를 구하는 문제이다.</p>
<ol>
<li>숫자1 * 숫자2 / 숫자3</li>
<li>숫자1 / 숫자2 * 숫자3</li>
<li>1과 2의 결과값 크키 비교 후 큰 수 출력.</li>
</ol>
<p>여기서, 많이 헤매는 부분은 <code>//</code>, <code>/</code> 둘 중 어느 것을 써야하는지이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># 10 3 3 입력</span></span><br><span class="line">print(a*b/c, a/b*c)		<span class="comment"># 10.0 10.0 출력</span></span><br><span class="line">print(a*b//c, a//b*c)	<span class="comment"># 10 9 출력</span></span><br></pre></td></tr></table></figure>
<p><code>//</code>은 소수점을 버리기 때문에 값이 차이가 나는 것을 알 수 있다.</p>
<p>하지만 이 문제에서 왜 <code>/</code>을 쓰는지는 모르겠다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-24T08:38:00.000Z" title="2021-02-24T08:38:00.000Z">2021-02-24</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-24T18:12:47.000Z" title="2021-02-24T18:12:47.000Z">2021-02-25</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/">Basic</a></span><span class="level-item">4분안에 읽기 (약 616 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/">알고리즘 정리 - 동적 계획법, 분할 정복</a></h1><div class="content"><h1 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h1><h2 id="동적-계획법-Dynamic-Programming"><a href="#동적-계획법-Dynamic-Programming" class="headerlink" title="동적 계획법(Dynamic Programming)"></a>동적 계획법(Dynamic Programming)</h2><p>입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘</p>
<p>상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식</p>
<p>Memoization 기법을 사용함.<br><br>Memoization이란? 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술</p>
<p>문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용됨.</p>
<h2 id="분할-정복"><a href="#분할-정복" class="headerlink" title="분할 정복"></a>분할 정복</h2><p>문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘</p>
<p>하양식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식</p>
<p>문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음.</p>
<h2 id="공통점"><a href="#공통점" class="headerlink" title="공통점"></a>공통점</h2><p>문제를 잘게 쪼개서, 가장 작은 단위로 분할</p>
<h2 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h2><ul>
<li><p>동적 계획법<br><br>부분 문제는 중복되어, 상위 문제 해결 시 재활용됨.<br><br>Memoization 기법 사용(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)</p>
</li>
<li><p>분할 정복<br><br>부분 문제는 서로 중보되지 않음.<br><br>Memoization 기법 사용 안함.</p>
</li>
</ul>
<h2 id="이해"><a href="#이해" class="headerlink" title="이해"></a>이해</h2><h3 id="동적-계획법-알고리즘-이해"><a href="#동적-계획법-알고리즘-이해" class="headerlink" title="동적 계획법 알고리즘 이해"></a>동적 계획법 알고리즘 이해</h3><ol>
<li>피보나치 수열<br><img src="/images/pasted-225.png"></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(0) &#x3D; 0</span><br><span class="line">fibonacci(1) &#x3D; 1</span><br><span class="line">fibonacci(2) &#x3D; 1</span><br><span class="line">fibonacci(3) &#x3D; 2</span><br><span class="line">fibonacci(4) &#x3D; 3</span><br><span class="line">fibonacci(5) &#x3D; 5</span><br><span class="line">fibonacci(6) &#x3D; 8</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>Recursive call 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> fibo(num - <span class="number">1</span>) + fibo(num - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(fibo(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>fibo(4)를 구하기 위해선 fibo(3)과 fibo(2)가 필요하다.</p>
<p>fibo(3)은 fibo(2) + fibo(1)<br><br>fibo(2)은 fibo(1) + fibo(0)</p>
<p>fibo(4)를 구하기 위해선 fibo(0) 1개, fibo(1) 2개, fibo(2) 1개가 필요한데 이를 계속 계산하여 구하는 것은 비효율적이다.</p>
<p>이 부분을 해결하는 방법이 동적 계획법이다.</p>
<figure class="highlight python"><figcaption><span>DP 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp</span>(<span class="params">num</span>):</span></span><br><span class="line">    cache = [<span class="number">0</span> <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(num+<span class="number">1</span>)]</span><br><span class="line">    cache[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    cache[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num+<span class="number">1</span>):</span><br><span class="line">        cache[index] = cache[index<span class="number">-1</span>] + cache[index<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> cache[num]</span><br><span class="line"></span><br><span class="line">print(fibo_dp(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>리스트에 피보나치 수열을 계산 값을 저장을 하여 저장된 값을 사용하여 계산하여 효율을 높였다.</p>
<h3 id="분할-정복-알고리즘-이해"><a href="#분할-정복-알고리즘-이해" class="headerlink" title="분할 정복 알고리즘 이해"></a>분할 정복 알고리즘 이해</h3><p>퀵 정렬 알고리즘 참고</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-02-24T00:13:00.000Z" title="2021-02-24T00:13:00.000Z">2021-02-24</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-02-24T18:39:42.000Z" title="2021-02-24T18:39:42.000Z">2021-02-25</time>&nbsp;업데이트 됨</span><span class="level-item"> LRTK </span><span class="level-item"><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a><span> / </span><a class="link-muted" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/">Basic</a></span><span class="level-item">1분안에 읽기 (약 207 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/24/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-%ED%80%B5-%EC%A0%95%EB%A0%AC/">알고리즘 정리 - 퀵 정렬</a></h1><div class="content"><h1 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h1><img src="https://media.vlpt.us/images/rachell_lee/post/9d07118d-e83a-46c6-a1f9-7d667dbc09b5/quick_sort.gif">

<p>기준점(pivot)을 정해서, 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right)으로 모으는 함수를 작성함.<br><br>각 왼쪽(left), 오른쪽(right)은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복함.<br><br>함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right)을 리턴함.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    left, right = <span class="built_in">list</span>(), <span class="built_in">list</span>()</span><br><span class="line">    pivot = data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> pivot &gt; data[index]:</span><br><span class="line">            left.append(data[index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(data[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qsort(left) + [pivot] + qsort(right)</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line">print(qsort(data_list))</span><br></pre></td></tr></table></figure>
<h2 id="알고리즘-분석"><a href="#알고리즘-분석" class="headerlink" title="알고리즘 분석"></a>알고리즘 분석</h2><p>병합 정렬과 유사, 시간 복잡도는 O(n log n)</p>
<p>단, 최악의 경우 pivot이 가장 크거나 작으면 모든 데이터를와 비교하게 된다. O(n<sup>2</sup>)</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/3/">이전</a></div><div class="pagination-next"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/5/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">1</a></li><li><a class="pagination-link" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/3/">3</a></li><li><a class="pagination-link is-current" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/4/">4</a></li><li><a class="pagination-link" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/page/10/">10</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://media1.giphy.com/media/26BGAOkDPOZTXwmHK/giphy.gif?cid=ecf05e47e31mcqduw06hqdaodjpx28rx50ysaylnq9tgy9sc&amp;rid=giphy.gif" alt="LRTK"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LRTK</p><p class="is-size-6 is-block">CODER</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>South Korea / Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">158</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">32</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrtk-coder" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/lrtk-coder"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://wikidocs.net/book/1" target="_blank" rel="external nofollow noopener noreferrer"><span class="level-left"><span class="level-item">Jump To Python</span></span><span class="level-right"><span class="level-item tag">wikidocs.net</span></span></a></li><li><a class="level is-mobile" href="https://solved.ac/" target="_blank" rel="external nofollow noopener noreferrer"><span class="level-left"><span class="level-item">Solved</span></span><span class="level-right"><span class="level-item tag">solved.ac</span></span></a></li><li><a class="level is-mobile" href="https://www.root-me.org/" target="_blank" rel="external nofollow noopener noreferrer"><span class="level-left"><span class="level-item">Root-me</span></span><span class="level-right"><span class="level-item tag">www.root-me.org</span></span></a></li><li><a class="level is-mobile" href="https://github.com/Hack-with-Github/Awesome-Hacking" target="_blank" rel="external nofollow noopener noreferrer"><span class="level-left"><span class="level-item">Awesome-Hacking</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">66</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">11월 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BeeBox/"><span class="tag">BeeBox</span><span class="tag">44</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Big-O/"><span class="tag">Big-O</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bubble-Sort/"><span class="tag">Bubble Sort</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Double-Linked-List/"><span class="tag">Double Linked List</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dreamhack/"><span class="tag">Dreamhack</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hash-Table/"><span class="tag">Hash Table</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Insertion-Sort/"><span class="tag">Insertion Sort</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linked-List/"><span class="tag">Linked List</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedList/"><span class="tag">LinkedList</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OWASP/"><span class="tag">OWASP</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Queue/"><span class="tag">Queue</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selection-Sort/"><span class="tag">Selection Sort</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stack/"><span class="tag">Stack</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tree/"><span class="tag">Tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/backjoon/"><span class="tag">backjoon</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/backjoon-bronze4/"><span class="tag">backjoon bronze4</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%8B%A4%ED%81%AC%EC%9B%B9/"><span class="tag">다크웹</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/"><span class="tag">동적 계획법</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80/"><span class="tag">백준</span><span class="tag">88</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%882/"><span class="tag">백준 브론즈2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%883/"><span class="tag">백준 브론즈3</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%884/"><span class="tag">백준 브론즈4</span><span class="tag">45</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%885/"><span class="tag">백준 브론즈5</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%843/"><span class="tag">백준 실버3</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%844/"><span class="tag">백준 실버4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%845/"><span class="tag">백준 실버5</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B3%B4%EC%95%88%EB%89%B4%EC%8A%A4/"><span class="tag">보안뉴스</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/"><span class="tag">분할 정복</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B8%8C%EB%A1%A0%EC%A6%884/"><span class="tag">브론즈4</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%B5%EC%9E%A1%EB%8F%84/"><span class="tag">알고리즘 복잡도</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/"><span class="tag">재귀함수</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/"><span class="tag">퀵 정렬</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Security/"><span class="level-start"><span class="level-item">Security</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Security/Dreamhack/"><span class="level-start"><span class="level-item">Dreamhack</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Security/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">47</span></span></a><ul><li><a class="level is-mobile" href="/categories/Security/Web/BeeBox/"><span class="level-start"><span class="level-item">BeeBox</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/categories/Security/Web/OWASP-TOP-10/"><span class="level-start"><span class="level-item">OWASP TOP 10</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Security/%EB%B3%B4%EC%95%88%EB%89%B4%EC%8A%A4/"><span class="level-start"><span class="level-item">보안뉴스</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><span class="level-start"><span class="level-item">알고리즘</span></span><span class="level-end"><span class="level-item tag">93</span></span></a><ul><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Basic/"><span class="level-start"><span class="level-item">Basic</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"><span class="level-start"><span class="level-item">백준</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/"><span class="level-start"><span class="level-item">브론즈</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%884/"><span class="level-start"><span class="level-item">브론즈4</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%885/"><span class="level-start"><span class="level-item">브론즈5</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EC%8B%A4%EB%B2%84/"><span class="level-start"><span class="level-item">실버</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-24T15:48:03.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-2446%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 2446번 문제</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-24T15:23:00.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-1085%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 1085번 문제</a></p><p class="categories"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-24T15:10:00.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/24/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-10250%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 10250번 문제</a></p><p class="categories"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-23T15:14:00.000Z">2021-03-24</time></p><p class="title"><a href="/2021/03/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-10872%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 10872번 문제</a></p><p class="categories"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-23T15:00:00.000Z">2021-03-24</time></p><p class="title"><a href="/2021/03/23/%EB%B0%B1%EC%A4%80-%EB%B8%8C%EB%A1%A0%EC%A6%88-11718%EB%B2%88-%EB%AC%B8%EC%A0%9C/">백준 브론즈 11718번 문제</a></p><p class="categories"><a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/">백준</a> / <a href="/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/%EB%B8%8C%EB%A1%A0%EC%A6%88/">브론즈</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Logo4.svg" alt="LRTK Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 LRTK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>